/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// node_modules/strtok3/lib/FsPromise.js
var require_FsPromise = __commonJS({
  "node_modules/strtok3/lib/FsPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.readFile = exports2.writeFileSync = exports2.writeFile = exports2.read = exports2.open = exports2.close = exports2.stat = exports2.createReadStream = exports2.pathExists = void 0;
    var fs3 = require("fs");
    exports2.pathExists = fs3.existsSync;
    exports2.createReadStream = fs3.createReadStream;
    async function stat(path3) {
      return new Promise((resolve2, reject2) => {
        fs3.stat(path3, (err, stats) => {
          err ? reject2(err) : resolve2(stats);
        });
      });
    }
    exports2.stat = stat;
    async function close(fd) {
      return new Promise((resolve2, reject2) => {
        fs3.close(fd, (err) => {
          err ? reject2(err) : resolve2();
        });
      });
    }
    exports2.close = close;
    async function open(path3, mode) {
      return new Promise((resolve2, reject2) => {
        fs3.open(path3, mode, (err, fd) => {
          err ? reject2(err) : resolve2(fd);
        });
      });
    }
    exports2.open = open;
    async function read(fd, buffer, offset, length, position) {
      return new Promise((resolve2, reject2) => {
        fs3.read(fd, buffer, offset, length, position, (err, bytesRead, _buffer) => {
          err ? reject2(err) : resolve2({ bytesRead, buffer: _buffer });
        });
      });
    }
    exports2.read = read;
    async function writeFile(path3, data) {
      return new Promise((resolve2, reject2) => {
        fs3.writeFile(path3, data, (err) => {
          err ? reject2(err) : resolve2();
        });
      });
    }
    exports2.writeFile = writeFile;
    function writeFileSync(path3, data) {
      fs3.writeFileSync(path3, data);
    }
    exports2.writeFileSync = writeFileSync;
    async function readFile(path3) {
      return new Promise((resolve2, reject2) => {
        fs3.readFile(path3, (err, buffer) => {
          err ? reject2(err) : resolve2(buffer);
        });
      });
    }
    exports2.readFile = readFile;
  }
});

// node_modules/peek-readable/lib/EndOfFileStream.js
var require_EndOfFileStream = __commonJS({
  "node_modules/peek-readable/lib/EndOfFileStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.EndOfStreamError = exports2.defaultMessages = void 0;
    exports2.defaultMessages = "End-Of-Stream";
    var EndOfStreamError = class extends Error {
      constructor() {
        super(exports2.defaultMessages);
      }
    };
    exports2.EndOfStreamError = EndOfStreamError;
  }
});

// node_modules/peek-readable/lib/Deferred.js
var require_Deferred = __commonJS({
  "node_modules/peek-readable/lib/Deferred.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this.resolve = () => null, this.reject = () => null, this.promise = new Promise((resolve2, reject2) => {
          this.reject = reject2, this.resolve = resolve2;
        });
      }
    };
    exports2.Deferred = Deferred;
  }
});

// node_modules/peek-readable/lib/StreamReader.js
var require_StreamReader = __commonJS({
  "node_modules/peek-readable/lib/StreamReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.StreamReader = exports2.EndOfStreamError = void 0;
    var EndOfFileStream_1 = require_EndOfFileStream(), Deferred_1 = require_Deferred(), EndOfFileStream_2 = require_EndOfFileStream();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: !0, get: function() {
      return EndOfFileStream_2.EndOfStreamError;
    } });
    var maxStreamReadSize = 1 * 1024 * 1024, StreamReader = class {
      constructor(s) {
        if (this.s = s, this.deferred = null, this.endOfStream = !1, this.peekQueue = [], !s.read || !s.once)
          throw new Error("Expected an instance of stream.Readable");
        this.s.once("end", () => this.reject(new EndOfFileStream_1.EndOfStreamError())), this.s.once("error", (err) => this.reject(err)), this.s.once("close", () => this.reject(new Error("Stream closed")));
      }
      /**
       * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
       * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes peeked
       */
      async peek(uint8Array, offset, length) {
        let bytesRead = await this.read(uint8Array, offset, length);
        return this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)), bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset - Offset target
       * @param length - Number of bytes to read
       * @returns Number of bytes read
       */
      async read(buffer, offset, length) {
        if (length === 0)
          return 0;
        if (this.peekQueue.length === 0 && this.endOfStream)
          throw new EndOfFileStream_1.EndOfStreamError();
        let remaining = length, bytesRead = 0;
        for (; this.peekQueue.length > 0 && remaining > 0; ) {
          let peekData = this.peekQueue.pop();
          if (!peekData)
            throw new Error("peekData should be defined");
          let lenCopy = Math.min(peekData.length, remaining);
          buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead), bytesRead += lenCopy, remaining -= lenCopy, lenCopy < peekData.length && this.peekQueue.push(peekData.subarray(lenCopy));
        }
        for (; remaining > 0 && !this.endOfStream; ) {
          let reqLen = Math.min(remaining, maxStreamReadSize), chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
          if (bytesRead += chunkLen, chunkLen < reqLen)
            break;
          remaining -= chunkLen;
        }
        return bytesRead;
      }
      /**
       * Read chunk from stream
       * @param buffer Target Uint8Array (or Buffer) to store data read from stream in
       * @param offset Offset target
       * @param length Number of bytes to read
       * @returns Number of bytes read
       */
      async readFromStream(buffer, offset, length) {
        let readBuffer = this.s.read(length);
        if (readBuffer)
          return buffer.set(readBuffer, offset), readBuffer.length;
        {
          let request = {
            buffer,
            offset,
            length,
            deferred: new Deferred_1.Deferred()
          };
          return this.deferred = request.deferred, this.s.once("readable", () => {
            this.readDeferred(request);
          }), request.deferred.promise;
        }
      }
      /**
       * Process deferred read request
       * @param request Deferred read request
       */
      readDeferred(request) {
        let readBuffer = this.s.read(request.length);
        readBuffer ? (request.buffer.set(readBuffer, request.offset), request.deferred.resolve(readBuffer.length), this.deferred = null) : this.s.once("readable", () => {
          this.readDeferred(request);
        });
      }
      reject(err) {
        this.endOfStream = !0, this.deferred && (this.deferred.reject(err), this.deferred = null);
      }
    };
    exports2.StreamReader = StreamReader;
  }
});

// node_modules/peek-readable/lib/index.js
var require_lib = __commonJS({
  "node_modules/peek-readable/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.StreamReader = exports2.EndOfStreamError = void 0;
    var EndOfFileStream_1 = require_EndOfFileStream();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: !0, get: function() {
      return EndOfFileStream_1.EndOfStreamError;
    } });
    var StreamReader_1 = require_StreamReader();
    Object.defineProperty(exports2, "StreamReader", { enumerable: !0, get: function() {
      return StreamReader_1.StreamReader;
    } });
  }
});

// node_modules/strtok3/lib/AbstractTokenizer.js
var require_AbstractTokenizer = __commonJS({
  "node_modules/strtok3/lib/AbstractTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AbstractTokenizer = void 0;
    var peek_readable_1 = require_lib(), AbstractTokenizer = class {
      constructor(fileInfo) {
        this.position = 0, this.numBuffer = new Uint8Array(8), this.fileInfo = fileInfo || {};
      }
      /**
       * Read a token from the tokenizer-stream
       * @param token - The token to read
       * @param position - If provided, the desired position in the tokenizer-stream
       * @returns Promise with token data
       */
      async readToken(token, position = this.position) {
        let uint8Array = Buffer.alloc(token.len);
        if (await this.readBuffer(uint8Array, { position }) < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      /**
       * Peek a token from the tokenizer-stream.
       * @param token - Token to peek from the tokenizer-stream.
       * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
       * @returns Promise with token data
       */
      async peekToken(token, position = this.position) {
        let uint8Array = Buffer.alloc(token.len);
        if (await this.peekBuffer(uint8Array, { position }) < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async readNumber(token) {
        if (await this.readBuffer(this.numBuffer, { length: token.len }) < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      /**
       * Read a numeric token from the stream
       * @param token - Numeric token
       * @returns Promise with number
       */
      async peekNumber(token) {
        if (await this.peekBuffer(this.numBuffer, { length: token.len }) < token.len)
          throw new peek_readable_1.EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      /**
       * Ignore number of bytes, advances the pointer in under tokenizer-stream.
       * @param length - Number of bytes to ignore
       * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
       */
      async ignore(length) {
        if (this.fileInfo.size !== void 0) {
          let bytesLeft = this.fileInfo.size - this.position;
          if (length > bytesLeft)
            return this.position += bytesLeft, bytesLeft;
        }
        return this.position += length, length;
      }
      async close() {
      }
      normalizeOptions(uint8Array, options) {
        if (options && options.position !== void 0 && options.position < this.position)
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        return options ? {
          mayBeLess: options.mayBeLess === !0,
          offset: options.offset ? options.offset : 0,
          length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
          position: options.position ? options.position : this.position
        } : {
          mayBeLess: !1,
          offset: 0,
          length: uint8Array.length,
          position: this.position
        };
      }
    };
    exports2.AbstractTokenizer = AbstractTokenizer;
  }
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var require_ReadStreamTokenizer = __commonJS({
  "node_modules/strtok3/lib/ReadStreamTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ReadStreamTokenizer = void 0;
    var AbstractTokenizer_1 = require_AbstractTokenizer(), peek_readable_1 = require_lib(), maxBufferSize = 256e3, ReadStreamTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      constructor(stream2, fileInfo) {
        super(fileInfo), this.streamReader = new peek_readable_1.StreamReader(stream2);
      }
      /**
       * Get file information, an HTTP-client may implement this doing a HEAD request
       * @return Promise with file information
       */
      async getFileInfo() {
        return this.fileInfo;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
       * @param options - Read behaviour options
       * @returns Promise with number of bytes read
       */
      async readBuffer(uint8Array, options) {
        let normOptions = this.normalizeOptions(uint8Array, options), skipBytes = normOptions.position - this.position;
        if (skipBytes > 0)
          return await this.ignore(skipBytes), this.readBuffer(uint8Array, options);
        if (skipBytes < 0)
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        if (normOptions.length === 0)
          return 0;
        let bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        if (this.position += bytesRead, (!options || !options.mayBeLess) && bytesRead < normOptions.length)
          throw new peek_readable_1.EndOfStreamError();
        return bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise with number of bytes peeked
       */
      async peekBuffer(uint8Array, options) {
        let normOptions = this.normalizeOptions(uint8Array, options), bytesRead = 0;
        if (normOptions.position) {
          let skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            let skipBuffer = new Uint8Array(normOptions.length + skipBytes);
            return bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess }), uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset), bytesRead - skipBytes;
          } else if (skipBytes < 0)
            throw new Error("Cannot peek from a negative offset in a stream");
        }
        if (normOptions.length > 0) {
          try {
            bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
          } catch (err) {
            if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError)
              return 0;
            throw err;
          }
          if (!normOptions.mayBeLess && bytesRead < normOptions.length)
            throw new peek_readable_1.EndOfStreamError();
        }
        return bytesRead;
      }
      async ignore(length) {
        let bufSize = Math.min(maxBufferSize, length), buf = new Uint8Array(bufSize), totBytesRead = 0;
        for (; totBytesRead < length; ) {
          let remaining = length - totBytesRead, bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
          if (bytesRead < 0)
            return bytesRead;
          totBytesRead += bytesRead;
        }
        return totBytesRead;
      }
    };
    exports2.ReadStreamTokenizer = ReadStreamTokenizer;
  }
});

// node_modules/strtok3/lib/BufferTokenizer.js
var require_BufferTokenizer = __commonJS({
  "node_modules/strtok3/lib/BufferTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.BufferTokenizer = void 0;
    var peek_readable_1 = require_lib(), AbstractTokenizer_1 = require_AbstractTokenizer(), BufferTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      /**
       * Construct BufferTokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param fileInfo - Pass additional file information to the tokenizer
       */
      constructor(uint8Array, fileInfo) {
        super(fileInfo), this.uint8Array = uint8Array, this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
      }
      /**
       * Read buffer from tokenizer
       * @param uint8Array - Uint8Array to tokenize
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async readBuffer(uint8Array, options) {
        if (options && options.position) {
          if (options.position < this.position)
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          this.position = options.position;
        }
        let bytesRead = await this.peekBuffer(uint8Array, options);
        return this.position += bytesRead, bytesRead;
      }
      /**
       * Peek (read ahead) buffer from tokenizer
       * @param uint8Array
       * @param options - Read behaviour options
       * @returns {Promise<number>}
       */
      async peekBuffer(uint8Array, options) {
        let normOptions = this.normalizeOptions(uint8Array, options), bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length)
          throw new peek_readable_1.EndOfStreamError();
        return uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset), bytes2read;
      }
      async close() {
      }
    };
    exports2.BufferTokenizer = BufferTokenizer;
  }
});

// node_modules/strtok3/lib/core.js
var require_core = __commonJS({
  "node_modules/strtok3/lib/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.fromBuffer = exports2.fromStream = exports2.EndOfStreamError = void 0;
    var ReadStreamTokenizer_1 = require_ReadStreamTokenizer(), BufferTokenizer_1 = require_BufferTokenizer(), peek_readable_1 = require_lib();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: !0, get: function() {
      return peek_readable_1.EndOfStreamError;
    } });
    function fromStream2(stream2, fileInfo) {
      return fileInfo = fileInfo || {}, new ReadStreamTokenizer_1.ReadStreamTokenizer(stream2, fileInfo);
    }
    exports2.fromStream = fromStream2;
    function fromBuffer2(uint8Array, fileInfo) {
      return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);
    }
    exports2.fromBuffer = fromBuffer2;
  }
});

// node_modules/strtok3/lib/FileTokenizer.js
var require_FileTokenizer = __commonJS({
  "node_modules/strtok3/lib/FileTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.fromFile = exports2.FileTokenizer = void 0;
    var AbstractTokenizer_1 = require_AbstractTokenizer(), peek_readable_1 = require_lib(), fs3 = require_FsPromise(), FileTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      constructor(fd, fileInfo) {
        super(fileInfo), this.fd = fd;
      }
      /**
       * Read buffer from file
       * @param uint8Array - Uint8Array to write result to
       * @param options - Read behaviour options
       * @returns Promise number of bytes read
       */
      async readBuffer(uint8Array, options) {
        let normOptions = this.normalizeOptions(uint8Array, options);
        this.position = normOptions.position;
        let res = await fs3.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if (this.position += res.bytesRead, res.bytesRead < normOptions.length && (!options || !options.mayBeLess))
          throw new peek_readable_1.EndOfStreamError();
        return res.bytesRead;
      }
      /**
       * Peek buffer from file
       * @param uint8Array - Uint8Array (or Buffer) to write data to
       * @param options - Read behaviour options
       * @returns Promise number of bytes read
       */
      async peekBuffer(uint8Array, options) {
        let normOptions = this.normalizeOptions(uint8Array, options), res = await fs3.read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if (!normOptions.mayBeLess && res.bytesRead < normOptions.length)
          throw new peek_readable_1.EndOfStreamError();
        return res.bytesRead;
      }
      async close() {
        return fs3.close(this.fd);
      }
    };
    exports2.FileTokenizer = FileTokenizer;
    async function fromFile(sourceFilePath) {
      let stat = await fs3.stat(sourceFilePath);
      if (!stat.isFile)
        throw new Error(`File not a file: ${sourceFilePath}`);
      let fd = await fs3.open(sourceFilePath, "r");
      return new FileTokenizer(fd, { path: sourceFilePath, size: stat.size });
    }
    exports2.fromFile = fromFile;
  }
});

// node_modules/strtok3/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/strtok3/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.fromStream = exports2.fromBuffer = exports2.EndOfStreamError = exports2.fromFile = void 0;
    var fs3 = require_FsPromise(), core = require_core(), FileTokenizer_1 = require_FileTokenizer();
    Object.defineProperty(exports2, "fromFile", { enumerable: !0, get: function() {
      return FileTokenizer_1.fromFile;
    } });
    var core_1 = require_core();
    Object.defineProperty(exports2, "EndOfStreamError", { enumerable: !0, get: function() {
      return core_1.EndOfStreamError;
    } });
    Object.defineProperty(exports2, "fromBuffer", { enumerable: !0, get: function() {
      return core_1.fromBuffer;
    } });
    async function fromStream2(stream2, fileInfo) {
      if (fileInfo = fileInfo || {}, stream2.path) {
        let stat = await fs3.stat(stream2.path);
        fileInfo.path = stream2.path, fileInfo.size = stat.size;
      }
      return core.fromStream(stream2, fileInfo);
    }
    exports2.fromStream = fromStream2;
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i];
      for (i += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8)
        ;
      for (m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8)
        ;
      if (e === 0)
        e = 1 - eBias;
      else {
        if (e === eMax)
          return m ? NaN : (s ? -1 : 1) * (1 / 0);
        m = m + Math.pow(2, mLen), e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      for (value = Math.abs(value), isNaN(value) || value === 1 / 0 ? (m = isNaN(value) ? 1 : 0, e = eMax) : (e = Math.floor(Math.log(value) / Math.LN2), value * (c = Math.pow(2, -e)) < 1 && (e--, c *= 2), e + eBias >= 1 ? value += rt / c : value += rt * Math.pow(2, 1 - eBias), value * c >= 2 && (e++, c /= 2), e + eBias >= eMax ? (m = 0, e = eMax) : e + eBias >= 1 ? (m = (value * c - 1) * Math.pow(2, mLen), e = e + eBias) : (m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0)); mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8)
        ;
      for (e = e << mLen | m, eLen += mLen; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8)
        ;
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/token-types/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/token-types/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AnsiStringType = exports2.StringType = exports2.BufferType = exports2.Uint8ArrayType = exports2.IgnoreType = exports2.Float80_LE = exports2.Float80_BE = exports2.Float64_LE = exports2.Float64_BE = exports2.Float32_LE = exports2.Float32_BE = exports2.Float16_LE = exports2.Float16_BE = exports2.INT64_BE = exports2.UINT64_BE = exports2.INT64_LE = exports2.UINT64_LE = exports2.INT32_LE = exports2.INT32_BE = exports2.INT24_BE = exports2.INT24_LE = exports2.INT16_LE = exports2.INT16_BE = exports2.INT8 = exports2.UINT32_BE = exports2.UINT32_LE = exports2.UINT24_BE = exports2.UINT24_LE = exports2.UINT16_BE = exports2.UINT16_LE = exports2.UINT8 = void 0;
    var ieee754 = require_ieee754();
    function dv(array) {
      return new DataView(array.buffer, array.byteOffset);
    }
    exports2.UINT8 = {
      len: 1,
      get(array, offset) {
        return dv(array).getUint8(offset);
      },
      put(array, offset, value) {
        return dv(array).setUint8(offset, value), offset + 1;
      }
    };
    exports2.UINT16_LE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset, !0);
      },
      put(array, offset, value) {
        return dv(array).setUint16(offset, value, !0), offset + 2;
      }
    };
    exports2.UINT16_BE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset);
      },
      put(array, offset, value) {
        return dv(array).setUint16(offset, value), offset + 2;
      }
    };
    exports2.UINT24_LE = {
      len: 3,
      get(array, offset) {
        let dataView = dv(array);
        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, !0) << 8);
      },
      put(array, offset, value) {
        let dataView = dv(array);
        return dataView.setUint8(offset, value & 255), dataView.setUint16(offset + 1, value >> 8, !0), offset + 3;
      }
    };
    exports2.UINT24_BE = {
      len: 3,
      get(array, offset) {
        let dataView = dv(array);
        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
      },
      put(array, offset, value) {
        let dataView = dv(array);
        return dataView.setUint16(offset, value >> 8), dataView.setUint8(offset + 2, value & 255), offset + 3;
      }
    };
    exports2.UINT32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset, !0);
      },
      put(array, offset, value) {
        return dv(array).setUint32(offset, value, !0), offset + 4;
      }
    };
    exports2.UINT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset);
      },
      put(array, offset, value) {
        return dv(array).setUint32(offset, value), offset + 4;
      }
    };
    exports2.INT8 = {
      len: 1,
      get(array, offset) {
        return dv(array).getInt8(offset);
      },
      put(array, offset, value) {
        return dv(array).setInt8(offset, value), offset + 1;
      }
    };
    exports2.INT16_BE = {
      len: 2,
      get(array, offset) {
        return dv(array).getInt16(offset);
      },
      put(array, offset, value) {
        return dv(array).setInt16(offset, value), offset + 2;
      }
    };
    exports2.INT16_LE = {
      len: 2,
      get(array, offset) {
        return dv(array).getInt16(offset, !0);
      },
      put(array, offset, value) {
        return dv(array).setInt16(offset, value, !0), offset + 2;
      }
    };
    exports2.INT24_LE = {
      len: 3,
      get(array, offset) {
        let unsigned = exports2.UINT24_LE.get(array, offset);
        return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
      },
      put(array, offset, value) {
        let dataView = dv(array);
        return dataView.setUint8(offset, value & 255), dataView.setUint16(offset + 1, value >> 8, !0), offset + 3;
      }
    };
    exports2.INT24_BE = {
      len: 3,
      get(array, offset) {
        let unsigned = exports2.UINT24_BE.get(array, offset);
        return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
      },
      put(array, offset, value) {
        let dataView = dv(array);
        return dataView.setUint16(offset, value >> 8), dataView.setUint8(offset + 2, value & 255), offset + 3;
      }
    };
    exports2.INT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getInt32(offset);
      },
      put(array, offset, value) {
        return dv(array).setInt32(offset, value), offset + 4;
      }
    };
    exports2.INT32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getInt32(offset, !0);
      },
      put(array, offset, value) {
        return dv(array).setInt32(offset, value, !0), offset + 4;
      }
    };
    exports2.UINT64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigUint64(offset, !0);
      },
      put(array, offset, value) {
        return dv(array).setBigUint64(offset, value, !0), offset + 8;
      }
    };
    exports2.INT64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigInt64(offset, !0);
      },
      put(array, offset, value) {
        return dv(array).setBigInt64(offset, value, !0), offset + 8;
      }
    };
    exports2.UINT64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigUint64(offset);
      },
      put(array, offset, value) {
        return dv(array).setBigUint64(offset, value), offset + 8;
      }
    };
    exports2.INT64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigInt64(offset);
      },
      put(array, offset, value) {
        return dv(array).setBigInt64(offset, value), offset + 8;
      }
    };
    exports2.Float16_BE = {
      len: 2,
      get(dataView, offset) {
        return ieee754.read(dataView, offset, !1, 10, this.len);
      },
      put(dataView, offset, value) {
        return ieee754.write(dataView, value, offset, !1, 10, this.len), offset + this.len;
      }
    };
    exports2.Float16_LE = {
      len: 2,
      get(array, offset) {
        return ieee754.read(array, offset, !0, 10, this.len);
      },
      put(array, offset, value) {
        return ieee754.write(array, value, offset, !0, 10, this.len), offset + this.len;
      }
    };
    exports2.Float32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getFloat32(offset);
      },
      put(array, offset, value) {
        return dv(array).setFloat32(offset, value), offset + 4;
      }
    };
    exports2.Float32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getFloat32(offset, !0);
      },
      put(array, offset, value) {
        return dv(array).setFloat32(offset, value, !0), offset + 4;
      }
    };
    exports2.Float64_BE = {
      len: 8,
      get(array, offset) {
        return dv(array).getFloat64(offset);
      },
      put(array, offset, value) {
        return dv(array).setFloat64(offset, value), offset + 8;
      }
    };
    exports2.Float64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getFloat64(offset, !0);
      },
      put(array, offset, value) {
        return dv(array).setFloat64(offset, value, !0), offset + 8;
      }
    };
    exports2.Float80_BE = {
      len: 10,
      get(array, offset) {
        return ieee754.read(array, offset, !1, 63, this.len);
      },
      put(array, offset, value) {
        return ieee754.write(array, value, offset, !1, 63, this.len), offset + this.len;
      }
    };
    exports2.Float80_LE = {
      len: 10,
      get(array, offset) {
        return ieee754.read(array, offset, !0, 63, this.len);
      },
      put(array, offset, value) {
        return ieee754.write(array, value, offset, !0, 63, this.len), offset + this.len;
      }
    };
    var IgnoreType = class {
      /**
       * @param len number of bytes to ignore
       */
      constructor(len) {
        this.len = len;
      }
      // ToDo: don't read, but skip data
      get(array, off) {
      }
    };
    exports2.IgnoreType = IgnoreType;
    var Uint8ArrayType = class {
      constructor(len) {
        this.len = len;
      }
      get(array, offset) {
        return array.subarray(offset, offset + this.len);
      }
    };
    exports2.Uint8ArrayType = Uint8ArrayType;
    var BufferType = class {
      constructor(len) {
        this.len = len;
      }
      get(uint8Array, off) {
        return Buffer.from(uint8Array.subarray(off, off + this.len));
      }
    };
    exports2.BufferType = BufferType;
    var StringType = class {
      constructor(len, encoding) {
        this.len = len, this.encoding = encoding;
      }
      get(uint8Array, offset) {
        return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
      }
    };
    exports2.StringType = StringType;
    var AnsiStringType = class _AnsiStringType {
      constructor(len) {
        this.len = len;
      }
      static decode(buffer, offset, until) {
        let str = "";
        for (let i = offset; i < until; ++i)
          str += _AnsiStringType.codePointToString(_AnsiStringType.singleByteDecoder(buffer[i]));
        return str;
      }
      static inRange(a, min, max) {
        return min <= a && a <= max;
      }
      static codePointToString(cp) {
        return cp <= 65535 ? String.fromCharCode(cp) : (cp -= 65536, String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320));
      }
      static singleByteDecoder(bite) {
        if (_AnsiStringType.inRange(bite, 0, 127))
          return bite;
        let codePoint = _AnsiStringType.windows1252[bite - 128];
        if (codePoint === null)
          throw Error("invaliding encoding");
        return codePoint;
      }
      get(buffer, offset = 0) {
        return _AnsiStringType.decode(buffer, offset, offset + this.len);
      }
    };
    exports2.AnsiStringType = AnsiStringType;
    AnsiStringType.windows1252 = [
      8364,
      129,
      8218,
      402,
      8222,
      8230,
      8224,
      8225,
      710,
      8240,
      352,
      8249,
      338,
      141,
      381,
      143,
      144,
      8216,
      8217,
      8220,
      8221,
      8226,
      8211,
      8212,
      732,
      8482,
      353,
      8250,
      339,
      157,
      382,
      376,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ];
  }
});

// node_modules/file-type/util.js
var require_util = __commonJS({
  "node_modules/file-type/util.js"(exports2) {
    "use strict";
    exports2.stringToBytes = (string) => [...string].map((character) => character.charCodeAt(0));
    exports2.tarHeaderChecksumMatches = (buffer, offset = 0) => {
      let readSum = parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
      if (isNaN(readSum))
        return !1;
      let sum = 8 * 32;
      for (let i = offset; i < offset + 148; i++)
        sum += buffer[i];
      for (let i = offset + 156; i < offset + 512; i++)
        sum += buffer[i];
      return readSum === sum;
    };
    exports2.uint32SyncSafeToken = {
      get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
      len: 4
    };
  }
});

// node_modules/file-type/supported.js
var require_supported = __commonJS({
  "node_modules/file-type/supported.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      extensions: [
        "jpg",
        "png",
        "apng",
        "gif",
        "webp",
        "flif",
        "xcf",
        "cr2",
        "cr3",
        "orf",
        "arw",
        "dng",
        "nef",
        "rw2",
        "raf",
        "tif",
        "bmp",
        "icns",
        "jxr",
        "psd",
        "indd",
        "zip",
        "tar",
        "rar",
        "gz",
        "bz2",
        "7z",
        "dmg",
        "mp4",
        "mid",
        "mkv",
        "webm",
        "mov",
        "avi",
        "mpg",
        "mp2",
        "mp3",
        "m4a",
        "oga",
        "ogg",
        "ogv",
        "opus",
        "flac",
        "wav",
        "spx",
        "amr",
        "pdf",
        "epub",
        "exe",
        "swf",
        "rtf",
        "wasm",
        "woff",
        "woff2",
        "eot",
        "ttf",
        "otf",
        "ico",
        "flv",
        "ps",
        "xz",
        "sqlite",
        "nes",
        "crx",
        "xpi",
        "cab",
        "deb",
        "ar",
        "rpm",
        "Z",
        "lz",
        "cfb",
        "mxf",
        "mts",
        "blend",
        "bpg",
        "docx",
        "pptx",
        "xlsx",
        "3gp",
        "3g2",
        "jp2",
        "jpm",
        "jpx",
        "mj2",
        "aif",
        "qcp",
        "odt",
        "ods",
        "odp",
        "xml",
        "mobi",
        "heic",
        "cur",
        "ktx",
        "ape",
        "wv",
        "dcm",
        "ics",
        "glb",
        "pcap",
        "dsf",
        "lnk",
        "alias",
        "voc",
        "ac3",
        "m4v",
        "m4p",
        "m4b",
        "f4v",
        "f4p",
        "f4b",
        "f4a",
        "mie",
        "asf",
        "ogm",
        "ogx",
        "mpc",
        "arrow",
        "shp",
        "aac",
        "mp1",
        "it",
        "s3m",
        "xm",
        "ai",
        "skp",
        "avif",
        "eps",
        "lzh",
        "pgp",
        "asar",
        "stl",
        "chm",
        "3mf",
        "zst",
        "jxl",
        "vcf"
      ],
      mimeTypes: [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/flif",
        "image/x-xcf",
        "image/x-canon-cr2",
        "image/x-canon-cr3",
        "image/tiff",
        "image/bmp",
        "image/vnd.ms-photo",
        "image/vnd.adobe.photoshop",
        "application/x-indesign",
        "application/epub+zip",
        "application/x-xpinstall",
        "application/vnd.oasis.opendocument.text",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.presentation",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/zip",
        "application/x-tar",
        "application/x-rar-compressed",
        "application/gzip",
        "application/x-bzip2",
        "application/x-7z-compressed",
        "application/x-apple-diskimage",
        "application/x-apache-arrow",
        "video/mp4",
        "audio/midi",
        "video/x-matroska",
        "video/webm",
        "video/quicktime",
        "video/vnd.avi",
        "audio/vnd.wave",
        "audio/qcelp",
        "audio/x-ms-asf",
        "video/x-ms-asf",
        "application/vnd.ms-asf",
        "video/mpeg",
        "video/3gpp",
        "audio/mpeg",
        "audio/mp4",
        // RFC 4337
        "audio/opus",
        "video/ogg",
        "audio/ogg",
        "application/ogg",
        "audio/x-flac",
        "audio/ape",
        "audio/wavpack",
        "audio/amr",
        "application/pdf",
        "application/x-msdownload",
        "application/x-shockwave-flash",
        "application/rtf",
        "application/wasm",
        "font/woff",
        "font/woff2",
        "application/vnd.ms-fontobject",
        "font/ttf",
        "font/otf",
        "image/x-icon",
        "video/x-flv",
        "application/postscript",
        "application/eps",
        "application/x-xz",
        "application/x-sqlite3",
        "application/x-nintendo-nes-rom",
        "application/x-google-chrome-extension",
        "application/vnd.ms-cab-compressed",
        "application/x-deb",
        "application/x-unix-archive",
        "application/x-rpm",
        "application/x-compress",
        "application/x-lzip",
        "application/x-cfb",
        "application/x-mie",
        "application/mxf",
        "video/mp2t",
        "application/x-blender",
        "image/bpg",
        "image/jp2",
        "image/jpx",
        "image/jpm",
        "image/mj2",
        "audio/aiff",
        "application/xml",
        "application/x-mobipocket-ebook",
        "image/heif",
        "image/heif-sequence",
        "image/heic",
        "image/heic-sequence",
        "image/icns",
        "image/ktx",
        "application/dicom",
        "audio/x-musepack",
        "text/calendar",
        "text/vcard",
        "model/gltf-binary",
        "application/vnd.tcpdump.pcap",
        "audio/x-dsf",
        // Non-standard
        "application/x.ms.shortcut",
        // Invented by us
        "application/x.apple.alias",
        // Invented by us
        "audio/x-voc",
        "audio/vnd.dolby.dd-raw",
        "audio/x-m4a",
        "image/apng",
        "image/x-olympus-orf",
        "image/x-sony-arw",
        "image/x-adobe-dng",
        "image/x-nikon-nef",
        "image/x-panasonic-rw2",
        "image/x-fujifilm-raf",
        "video/x-m4v",
        "video/3gpp2",
        "application/x-esri-shape",
        "audio/aac",
        "audio/x-it",
        "audio/x-s3m",
        "audio/x-xm",
        "video/MP1S",
        "video/MP2P",
        "application/vnd.sketchup.skp",
        "image/avif",
        "application/x-lzh-compressed",
        "application/pgp-encrypted",
        "application/x-asar",
        "model/stl",
        "application/vnd.ms-htmlhelp",
        "model/3mf",
        "image/jxl",
        "application/zstd"
      ]
    };
  }
});

// node_modules/file-type/core.js
var require_core2 = __commonJS({
  "node_modules/file-type/core.js"(exports, module) {
    "use strict";
    var Token = require_lib3(), strtok3 = require_core(), {
      stringToBytes,
      tarHeaderChecksumMatches,
      uint32SyncSafeToken
    } = require_util(), supported = require_supported(), minimumBytes = 4100;
    async function fromStream(stream2) {
      let tokenizer = await strtok3.fromStream(stream2);
      try {
        return await fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async function fromBuffer(input) {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input)))
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      let buffer = input instanceof Buffer ? input : Buffer.from(input);
      if (!(buffer && buffer.length > 1))
        return;
      let tokenizer = strtok3.fromBuffer(buffer);
      return fromTokenizer(tokenizer);
    }
    function _check(buffer, headers, options) {
      options = {
        offset: 0,
        ...options
      };
      for (let [index, header] of headers.entries())
        if (options.mask) {
          if (header !== (options.mask[index] & buffer[index + options.offset]))
            return !1;
        } else if (header !== buffer[index + options.offset])
          return !1;
      return !0;
    }
    async function fromTokenizer(tokenizer) {
      try {
        return _fromTokenizer(tokenizer);
      } catch (error) {
        if (!(error instanceof strtok3.EndOfStreamError))
          throw error;
      }
    }
    async function _fromTokenizer(tokenizer) {
      let buffer = Buffer.alloc(minimumBytes), bytesRead = 12, check = (header, options) => _check(buffer, header, options), checkString = (header, options) => check(stringToBytes(header), options);
      if (tokenizer.fileInfo.size || (tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER), await tokenizer.peekBuffer(buffer, { length: bytesRead, mayBeLess: !0 }), check([66, 77]))
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      if (check([11, 119]))
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      if (check([120, 1]))
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      if (check([77, 90]))
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      if (check([37, 33]))
        return await tokenizer.peekBuffer(buffer, { length: 24, mayBeLess: !0 }), checkString("PS-Adobe-", { offset: 2 }) && checkString(" EPSF-", { offset: 14 }) ? {
          ext: "eps",
          mime: "application/eps"
        } : {
          ext: "ps",
          mime: "application/postscript"
        };
      if (check([31, 160]) || check([31, 157]))
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      if (check([255, 216, 255]))
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      if (check([73, 73, 188]))
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      if (check([31, 139, 8]))
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      if (check([66, 90, 104]))
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      if (checkString("ID3")) {
        await tokenizer.ignore(6);
        let id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);
        return tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size ? {
          ext: "mp3",
          mime: "audio/mpeg"
        } : (await tokenizer.ignore(id3HeaderLen), fromTokenizer(tokenizer));
      }
      if (checkString("MP+"))
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      if ((buffer[0] === 67 || buffer[0] === 70) && check([87, 83], { offset: 1 }))
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      if (check([71, 73, 70]))
        return {
          ext: "gif",
          mime: "image/gif"
        };
      if (checkString("FLIF"))
        return {
          ext: "flif",
          mime: "image/flif"
        };
      if (checkString("8BPS"))
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      if (checkString("WEBP", { offset: 8 }))
        return {
          ext: "webp",
          mime: "image/webp"
        };
      if (checkString("MPCK"))
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      if (checkString("FORM"))
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      if (checkString("icns", { offset: 0 }))
        return {
          ext: "icns",
          mime: "image/icns"
        };
      if (check([80, 75, 3, 4])) {
        try {
          for (; tokenizer.position + 30 < tokenizer.fileInfo.size; ) {
            await tokenizer.readBuffer(buffer, { length: 30 });
            let zipHeader = {
              compressedSize: buffer.readUInt32LE(18),
              uncompressedSize: buffer.readUInt32LE(22),
              filenameLength: buffer.readUInt16LE(26),
              extraFieldLength: buffer.readUInt16LE(28)
            };
            if (zipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, "utf-8")), await tokenizer.ignore(zipHeader.extraFieldLength), zipHeader.filename === "META-INF/mozilla.rsa")
              return {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
            if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml"))
              switch (zipHeader.filename.split("/")[0]) {
                case "_rels":
                  break;
                case "word":
                  return {
                    ext: "docx",
                    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                  };
                case "ppt":
                  return {
                    ext: "pptx",
                    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                  };
                case "xl":
                  return {
                    ext: "xlsx",
                    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                  };
                default:
                  break;
              }
            if (zipHeader.filename.startsWith("xl/"))
              return {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model"))
              return {
                ext: "3mf",
                mime: "model/3mf"
              };
            if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize)
              switch (await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, "utf-8"))) {
                case "application/epub+zip":
                  return {
                    ext: "epub",
                    mime: "application/epub+zip"
                  };
                case "application/vnd.oasis.opendocument.text":
                  return {
                    ext: "odt",
                    mime: "application/vnd.oasis.opendocument.text"
                  };
                case "application/vnd.oasis.opendocument.spreadsheet":
                  return {
                    ext: "ods",
                    mime: "application/vnd.oasis.opendocument.spreadsheet"
                  };
                case "application/vnd.oasis.opendocument.presentation":
                  return {
                    ext: "odp",
                    mime: "application/vnd.oasis.opendocument.presentation"
                  };
                default:
              }
            if (zipHeader.compressedSize === 0) {
              let nextHeaderIndex = -1;
              for (; nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size; )
                await tokenizer.peekBuffer(buffer, { mayBeLess: !0 }), nextHeaderIndex = buffer.indexOf("504B0304", 0, "hex"), await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);
            } else
              await tokenizer.ignore(zipHeader.compressedSize);
          }
        } catch (error) {
          if (!(error instanceof strtok3.EndOfStreamError))
            throw error;
        }
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (checkString("OggS")) {
        await tokenizer.ignore(28);
        let type = Buffer.alloc(8);
        return await tokenizer.readBuffer(type), _check(type, [79, 112, 117, 115, 72, 101, 97, 100]) ? {
          ext: "opus",
          mime: "audio/opus"
        } : _check(type, [128, 116, 104, 101, 111, 114, 97]) ? {
          ext: "ogv",
          mime: "video/ogg"
        } : _check(type, [1, 118, 105, 100, 101, 111, 0]) ? {
          ext: "ogm",
          mime: "video/ogg"
        } : _check(type, [127, 70, 76, 65, 67]) ? {
          ext: "oga",
          mime: "audio/ogg"
        } : _check(type, [83, 112, 101, 101, 120, 32, 32]) ? {
          ext: "spx",
          mime: "audio/ogg"
        } : _check(type, [1, 118, 111, 114, 98, 105, 115]) ? {
          ext: "ogg",
          mime: "audio/ogg"
        } : {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8))
        return {
          ext: "zip",
          mime: "application/zip"
        };
      if (checkString("ftyp", { offset: 4 }) && buffer[8] & 96) {
        let brandMajor = buffer.toString("binary", 8, 12).replace("\0", " ").trim();
        switch (brandMajor) {
          case "avif":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            return brandMajor.startsWith("3g") ? brandMajor.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (checkString("MThd"))
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      if (checkString("wOFF") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 })))
        return {
          ext: "woff",
          mime: "font/woff"
        };
      if (checkString("wOF2") && (check([0, 1, 0, 0], { offset: 4 }) || checkString("OTTO", { offset: 4 })))
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      if (check([212, 195, 178, 161]) || check([161, 178, 195, 212]))
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      if (checkString("DSD "))
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
          // Non-standard
        };
      if (checkString("LZIP"))
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      if (checkString("fLaC"))
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      if (check([66, 80, 71, 251]))
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      if (checkString("wvpk"))
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      if (checkString("%PDF")) {
        await tokenizer.ignore(1350);
        let maxBufferSize = 10 * 1024 * 1024, buffer2 = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));
        return await tokenizer.readBuffer(buffer2, { mayBeLess: !0 }), buffer2.includes(Buffer.from("AIPrivateData")) ? {
          ext: "ai",
          mime: "application/postscript"
        } : {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([0, 97, 115, 109]))
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      if (check([73, 73, 42, 0]))
        return checkString("CR", { offset: 8 }) ? {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        } : check([28, 0, 254, 0], { offset: 8 }) || check([31, 0, 11, 0], { offset: 8 }) ? {
          ext: "nef",
          mime: "image/x-nikon-nef"
        } : check([8, 0, 0, 0], { offset: 4 }) && (check([45, 0, 254, 0], { offset: 8 }) || check([39, 0, 254, 0], { offset: 8 })) ? {
          ext: "dng",
          mime: "image/x-adobe-dng"
        } : (buffer = Buffer.alloc(24), await tokenizer.peekBuffer(buffer), (check([16, 251, 134, 1], { offset: 4 }) || check([8, 0, 0, 0], { offset: 4 })) && // This pattern differentiates ARW from other TIFF-ish file types:
        check([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 }) ? {
          ext: "arw",
          mime: "image/x-sony-arw"
        } : {
          ext: "tif",
          mime: "image/tiff"
        });
      if (check([77, 77, 0, 42]))
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      if (checkString("MAC "))
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      if (check([26, 69, 223, 163])) {
        async function readField() {
          let msb = await tokenizer.peekNumber(Token.UINT8), mask = 128, ic = 0;
          for (; !(msb & mask) && mask !== 0; )
            ++ic, mask >>= 1;
          let id = Buffer.alloc(ic + 1);
          return await tokenizer.readBuffer(id), id;
        }
        async function readElement() {
          let id = await readField(), lenField = await readField();
          lenField[0] ^= 128 >> lenField.length - 1;
          let nrLen = Math.min(6, lenField.length);
          return {
            id: id.readUIntBE(0, id.length),
            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
          };
        }
        async function readChildren(level, children) {
          for (; children > 0; ) {
            let e = await readElement();
            if (e.id === 17026)
              return tokenizer.readToken(new Token.StringType(e.len, "utf-8"));
            await tokenizer.ignore(e.len), --children;
          }
        }
        let re = await readElement();
        switch (await readChildren(1, re.len)) {
          case "webm":
            return {
              ext: "webm",
              mime: "video/webm"
            };
          case "matroska":
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          default:
            return;
        }
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 }))
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        if (check([87, 65, 86, 69], { offset: 8 }))
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        if (check([81, 76, 67, 77], { offset: 8 }))
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
      }
      if (checkString("SQLi"))
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      if (check([78, 69, 83, 26]))
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      if (checkString("Cr24"))
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      if (checkString("MSCF") || checkString("ISc("))
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      if (check([237, 171, 238, 219]))
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      if (check([197, 208, 211, 198]))
        return {
          ext: "eps",
          mime: "application/eps"
        };
      if (check([40, 181, 47, 253]))
        return {
          ext: "zst",
          mime: "application/zstd"
        };
      if (check([79, 84, 84, 79, 0]))
        return {
          ext: "otf",
          mime: "font/otf"
        };
      if (checkString("#!AMR"))
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      if (checkString("{\\rtf"))
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      if (check([70, 76, 86, 1]))
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      if (checkString("IMPM"))
        return {
          ext: "it",
          mime: "audio/x-it"
        };
      if (checkString("-lh0-", { offset: 2 }) || checkString("-lh1-", { offset: 2 }) || checkString("-lh2-", { offset: 2 }) || checkString("-lh3-", { offset: 2 }) || checkString("-lh4-", { offset: 2 }) || checkString("-lh5-", { offset: 2 }) || checkString("-lh6-", { offset: 2 }) || checkString("-lh7-", { offset: 2 }) || checkString("-lzs-", { offset: 2 }) || checkString("-lz4-", { offset: 2 }) || checkString("-lz5-", { offset: 2 }) || checkString("-lhd-", { offset: 2 }))
        return {
          ext: "lzh",
          mime: "application/x-lzh-compressed"
        };
      if (check([0, 0, 1, 186])) {
        if (check([33], { offset: 4, mask: [241] }))
          return {
            ext: "mpg",
            // May also be .ps, .mpeg
            mime: "video/MP1S"
          };
        if (check([68], { offset: 4, mask: [196] }))
          return {
            ext: "mpg",
            // May also be .mpg, .m2p, .vob or .sub
            mime: "video/MP2P"
          };
      }
      if (checkString("ITSF"))
        return {
          ext: "chm",
          mime: "application/vnd.ms-htmlhelp"
        };
      if (check([253, 55, 122, 88, 90, 0]))
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      if (checkString("<?xml "))
        return {
          ext: "xml",
          mime: "application/xml"
        };
      if (check([55, 122, 188, 175, 39, 28]))
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      if (check([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1))
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      if (checkString("solid "))
        return {
          ext: "stl",
          mime: "model/stl"
        };
      if (checkString("BLENDER"))
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      if (checkString("!<arch>"))
        return await tokenizer.ignore(8), await tokenizer.readToken(new Token.StringType(13, "ascii")) === "debian-binary" ? {
          ext: "deb",
          mime: "application/x-deb"
        } : {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        await tokenizer.ignore(8);
        async function readChunkHeader() {
          return {
            length: await tokenizer.readToken(Token.INT32_BE),
            type: await tokenizer.readToken(new Token.StringType(4, "binary"))
          };
        }
        do {
          let chunk = await readChunkHeader();
          if (chunk.length < 0)
            return;
          switch (chunk.type) {
            case "IDAT":
              return {
                ext: "png",
                mime: "image/png"
              };
            case "acTL":
              return {
                ext: "apng",
                mime: "image/apng"
              };
            default:
              await tokenizer.ignore(chunk.length + 4);
          }
        } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([65, 82, 82, 79, 87, 49, 0, 0]))
        return {
          ext: "arrow",
          mime: "application/x-apache-arrow"
        };
      if (check([103, 108, 84, 70, 2, 0, 0, 0]))
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      if (check([102, 114, 101, 101], { offset: 4 }) || // `free`
      check([109, 100, 97, 116], { offset: 4 }) || // `mdat` MJPEG
      check([109, 111, 111, 118], { offset: 4 }) || // `moov`
      check([119, 105, 100, 101], { offset: 4 }))
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      if (check([73, 73, 82, 79, 8, 0, 0, 0, 24]))
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      if (checkString("gimp xcf "))
        return {
          ext: "xcf",
          mime: "image/x-xcf"
        };
      if (check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
        return {
          ext: "rw2",
          mime: "image/x-panasonic-rw2"
        };
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function readHeader() {
          let guid = Buffer.alloc(16);
          return await tokenizer.readBuffer(guid), {
            id: guid,
            size: Number(await tokenizer.readToken(Token.UINT64_LE))
          };
        }
        for (await tokenizer.ignore(30); tokenizer.position + 24 < tokenizer.fileInfo.size; ) {
          let header = await readHeader(), payload = header.size - 24;
          if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            let typeId = Buffer.alloc(16);
            if (payload -= await tokenizer.readBuffer(typeId), _check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
              return {
                ext: "asf",
                mime: "audio/x-ms-asf"
              };
            if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
              return {
                ext: "asf",
                mime: "video/x-ms-asf"
              };
            break;
          }
          await tokenizer.ignore(payload);
        }
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      if ((check([126, 16, 4]) || check([126, 24, 4])) && check([48, 77, 73, 69], { offset: 4 }))
        return {
          ext: "mie",
          mime: "application/x-mie"
        };
      if (check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
        return {
          ext: "shp",
          mime: "application/x-esri-shape"
        };
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10]))
        switch (await tokenizer.ignore(20), await tokenizer.readToken(new Token.StringType(4, "ascii"))) {
          case "jp2 ":
            return {
              ext: "jp2",
              mime: "image/jp2"
            };
          case "jpx ":
            return {
              ext: "jpx",
              mime: "image/jpx"
            };
          case "jpm ":
            return {
              ext: "jpm",
              mime: "image/jpm"
            };
          case "mjp2":
            return {
              ext: "mj2",
              mime: "image/mj2"
            };
          default:
            return;
        }
      if (check([255, 10]) || check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
        return {
          ext: "jxl",
          mime: "image/jxl"
        };
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179]))
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      if (check([0, 1, 0, 0, 0]))
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      if (check([0, 0, 1, 0]))
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      if (check([0, 0, 2, 0]))
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      if (check([208, 207, 17, 224, 161, 177, 26, 225]))
        return {
          ext: "cfb",
          mime: "application/x-cfb"
        };
      if (await tokenizer.peekBuffer(buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: !0 }), checkString("BEGIN:")) {
        if (checkString("VCARD", { offset: 6 }))
          return {
            ext: "vcf",
            mime: "text/vcard"
          };
        if (checkString("VCALENDAR", { offset: 6 }))
          return {
            ext: "ics",
            mime: "text/calendar"
          };
      }
      if (checkString("FUJIFILMCCD-RAW"))
        return {
          ext: "raf",
          mime: "image/x-fujifilm-raf"
        };
      if (checkString("Extended Module:"))
        return {
          ext: "xm",
          mime: "audio/x-xm"
        };
      if (checkString("Creative Voice File"))
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      if (check([4, 0, 0, 0]) && buffer.length >= 16) {
        let jsonSize = buffer.readUInt32LE(12);
        if (jsonSize > 12 && buffer.length >= jsonSize + 16)
          try {
            let header = buffer.slice(16, jsonSize + 16).toString();
            if (JSON.parse(header).files)
              return {
                ext: "asar",
                mime: "application/x-asar"
              };
          } catch (_) {
          }
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      if (checkString("SCRM", { offset: 44 }))
        return {
          ext: "s3m",
          mime: "audio/x-s3m"
        };
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 })))
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      if (check([68, 73, 67, 77], { offset: 128 }))
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70]))
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
          // Invented by us
        };
      if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0]))
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
          // Invented by us
        };
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 })))
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      if (check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29]))
        return {
          ext: "indd",
          mime: "application/x-indesign"
        };
      if (await tokenizer.peekBuffer(buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: !0 }), tarHeaderChecksumMatches(buffer))
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      if (check([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0]))
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      if (checkString("-----BEGIN PGP MESSAGE-----"))
        return {
          ext: "pgp",
          mime: "application/pgp-encrypted"
        };
      if (buffer.length >= 2 && check([255, 224], { offset: 0, mask: [255, 224] })) {
        if (check([16], { offset: 1, mask: [22] }))
          return check([8], { offset: 1, mask: [8] }) ? {
            ext: "aac",
            mime: "audio/aac"
          } : {
            ext: "aac",
            mime: "audio/aac"
          };
        if (check([2], { offset: 1, mask: [6] }))
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        if (check([4], { offset: 1, mask: [6] }))
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        if (check([6], { offset: 1, mask: [6] }))
          return {
            ext: "mp1",
            mime: "audio/mpeg"
          };
      }
    }
    var stream = (readableStream) => new Promise((resolve, reject) => {
      let stream = eval("require")("stream");
      readableStream.on("error", reject), readableStream.once("readable", async () => {
        let pass = new stream.PassThrough(), outputStream;
        stream.pipeline ? outputStream = stream.pipeline(readableStream, pass, () => {
        }) : outputStream = readableStream.pipe(pass);
        let chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
        try {
          let fileType2 = await fromBuffer(chunk);
          pass.fileType = fileType2;
        } catch (error) {
          reject(error);
        }
        resolve(outputStream);
      });
    }), fileType = {
      fromStream,
      fromTokenizer,
      fromBuffer,
      stream
    };
    Object.defineProperty(fileType, "extensions", {
      get() {
        return new Set(supported.extensions);
      }
    });
    Object.defineProperty(fileType, "mimeTypes", {
      get() {
        return new Set(supported.mimeTypes);
      }
    });
    module.exports = fileType;
  }
});

// node_modules/content-type/index.js
var require_content_type = __commonJS({
  "node_modules/content-type/index.js"(exports2) {
    "use strict";
    var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g, QUOTE_REGEXP = /([\\"])/g, TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    exports2.format = format;
    exports2.parse = parse;
    function format(obj) {
      if (!obj || typeof obj != "object")
        throw new TypeError("argument obj is required");
      var parameters = obj.parameters, type = obj.type;
      if (!type || !TYPE_REGEXP.test(type))
        throw new TypeError("invalid type");
      var string = type;
      if (parameters && typeof parameters == "object")
        for (var param, params = Object.keys(parameters).sort(), i = 0; i < params.length; i++) {
          if (param = params[i], !TOKEN_REGEXP.test(param))
            throw new TypeError("invalid parameter name");
          string += "; " + param + "=" + qstring(parameters[param]);
        }
      return string;
    }
    function parse(string) {
      if (!string)
        throw new TypeError("argument string is required");
      var header = typeof string == "object" ? getcontenttype(string) : string;
      if (typeof header != "string")
        throw new TypeError("argument string is required to be a string");
      var index = header.indexOf(";"), type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (!TYPE_REGEXP.test(type))
        throw new TypeError("invalid media type");
      var obj = new ContentType(type.toLowerCase());
      if (index !== -1) {
        var key, match, value;
        for (PARAM_REGEXP.lastIndex = index; match = PARAM_REGEXP.exec(header); ) {
          if (match.index !== index)
            throw new TypeError("invalid parameter format");
          index += match[0].length, key = match[1].toLowerCase(), value = match[2], value.charCodeAt(0) === 34 && (value = value.slice(1, -1), value.indexOf("\\") !== -1 && (value = value.replace(QESC_REGEXP, "$1"))), obj.parameters[key] = value;
        }
        if (index !== header.length)
          throw new TypeError("invalid parameter format");
      }
      return obj;
    }
    function getcontenttype(obj) {
      var header;
      if (typeof obj.getHeader == "function" ? header = obj.getHeader("content-type") : typeof obj.headers == "object" && (header = obj.headers && obj.headers["content-type"]), typeof header != "string")
        throw new TypeError("content-type header is missing from object");
      return header;
    }
    function qstring(val) {
      var str = String(val);
      if (TOKEN_REGEXP.test(str))
        return str;
      if (str.length > 0 && !TEXT_REGEXP.test(str))
        throw new TypeError("invalid parameter value");
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ContentType(type) {
      this.parameters = /* @__PURE__ */ Object.create(null), this.type = type;
    }
  }
});

// node_modules/media-typer/index.js
var require_media_typer = __commonJS({
  "node_modules/media-typer/index.js"(exports2) {
    "use strict";
    var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/, TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/, TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
    exports2.format = format;
    exports2.parse = parse;
    exports2.test = test;
    function format(obj) {
      if (!obj || typeof obj != "object")
        throw new TypeError("argument obj is required");
      var subtype = obj.subtype, suffix = obj.suffix, type = obj.type;
      if (!type || !TYPE_NAME_REGEXP.test(type))
        throw new TypeError("invalid type");
      if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype))
        throw new TypeError("invalid subtype");
      var string = type + "/" + subtype;
      if (suffix) {
        if (!TYPE_NAME_REGEXP.test(suffix))
          throw new TypeError("invalid suffix");
        string += "+" + suffix;
      }
      return string;
    }
    function test(string) {
      if (!string)
        throw new TypeError("argument string is required");
      if (typeof string != "string")
        throw new TypeError("argument string is required to be a string");
      return TYPE_REGEXP.test(string.toLowerCase());
    }
    function parse(string) {
      if (!string)
        throw new TypeError("argument string is required");
      if (typeof string != "string")
        throw new TypeError("argument string is required to be a string");
      var match = TYPE_REGEXP.exec(string.toLowerCase());
      if (!match)
        throw new TypeError("invalid media type");
      var type = match[1], subtype = match[2], suffix, index = subtype.lastIndexOf("+");
      return index !== -1 && (suffix = subtype.substr(index + 1), subtype = subtype.substr(0, index)), new MediaType(type, subtype, suffix);
    }
    function MediaType(type, subtype, suffix) {
      this.type = type, this.subtype = subtype, this.suffix = suffix;
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3, m = s * 60, h = m * 60, d = h * 24, w = d * 7, y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0)
        return parse(val);
      if (type === "number" && isFinite(val))
        return options.long ? fmtLong(val) : fmtShort(val);
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      if (str = String(str), !(str.length > 100)) {
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (match) {
          var n = parseFloat(match[1]), type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return;
          }
        }
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      return msAbs >= d ? Math.round(ms / d) + "d" : msAbs >= h ? Math.round(ms / h) + "h" : msAbs >= m ? Math.round(ms / m) + "m" : msAbs >= s ? Math.round(ms / s) + "s" : ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      return msAbs >= d ? plural(ms, msAbs, d, "day") : msAbs >= h ? plural(ms, msAbs, h, "hour") : msAbs >= m ? plural(ms, msAbs, m, "minute") : msAbs >= s ? plural(ms, msAbs, s, "second") : ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = coerce, createDebug.disable = disable, createDebug.enable = enable, createDebug.enabled = enabled, createDebug.humanize = require_ms(), createDebug.destroy = destroy, Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++)
          hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime, enableOverride = null, namespacesCache, enabledCache;
        function debug(...args) {
          if (!debug.enabled)
            return;
          let self = debug, curr = Number(/* @__PURE__ */ new Date()), ms = curr - (prevTime || curr);
          self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), typeof args[0] != "string" && args.unshift("%O");
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%")
              return "%";
            index++;
            let formatter = createDebug.formatters[format];
            if (typeof formatter == "function") {
              let val = args[index];
              match = formatter.call(self, val), args.splice(index, 1), index--;
            }
            return match;
          }), createDebug.formatArgs.call(self, args), (self.log || createDebug.log).apply(self, args);
        }
        return debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), debug.extend = extend, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", {
          enumerable: !0,
          configurable: !1,
          get: () => enableOverride !== null ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace)), enabledCache),
          set: (v) => {
            enableOverride = v;
          }
        }), typeof createDebug.init == "function" && createDebug.init(debug), debug;
      }
      function extend(namespace, delimiter) {
        let newDebug = createDebug(this.namespace + (typeof delimiter == "undefined" ? ":" : delimiter) + namespace);
        return newDebug.log = this.log, newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];
        let split = (typeof namespaces == "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (let ns of split)
          ns[0] === "-" ? createDebug.skips.push(ns.slice(1)) : createDebug.names.push(ns);
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0, templateIndex = 0, starIndex = -1, matchIndex = 0;
        for (; searchIndex < search.length; )
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*"))
            template[templateIndex] === "*" ? (starIndex = templateIndex, matchIndex = searchIndex, templateIndex++) : (searchIndex++, templateIndex++);
          else if (starIndex !== -1)
            templateIndex = starIndex + 1, matchIndex++, searchIndex = matchIndex;
          else
            return !1;
        for (; templateIndex < template.length && template[templateIndex] === "*"; )
          templateIndex++;
        return templateIndex === template.length;
      }
      function disable() {
        let namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        return createDebug.enable(""), namespaces;
      }
      function enabled(name) {
        for (let skip of createDebug.skips)
          if (matchesTemplate(name, skip))
            return !1;
        for (let ns of createDebug.names)
          if (matchesTemplate(name, ns))
            return !0;
        return !1;
      }
      function coerce(val) {
        return val instanceof Error ? val.stack || val.message : val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      return createDebug.enable(createDebug.load()), createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = !1;
      return () => {
        warned || (warned = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let m;
      return typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator != "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff), !this.useColors)
        return;
      let c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0, lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        match !== "%%" && (index++, match === "%c" && (lastC = index));
      }), args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        namespaces ? exports2.storage.setItem("debug", namespaces) : exports2.storage.removeItem("debug");
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      return !r && typeof process != "undefined" && "env" in process && (r = process.env.DEBUG), r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/music-metadata/lib/matroska/types.js
var require_types = __commonJS({
  "node_modules/music-metadata/lib/matroska/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.TrackType = exports2.TargetType = exports2.DataType = void 0;
    var DataType;
    (function(DataType2) {
      DataType2[DataType2.string = 0] = "string", DataType2[DataType2.uint = 1] = "uint", DataType2[DataType2.uid = 2] = "uid", DataType2[DataType2.bool = 3] = "bool", DataType2[DataType2.binary = 4] = "binary", DataType2[DataType2.float = 5] = "float";
    })(DataType = exports2.DataType || (exports2.DataType = {}));
    var TargetType;
    (function(TargetType2) {
      TargetType2[TargetType2.shot = 10] = "shot", TargetType2[TargetType2.scene = 20] = "scene", TargetType2[TargetType2.track = 30] = "track", TargetType2[TargetType2.part = 40] = "part", TargetType2[TargetType2.album = 50] = "album", TargetType2[TargetType2.edition = 60] = "edition", TargetType2[TargetType2.collection = 70] = "collection";
    })(TargetType = exports2.TargetType || (exports2.TargetType = {}));
    var TrackType;
    (function(TrackType2) {
      TrackType2[TrackType2.video = 1] = "video", TrackType2[TrackType2.audio = 2] = "audio", TrackType2[TrackType2.complex = 3] = "complex", TrackType2[TrackType2.logo = 4] = "logo", TrackType2[TrackType2.subtitle = 17] = "subtitle", TrackType2[TrackType2.button = 18] = "button", TrackType2[TrackType2.control = 32] = "control";
    })(TrackType = exports2.TrackType || (exports2.TrackType = {}));
  }
});

// node_modules/music-metadata/lib/type.js
var require_type = __commonJS({
  "node_modules/music-metadata/lib/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.TrackType = void 0;
    var types_1 = require_types();
    Object.defineProperty(exports2, "TrackType", { enumerable: !0, get: function() {
      return types_1.TrackType;
    } });
  }
});

// node_modules/music-metadata/lib/common/GenericTagTypes.js
var require_GenericTagTypes = __commonJS({
  "node_modules/music-metadata/lib/common/GenericTagTypes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isUnique = exports2.isSingleton = exports2.commonTags = void 0;
    exports2.commonTags = {
      year: { multiple: !1 },
      track: { multiple: !1 },
      disk: { multiple: !1 },
      title: { multiple: !1 },
      artist: { multiple: !1 },
      artists: { multiple: !0, unique: !0 },
      albumartist: { multiple: !1 },
      album: { multiple: !1 },
      date: { multiple: !1 },
      originaldate: { multiple: !1 },
      originalyear: { multiple: !1 },
      comment: { multiple: !0, unique: !1 },
      genre: { multiple: !0, unique: !0 },
      picture: { multiple: !0, unique: !0 },
      composer: { multiple: !0, unique: !0 },
      lyrics: { multiple: !0, unique: !1 },
      albumsort: { multiple: !1, unique: !0 },
      titlesort: { multiple: !1, unique: !0 },
      work: { multiple: !1, unique: !0 },
      artistsort: { multiple: !1, unique: !0 },
      albumartistsort: { multiple: !1, unique: !0 },
      composersort: { multiple: !1, unique: !0 },
      lyricist: { multiple: !0, unique: !0 },
      writer: { multiple: !0, unique: !0 },
      conductor: { multiple: !0, unique: !0 },
      remixer: { multiple: !0, unique: !0 },
      arranger: { multiple: !0, unique: !0 },
      engineer: { multiple: !0, unique: !0 },
      producer: { multiple: !0, unique: !0 },
      technician: { multiple: !0, unique: !0 },
      djmixer: { multiple: !0, unique: !0 },
      mixer: { multiple: !0, unique: !0 },
      label: { multiple: !0, unique: !0 },
      grouping: { multiple: !1 },
      subtitle: { multiple: !0 },
      discsubtitle: { multiple: !1 },
      totaltracks: { multiple: !1 },
      totaldiscs: { multiple: !1 },
      compilation: { multiple: !1 },
      rating: { multiple: !0 },
      bpm: { multiple: !1 },
      mood: { multiple: !1 },
      media: { multiple: !1 },
      catalognumber: { multiple: !0, unique: !0 },
      tvShow: { multiple: !1 },
      tvShowSort: { multiple: !1 },
      tvSeason: { multiple: !1 },
      tvEpisode: { multiple: !1 },
      tvEpisodeId: { multiple: !1 },
      tvNetwork: { multiple: !1 },
      podcast: { multiple: !1 },
      podcasturl: { multiple: !1 },
      releasestatus: { multiple: !1 },
      releasetype: { multiple: !0 },
      releasecountry: { multiple: !1 },
      script: { multiple: !1 },
      language: { multiple: !1 },
      copyright: { multiple: !1 },
      license: { multiple: !1 },
      encodedby: { multiple: !1 },
      encodersettings: { multiple: !1 },
      gapless: { multiple: !1 },
      barcode: { multiple: !1 },
      isrc: { multiple: !0 },
      asin: { multiple: !1 },
      musicbrainz_recordingid: { multiple: !1 },
      musicbrainz_trackid: { multiple: !1 },
      musicbrainz_albumid: { multiple: !1 },
      musicbrainz_artistid: { multiple: !0 },
      musicbrainz_albumartistid: { multiple: !0 },
      musicbrainz_releasegroupid: { multiple: !1 },
      musicbrainz_workid: { multiple: !1 },
      musicbrainz_trmid: { multiple: !1 },
      musicbrainz_discid: { multiple: !1 },
      acoustid_id: { multiple: !1 },
      acoustid_fingerprint: { multiple: !1 },
      musicip_puid: { multiple: !1 },
      musicip_fingerprint: { multiple: !1 },
      website: { multiple: !1 },
      "performer:instrument": { multiple: !0, unique: !0 },
      averageLevel: { multiple: !1 },
      peakLevel: { multiple: !1 },
      notes: { multiple: !0, unique: !1 },
      key: { multiple: !1 },
      originalalbum: { multiple: !1 },
      originalartist: { multiple: !1 },
      discogs_artist_id: { multiple: !0, unique: !0 },
      discogs_release_id: { multiple: !1 },
      discogs_label_id: { multiple: !1 },
      discogs_master_release_id: { multiple: !1 },
      discogs_votes: { multiple: !1 },
      discogs_rating: { multiple: !1 },
      replaygain_track_peak: { multiple: !1 },
      replaygain_track_gain: { multiple: !1 },
      replaygain_album_peak: { multiple: !1 },
      replaygain_album_gain: { multiple: !1 },
      replaygain_track_minmax: { multiple: !1 },
      replaygain_album_minmax: { multiple: !1 },
      replaygain_undo: { multiple: !1 },
      description: { multiple: !0 },
      longDescription: { multiple: !1 },
      category: { multiple: !0 },
      hdVideo: { multiple: !1 },
      keywords: { multiple: !0 },
      movement: { multiple: !1 },
      movementIndex: { multiple: !1 },
      movementTotal: { multiple: !1 },
      podcastId: { multiple: !1 },
      showMovement: { multiple: !1 },
      stik: { multiple: !1 }
    };
    function isSingleton(alias) {
      return exports2.commonTags.hasOwnProperty(alias) && !exports2.commonTags[alias].multiple;
    }
    exports2.isSingleton = isSingleton;
    function isUnique(alias) {
      return !exports2.commonTags[alias].multiple || exports2.commonTags[alias].unique;
    }
    exports2.isUnique = isUnique;
  }
});

// node_modules/music-metadata/lib/common/GenericTagMapper.js
var require_GenericTagMapper = __commonJS({
  "node_modules/music-metadata/lib/common/GenericTagMapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.CommonTagMapper = void 0;
    var CommonTagMapper = class {
      static toIntOrNull(str) {
        let cleaned = parseInt(str, 10);
        return isNaN(cleaned) ? null : cleaned;
      }
      // TODO: a string of 1of1 would fail to be converted
      // converts 1/10 to no : 1, of : 10
      // or 1 to no : 1, of : 0
      static normalizeTrack(origVal) {
        let split = origVal.toString().split("/");
        return {
          no: parseInt(split[0], 10) || null,
          of: parseInt(split[1], 10) || null
        };
      }
      constructor(tagTypes, tagMap) {
        this.tagTypes = tagTypes, this.tagMap = tagMap;
      }
      /**
       * Process and set common tags
       * write common tags to
       * @param tag Native tag
       * @param warnings Register warnings
       * @return common name
       */
      mapGenericTag(tag, warnings) {
        tag = { id: tag.id, value: tag.value }, this.postMap(tag, warnings);
        let id = this.getCommonName(tag.id);
        return id ? { id, value: tag.value } : null;
      }
      /**
       * Convert native tag key to common tag key
       * @tag  Native header tag
       * @return common tag name (alias)
       */
      getCommonName(tag) {
        return this.tagMap[tag];
      }
      /**
       * Handle post mapping exceptions / correction
       * @param tag Tag e.g. {"alb", "Buena Vista Social Club")
       * @param warnings Used to register warnings
       */
      postMap(tag, warnings) {
      }
    };
    CommonTagMapper.maxRatingScore = 1;
    exports2.CommonTagMapper = CommonTagMapper;
  }
});

// node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js
var require_ID3v1TagMap = __commonJS({
  "node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ID3v1TagMapper = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper(), id3v1TagMap = {
      title: "title",
      artist: "artist",
      album: "album",
      year: "year",
      comment: "comment",
      track: "track",
      genre: "genre"
    }, ID3v1TagMapper = class extends GenericTagMapper_1.CommonTagMapper {
      constructor() {
        super(["ID3v1"], id3v1TagMap);
      }
    };
    exports2.ID3v1TagMapper = ID3v1TagMapper;
  }
});

// node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js
var require_CaseInsensitiveTagMap = __commonJS({
  "node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.CaseInsensitiveTagMap = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper(), CaseInsensitiveTagMap = class extends GenericTagMapper_1.CommonTagMapper {
      constructor(tagTypes, tagMap) {
        let upperCaseMap = {};
        for (let tag of Object.keys(tagMap))
          upperCaseMap[tag.toUpperCase()] = tagMap[tag];
        super(tagTypes, upperCaseMap);
      }
      /**
       * @tag  Native header tag
       * @return common tag name (alias)
       */
      getCommonName(tag) {
        return this.tagMap[tag.toUpperCase()];
      }
    };
    exports2.CaseInsensitiveTagMap = CaseInsensitiveTagMap;
  }
});

// node_modules/music-metadata/lib/common/Util.js
var require_Util = __commonJS({
  "node_modules/music-metadata/lib/common/Util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.toRatio = exports2.dbToRatio = exports2.ratioToDb = exports2.a2hex = exports2.isBitSet = exports2.getBitAllignedNumber = exports2.stripNulls = exports2.decodeString = exports2.trimRightNull = exports2.findZero = exports2.getBit = void 0;
    function getBit(buf, off, bit) {
      return (buf[off] & 1 << bit) !== 0;
    }
    exports2.getBit = getBit;
    function findZero(uint8Array, start, end, encoding) {
      let i = start;
      if (encoding === "utf16le") {
        for (; uint8Array[i] !== 0 || uint8Array[i + 1] !== 0; ) {
          if (i >= end)
            return end;
          i += 2;
        }
        return i;
      } else {
        for (; uint8Array[i] !== 0; ) {
          if (i >= end)
            return end;
          i++;
        }
        return i;
      }
    }
    exports2.findZero = findZero;
    function trimRightNull(x) {
      let pos0 = x.indexOf("\0");
      return pos0 === -1 ? x : x.substr(0, pos0);
    }
    exports2.trimRightNull = trimRightNull;
    function swapBytes(uint8Array) {
      let l = uint8Array.length;
      if (l & 1)
        throw new Error("Buffer length must be even");
      for (let i = 0; i < l; i += 2) {
        let a = uint8Array[i];
        uint8Array[i] = uint8Array[i + 1], uint8Array[i + 1] = a;
      }
      return uint8Array;
    }
    function decodeString(uint8Array, encoding) {
      if (uint8Array[0] === 255 && uint8Array[1] === 254)
        return decodeString(uint8Array.subarray(2), encoding);
      if (encoding === "utf16le" && uint8Array[0] === 254 && uint8Array[1] === 255) {
        if (uint8Array.length & 1)
          throw new Error("Expected even number of octets for 16-bit unicode string");
        return decodeString(swapBytes(uint8Array), encoding);
      }
      return Buffer.from(uint8Array).toString(encoding);
    }
    exports2.decodeString = decodeString;
    function stripNulls(str) {
      return str = str.replace(/^\x00+/g, ""), str = str.replace(/\x00+$/g, ""), str;
    }
    exports2.stripNulls = stripNulls;
    function getBitAllignedNumber(source, byteOffset, bitOffset, len) {
      let byteOff = byteOffset + ~~(bitOffset / 8), bitOff = bitOffset % 8, value = source[byteOff];
      value &= 255 >> bitOff;
      let bitsRead = 8 - bitOff, bitsLeft = len - bitsRead;
      return bitsLeft < 0 ? value >>= 8 - bitOff - len : bitsLeft > 0 && (value <<= bitsLeft, value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft)), value;
    }
    exports2.getBitAllignedNumber = getBitAllignedNumber;
    function isBitSet(source, byteOffset, bitOffset) {
      return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;
    }
    exports2.isBitSet = isBitSet;
    function a2hex(str) {
      let arr = [];
      for (let i = 0, l = str.length; i < l; i++) {
        let hex = Number(str.charCodeAt(i)).toString(16);
        arr.push(hex.length === 1 ? "0" + hex : hex);
      }
      return arr.join(" ");
    }
    exports2.a2hex = a2hex;
    function ratioToDb(ratio) {
      return 10 * Math.log10(ratio);
    }
    exports2.ratioToDb = ratioToDb;
    function dbToRatio(dB) {
      return Math.pow(10, dB / 10);
    }
    exports2.dbToRatio = dbToRatio;
    function toRatio(value) {
      let ps = value.split(" ").map((p) => p.trim().toLowerCase());
      if (ps.length >= 1) {
        let v = parseFloat(ps[0]);
        return ps.length === 2 && ps[1] === "db" ? {
          dB: v,
          ratio: dbToRatio(v)
        } : {
          dB: ratioToDb(v),
          ratio: v
        };
      }
    }
    exports2.toRatio = toRatio;
  }
});

// node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js
var require_ID3v24TagMapper = __commonJS({
  "node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ID3v24TagMapper = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper(), CaseInsensitiveTagMap_1 = require_CaseInsensitiveTagMap(), util = require_Util(), id3v24TagMap = {
      // id3v2.3
      TIT2: "title",
      TPE1: "artist",
      "TXXX:Artists": "artists",
      TPE2: "albumartist",
      TALB: "album",
      TDRV: "date",
      /**
       * Original release year
       */
      TORY: "originalyear",
      TPOS: "disk",
      TCON: "genre",
      APIC: "picture",
      TCOM: "composer",
      "USLT:description": "lyrics",
      TSOA: "albumsort",
      TSOT: "titlesort",
      TOAL: "originalalbum",
      TSOP: "artistsort",
      TSO2: "albumartistsort",
      TSOC: "composersort",
      TEXT: "lyricist",
      "TXXX:Writer": "writer",
      TPE3: "conductor",
      // 'IPLS:instrument': 'performer:instrument', // ToDo
      TPE4: "remixer",
      "IPLS:arranger": "arranger",
      "IPLS:engineer": "engineer",
      "IPLS:producer": "producer",
      "IPLS:DJ-mix": "djmixer",
      "IPLS:mix": "mixer",
      TPUB: "label",
      TIT1: "grouping",
      TIT3: "subtitle",
      TRCK: "track",
      TCMP: "compilation",
      POPM: "rating",
      TBPM: "bpm",
      TMED: "media",
      "TXXX:CATALOGNUMBER": "catalognumber",
      "TXXX:MusicBrainz Album Status": "releasestatus",
      "TXXX:MusicBrainz Album Type": "releasetype",
      /**
       * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0
       */
      "TXXX:MusicBrainz Album Release Country": "releasecountry",
      /**
       * Release country as implemented // ToDo: report
       */
      "TXXX:RELEASECOUNTRY": "releasecountry",
      "TXXX:SCRIPT": "script",
      TLAN: "language",
      TCOP: "copyright",
      WCOP: "license",
      TENC: "encodedby",
      TSSE: "encodersettings",
      "TXXX:BARCODE": "barcode",
      "TXXX:ISRC": "isrc",
      TSRC: "isrc",
      "TXXX:ASIN": "asin",
      "TXXX:originalyear": "originalyear",
      "UFID:http://musicbrainz.org": "musicbrainz_recordingid",
      "TXXX:MusicBrainz Release Track Id": "musicbrainz_trackid",
      "TXXX:MusicBrainz Album Id": "musicbrainz_albumid",
      "TXXX:MusicBrainz Artist Id": "musicbrainz_artistid",
      "TXXX:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
      "TXXX:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
      "TXXX:MusicBrainz Work Id": "musicbrainz_workid",
      "TXXX:MusicBrainz TRM Id": "musicbrainz_trmid",
      "TXXX:MusicBrainz Disc Id": "musicbrainz_discid",
      "TXXX:ACOUSTID_ID": "acoustid_id",
      "TXXX:Acoustid Id": "acoustid_id",
      "TXXX:Acoustid Fingerprint": "acoustid_fingerprint",
      "TXXX:MusicIP PUID": "musicip_puid",
      "TXXX:MusicMagic Fingerprint": "musicip_fingerprint",
      WOAR: "website",
      // id3v2.4
      // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames
      TDRC: "date",
      TYER: "year",
      TDOR: "originaldate",
      // 'TMCL:instrument': 'performer:instrument',
      "TIPL:arranger": "arranger",
      "TIPL:engineer": "engineer",
      "TIPL:producer": "producer",
      "TIPL:DJ-mix": "djmixer",
      "TIPL:mix": "mixer",
      TMOO: "mood",
      // additional mappings:
      SYLT: "lyrics",
      TSST: "discsubtitle",
      TKEY: "key",
      COMM: "comment",
      TOPE: "originalartist",
      // Windows Media Player
      "PRIV:AverageLevel": "averageLevel",
      "PRIV:PeakLevel": "peakLevel",
      // Discogs
      "TXXX:DISCOGS_ARTIST_ID": "discogs_artist_id",
      "TXXX:DISCOGS_ARTISTS": "artists",
      "TXXX:DISCOGS_ARTIST_NAME": "artists",
      "TXXX:DISCOGS_ALBUM_ARTISTS": "albumartist",
      "TXXX:DISCOGS_CATALOG": "catalognumber",
      "TXXX:DISCOGS_COUNTRY": "releasecountry",
      "TXXX:DISCOGS_DATE": "originaldate",
      "TXXX:DISCOGS_LABEL": "label",
      "TXXX:DISCOGS_LABEL_ID": "discogs_label_id",
      "TXXX:DISCOGS_MASTER_RELEASE_ID": "discogs_master_release_id",
      "TXXX:DISCOGS_RATING": "discogs_rating",
      "TXXX:DISCOGS_RELEASED": "date",
      "TXXX:DISCOGS_RELEASE_ID": "discogs_release_id",
      "TXXX:DISCOGS_VOTES": "discogs_votes",
      "TXXX:CATALOGID": "catalognumber",
      "TXXX:STYLE": "genre",
      "TXXX:REPLAYGAIN_TRACK_PEAK": "replaygain_track_peak",
      "TXXX:REPLAYGAIN_TRACK_GAIN": "replaygain_track_gain",
      "TXXX:REPLAYGAIN_ALBUM_PEAK": "replaygain_album_peak",
      "TXXX:REPLAYGAIN_ALBUM_GAIN": "replaygain_album_gain",
      "TXXX:MP3GAIN_MINMAX": "replaygain_track_minmax",
      "TXXX:MP3GAIN_ALBUM_MINMAX": "replaygain_album_minmax",
      "TXXX:MP3GAIN_UNDO": "replaygain_undo",
      MVNM: "movement",
      MVIN: "movementIndex",
      PCST: "podcast",
      TCAT: "category",
      TDES: "description",
      TDRL: "date",
      TGID: "podcastId",
      TKWD: "keywords",
      WFED: "podcasturl"
    }, ID3v24TagMapper = class _ID3v24TagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
      static toRating(popm) {
        return {
          source: popm.email,
          rating: popm.rating > 0 ? (popm.rating - 1) / 254 * GenericTagMapper_1.CommonTagMapper.maxRatingScore : void 0
        };
      }
      constructor() {
        super(["ID3v2.3", "ID3v2.4"], id3v24TagMap);
      }
      /**
       * Handle post mapping exceptions / correction
       * @param tag to post map
       * @param warnings Wil be used to register (collect) warnings
       * @return Common value e.g. "Buena Vista Social Club"
       */
      postMap(tag, warnings) {
        switch (tag.id) {
          case "UFID":
            tag.value.owner_identifier === "http://musicbrainz.org" && (tag.id += ":" + tag.value.owner_identifier, tag.value = util.decodeString(tag.value.identifier, "latin1"));
            break;
          case "PRIV":
            switch (tag.value.owner_identifier) {
              case "AverageLevel":
              case "PeakValue":
                tag.id += ":" + tag.value.owner_identifier, tag.value = tag.value.data.length === 4 ? tag.value.data.readUInt32LE(0) : null, tag.value === null && warnings.addWarning("Failed to parse PRIV:PeakValue");
                break;
              default:
                warnings.addWarning(`Unknown PRIV owner-identifier: ${tag.value.owner_identifier}`);
            }
            break;
          case "COMM":
            tag.value = tag.value ? tag.value.text : null;
            break;
          case "POPM":
            tag.value = _ID3v24TagMapper.toRating(tag.value);
            break;
          default:
            break;
        }
      }
    };
    exports2.ID3v24TagMapper = ID3v24TagMapper;
  }
});

// node_modules/music-metadata/lib/asf/AsfTagMapper.js
var require_AsfTagMapper = __commonJS({
  "node_modules/music-metadata/lib/asf/AsfTagMapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AsfTagMapper = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper(), asfTagMap = {
      Title: "title",
      Author: "artist",
      "WM/AlbumArtist": "albumartist",
      "WM/AlbumTitle": "album",
      "WM/Year": "date",
      "WM/OriginalReleaseTime": "originaldate",
      "WM/OriginalReleaseYear": "originalyear",
      Description: "comment",
      "WM/TrackNumber": "track",
      "WM/PartOfSet": "disk",
      "WM/Genre": "genre",
      "WM/Composer": "composer",
      "WM/Lyrics": "lyrics",
      "WM/AlbumSortOrder": "albumsort",
      "WM/TitleSortOrder": "titlesort",
      "WM/ArtistSortOrder": "artistsort",
      "WM/AlbumArtistSortOrder": "albumartistsort",
      "WM/ComposerSortOrder": "composersort",
      "WM/Writer": "lyricist",
      "WM/Conductor": "conductor",
      "WM/ModifiedBy": "remixer",
      "WM/Engineer": "engineer",
      "WM/Producer": "producer",
      "WM/DJMixer": "djmixer",
      "WM/Mixer": "mixer",
      "WM/Publisher": "label",
      "WM/ContentGroupDescription": "grouping",
      "WM/SubTitle": "subtitle",
      "WM/SetSubTitle": "discsubtitle",
      // 'WM/PartOfSet': 'totaldiscs',
      "WM/IsCompilation": "compilation",
      "WM/SharedUserRating": "rating",
      "WM/BeatsPerMinute": "bpm",
      "WM/Mood": "mood",
      "WM/Media": "media",
      "WM/CatalogNo": "catalognumber",
      "MusicBrainz/Album Status": "releasestatus",
      "MusicBrainz/Album Type": "releasetype",
      "MusicBrainz/Album Release Country": "releasecountry",
      "WM/Script": "script",
      "WM/Language": "language",
      Copyright: "copyright",
      LICENSE: "license",
      "WM/EncodedBy": "encodedby",
      "WM/EncodingSettings": "encodersettings",
      "WM/Barcode": "barcode",
      "WM/ISRC": "isrc",
      "MusicBrainz/Track Id": "musicbrainz_recordingid",
      "MusicBrainz/Release Track Id": "musicbrainz_trackid",
      "MusicBrainz/Album Id": "musicbrainz_albumid",
      "MusicBrainz/Artist Id": "musicbrainz_artistid",
      "MusicBrainz/Album Artist Id": "musicbrainz_albumartistid",
      "MusicBrainz/Release Group Id": "musicbrainz_releasegroupid",
      "MusicBrainz/Work Id": "musicbrainz_workid",
      "MusicBrainz/TRM Id": "musicbrainz_trmid",
      "MusicBrainz/Disc Id": "musicbrainz_discid",
      "Acoustid/Id": "acoustid_id",
      "Acoustid/Fingerprint": "acoustid_fingerprint",
      "MusicIP/PUID": "musicip_puid",
      "WM/ARTISTS": "artists",
      "WM/InitialKey": "key",
      ASIN: "asin",
      "WM/Work": "work",
      "WM/AuthorURL": "website",
      "WM/Picture": "picture"
    }, AsfTagMapper = class _AsfTagMapper extends GenericTagMapper_1.CommonTagMapper {
      static toRating(rating) {
        return {
          rating: parseFloat(rating + 1) / 5
        };
      }
      constructor() {
        super(["asf"], asfTagMap);
      }
      postMap(tag) {
        switch (tag.id) {
          case "WM/SharedUserRating":
            let keys = tag.id.split(":");
            tag.value = _AsfTagMapper.toRating(tag.value), tag.id = keys[0];
            break;
        }
      }
    };
    exports2.AsfTagMapper = AsfTagMapper;
  }
});

// node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js
var require_ID3v22TagMapper = __commonJS({
  "node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ID3v22TagMapper = exports2.id3v22TagMap = void 0;
    var CaseInsensitiveTagMap_1 = require_CaseInsensitiveTagMap();
    exports2.id3v22TagMap = {
      TT2: "title",
      TP1: "artist",
      TP2: "albumartist",
      TAL: "album",
      TYE: "year",
      COM: "comment",
      TRK: "track",
      TPA: "disk",
      TCO: "genre",
      PIC: "picture",
      TCM: "composer",
      TOR: "originaldate",
      TOT: "originalalbum",
      TXT: "lyricist",
      TP3: "conductor",
      TPB: "label",
      TT1: "grouping",
      TT3: "subtitle",
      TLA: "language",
      TCR: "copyright",
      WCP: "license",
      TEN: "encodedby",
      TSS: "encodersettings",
      WAR: "website",
      "COM:iTunPGAP": "gapless",
      PCS: "podcast",
      TCP: "compilation",
      TDR: "date",
      TS2: "albumartistsort",
      TSA: "albumsort",
      TSC: "composersort",
      TSP: "artistsort",
      TST: "titlesort",
      WFD: "podcasturl",
      TBP: "bpm"
    };
    var ID3v22TagMapper = class extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
      constructor() {
        super(["ID3v2.2"], exports2.id3v22TagMap);
      }
    };
    exports2.ID3v22TagMapper = ID3v22TagMapper;
  }
});

// node_modules/music-metadata/lib/apev2/APEv2TagMapper.js
var require_APEv2TagMapper = __commonJS({
  "node_modules/music-metadata/lib/apev2/APEv2TagMapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.APEv2TagMapper = void 0;
    var CaseInsensitiveTagMap_1 = require_CaseInsensitiveTagMap(), apev2TagMap = {
      Title: "title",
      Artist: "artist",
      Artists: "artists",
      "Album Artist": "albumartist",
      Album: "album",
      Year: "date",
      Originalyear: "originalyear",
      Originaldate: "originaldate",
      Comment: "comment",
      Track: "track",
      Disc: "disk",
      DISCNUMBER: "disk",
      Genre: "genre",
      "Cover Art (Front)": "picture",
      "Cover Art (Back)": "picture",
      Composer: "composer",
      Lyrics: "lyrics",
      ALBUMSORT: "albumsort",
      TITLESORT: "titlesort",
      WORK: "work",
      ARTISTSORT: "artistsort",
      ALBUMARTISTSORT: "albumartistsort",
      COMPOSERSORT: "composersort",
      Lyricist: "lyricist",
      Writer: "writer",
      Conductor: "conductor",
      // 'Performer=artist(instrument)': 'performer:instrument',
      MixArtist: "remixer",
      Arranger: "arranger",
      Engineer: "engineer",
      Producer: "producer",
      DJMixer: "djmixer",
      Mixer: "mixer",
      Label: "label",
      Grouping: "grouping",
      Subtitle: "subtitle",
      DiscSubtitle: "discsubtitle",
      Compilation: "compilation",
      BPM: "bpm",
      Mood: "mood",
      Media: "media",
      CatalogNumber: "catalognumber",
      MUSICBRAINZ_ALBUMSTATUS: "releasestatus",
      MUSICBRAINZ_ALBUMTYPE: "releasetype",
      RELEASECOUNTRY: "releasecountry",
      Script: "script",
      Language: "language",
      Copyright: "copyright",
      LICENSE: "license",
      EncodedBy: "encodedby",
      EncoderSettings: "encodersettings",
      Barcode: "barcode",
      ISRC: "isrc",
      ASIN: "asin",
      musicbrainz_trackid: "musicbrainz_recordingid",
      musicbrainz_releasetrackid: "musicbrainz_trackid",
      MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
      MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
      MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
      MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
      MUSICBRAINZ_WORKID: "musicbrainz_workid",
      MUSICBRAINZ_TRMID: "musicbrainz_trmid",
      MUSICBRAINZ_DISCID: "musicbrainz_discid",
      Acoustid_Id: "acoustid_id",
      ACOUSTID_FINGERPRINT: "acoustid_fingerprint",
      MUSICIP_PUID: "musicip_puid",
      Weblink: "website",
      REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
      REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
      MP3GAIN_MINMAX: "replaygain_track_minmax",
      MP3GAIN_UNDO: "replaygain_undo"
    }, APEv2TagMapper = class extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
      constructor() {
        super(["APEv2"], apev2TagMap);
      }
    };
    exports2.APEv2TagMapper = APEv2TagMapper;
  }
});

// node_modules/music-metadata/lib/mp4/MP4TagMapper.js
var require_MP4TagMapper = __commonJS({
  "node_modules/music-metadata/lib/mp4/MP4TagMapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MP4TagMapper = exports2.tagType = void 0;
    var CaseInsensitiveTagMap_1 = require_CaseInsensitiveTagMap(), mp4TagMap = {
      "\xA9nam": "title",
      "\xA9ART": "artist",
      aART: "albumartist",
      /**
       * ToDo: Album artist seems to be stored here while Picard documentation says: aART
       */
      "----:com.apple.iTunes:Band": "albumartist",
      "\xA9alb": "album",
      "\xA9day": "date",
      "\xA9cmt": "comment",
      "\xA9com": "comment",
      trkn: "track",
      disk: "disk",
      "\xA9gen": "genre",
      covr: "picture",
      "\xA9wrt": "composer",
      "\xA9lyr": "lyrics",
      soal: "albumsort",
      sonm: "titlesort",
      soar: "artistsort",
      soaa: "albumartistsort",
      soco: "composersort",
      "----:com.apple.iTunes:LYRICIST": "lyricist",
      "----:com.apple.iTunes:CONDUCTOR": "conductor",
      "----:com.apple.iTunes:REMIXER": "remixer",
      "----:com.apple.iTunes:ENGINEER": "engineer",
      "----:com.apple.iTunes:PRODUCER": "producer",
      "----:com.apple.iTunes:DJMIXER": "djmixer",
      "----:com.apple.iTunes:MIXER": "mixer",
      "----:com.apple.iTunes:LABEL": "label",
      "\xA9grp": "grouping",
      "----:com.apple.iTunes:SUBTITLE": "subtitle",
      "----:com.apple.iTunes:DISCSUBTITLE": "discsubtitle",
      cpil: "compilation",
      tmpo: "bpm",
      "----:com.apple.iTunes:MOOD": "mood",
      "----:com.apple.iTunes:MEDIA": "media",
      "----:com.apple.iTunes:CATALOGNUMBER": "catalognumber",
      tvsh: "tvShow",
      tvsn: "tvSeason",
      tves: "tvEpisode",
      sosn: "tvShowSort",
      tven: "tvEpisodeId",
      tvnn: "tvNetwork",
      pcst: "podcast",
      purl: "podcasturl",
      "----:com.apple.iTunes:MusicBrainz Album Status": "releasestatus",
      "----:com.apple.iTunes:MusicBrainz Album Type": "releasetype",
      "----:com.apple.iTunes:MusicBrainz Album Release Country": "releasecountry",
      "----:com.apple.iTunes:SCRIPT": "script",
      "----:com.apple.iTunes:LANGUAGE": "language",
      cprt: "copyright",
      "\xA9cpy": "copyright",
      "----:com.apple.iTunes:LICENSE": "license",
      "\xA9too": "encodedby",
      pgap: "gapless",
      "----:com.apple.iTunes:BARCODE": "barcode",
      "----:com.apple.iTunes:ISRC": "isrc",
      "----:com.apple.iTunes:ASIN": "asin",
      "----:com.apple.iTunes:NOTES": "comment",
      "----:com.apple.iTunes:MusicBrainz Track Id": "musicbrainz_recordingid",
      "----:com.apple.iTunes:MusicBrainz Release Track Id": "musicbrainz_trackid",
      "----:com.apple.iTunes:MusicBrainz Album Id": "musicbrainz_albumid",
      "----:com.apple.iTunes:MusicBrainz Artist Id": "musicbrainz_artistid",
      "----:com.apple.iTunes:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
      "----:com.apple.iTunes:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
      "----:com.apple.iTunes:MusicBrainz Work Id": "musicbrainz_workid",
      "----:com.apple.iTunes:MusicBrainz TRM Id": "musicbrainz_trmid",
      "----:com.apple.iTunes:MusicBrainz Disc Id": "musicbrainz_discid",
      "----:com.apple.iTunes:Acoustid Id": "acoustid_id",
      "----:com.apple.iTunes:Acoustid Fingerprint": "acoustid_fingerprint",
      "----:com.apple.iTunes:MusicIP PUID": "musicip_puid",
      "----:com.apple.iTunes:fingerprint": "musicip_fingerprint",
      "----:com.apple.iTunes:replaygain_track_gain": "replaygain_track_gain",
      "----:com.apple.iTunes:replaygain_track_peak": "replaygain_track_peak",
      "----:com.apple.iTunes:replaygain_album_gain": "replaygain_album_gain",
      "----:com.apple.iTunes:replaygain_album_peak": "replaygain_album_peak",
      "----:com.apple.iTunes:replaygain_track_minmax": "replaygain_track_minmax",
      "----:com.apple.iTunes:replaygain_album_minmax": "replaygain_album_minmax",
      "----:com.apple.iTunes:replaygain_undo": "replaygain_undo",
      // Additional mappings:
      gnre: "genre",
      "----:com.apple.iTunes:ALBUMARTISTSORT": "albumartistsort",
      "----:com.apple.iTunes:ARTISTS": "artists",
      "----:com.apple.iTunes:ORIGINALDATE": "originaldate",
      "----:com.apple.iTunes:ORIGINALYEAR": "originalyear",
      // '----:com.apple.iTunes:PERFORMER': 'performer'
      desc: "description",
      ldes: "longDescription",
      "\xA9mvn": "movement",
      "\xA9mvi": "movementIndex",
      "\xA9mvc": "movementTotal",
      "\xA9wrk": "work",
      catg: "category",
      egid: "podcastId",
      hdvd: "hdVideo",
      keyw: "keywords",
      shwm: "showMovement",
      stik: "stik",
      rate: "rating"
    };
    exports2.tagType = "iTunes";
    var MP4TagMapper = class extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
      constructor() {
        super([exports2.tagType], mp4TagMap);
      }
      postMap(tag, warnings) {
        switch (tag.id) {
          case "rate":
            tag.value = {
              source: void 0,
              rating: parseFloat(tag.value) / 100
            };
            break;
        }
      }
    };
    exports2.MP4TagMapper = MP4TagMapper;
  }
});

// node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js
var require_VorbisTagMapper = __commonJS({
  "node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.VorbisTagMapper = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper(), vorbisTagMap = {
      TITLE: "title",
      ARTIST: "artist",
      ARTISTS: "artists",
      ALBUMARTIST: "albumartist",
      "ALBUM ARTIST": "albumartist",
      ALBUM: "album",
      DATE: "date",
      ORIGINALDATE: "originaldate",
      ORIGINALYEAR: "originalyear",
      COMMENT: "comment",
      TRACKNUMBER: "track",
      DISCNUMBER: "disk",
      GENRE: "genre",
      METADATA_BLOCK_PICTURE: "picture",
      COMPOSER: "composer",
      LYRICS: "lyrics",
      ALBUMSORT: "albumsort",
      TITLESORT: "titlesort",
      WORK: "work",
      ARTISTSORT: "artistsort",
      ALBUMARTISTSORT: "albumartistsort",
      COMPOSERSORT: "composersort",
      LYRICIST: "lyricist",
      WRITER: "writer",
      CONDUCTOR: "conductor",
      // 'PERFORMER=artist(instrument)': 'performer:instrument', // ToDo
      REMIXER: "remixer",
      ARRANGER: "arranger",
      ENGINEER: "engineer",
      PRODUCER: "producer",
      DJMIXER: "djmixer",
      MIXER: "mixer",
      LABEL: "label",
      GROUPING: "grouping",
      SUBTITLE: "subtitle",
      DISCSUBTITLE: "discsubtitle",
      TRACKTOTAL: "totaltracks",
      DISCTOTAL: "totaldiscs",
      COMPILATION: "compilation",
      RATING: "rating",
      BPM: "bpm",
      KEY: "key",
      MOOD: "mood",
      MEDIA: "media",
      CATALOGNUMBER: "catalognumber",
      RELEASESTATUS: "releasestatus",
      RELEASETYPE: "releasetype",
      RELEASECOUNTRY: "releasecountry",
      SCRIPT: "script",
      LANGUAGE: "language",
      COPYRIGHT: "copyright",
      LICENSE: "license",
      ENCODEDBY: "encodedby",
      ENCODERSETTINGS: "encodersettings",
      BARCODE: "barcode",
      ISRC: "isrc",
      ASIN: "asin",
      MUSICBRAINZ_TRACKID: "musicbrainz_recordingid",
      MUSICBRAINZ_RELEASETRACKID: "musicbrainz_trackid",
      MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
      MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
      MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
      MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
      MUSICBRAINZ_WORKID: "musicbrainz_workid",
      MUSICBRAINZ_TRMID: "musicbrainz_trmid",
      MUSICBRAINZ_DISCID: "musicbrainz_discid",
      ACOUSTID_ID: "acoustid_id",
      ACOUSTID_ID_FINGERPRINT: "acoustid_fingerprint",
      MUSICIP_PUID: "musicip_puid",
      // 'FINGERPRINT=MusicMagic Fingerprint{fingerprint}': 'musicip_fingerprint', // ToDo
      WEBSITE: "website",
      NOTES: "notes",
      TOTALTRACKS: "totaltracks",
      TOTALDISCS: "totaldiscs",
      // Discogs
      DISCOGS_ARTIST_ID: "discogs_artist_id",
      DISCOGS_ARTISTS: "artists",
      DISCOGS_ARTIST_NAME: "artists",
      DISCOGS_ALBUM_ARTISTS: "albumartist",
      DISCOGS_CATALOG: "catalognumber",
      DISCOGS_COUNTRY: "releasecountry",
      DISCOGS_DATE: "originaldate",
      DISCOGS_LABEL: "label",
      DISCOGS_LABEL_ID: "discogs_label_id",
      DISCOGS_MASTER_RELEASE_ID: "discogs_master_release_id",
      DISCOGS_RATING: "discogs_rating",
      DISCOGS_RELEASED: "date",
      DISCOGS_RELEASE_ID: "discogs_release_id",
      DISCOGS_VOTES: "discogs_votes",
      CATALOGID: "catalognumber",
      STYLE: "genre",
      //
      REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
      REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
      REPLAYGAIN_ALBUM_GAIN: "replaygain_album_gain",
      REPLAYGAIN_ALBUM_PEAK: "replaygain_album_peak",
      // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:
      REPLAYGAIN_MINMAX: "replaygain_track_minmax",
      REPLAYGAIN_ALBUM_MINMAX: "replaygain_album_minmax",
      REPLAYGAIN_UNDO: "replaygain_undo"
    }, VorbisTagMapper = class _VorbisTagMapper extends GenericTagMapper_1.CommonTagMapper {
      static toRating(email, rating, maxScore) {
        return {
          source: email && email.toLowerCase(),
          rating: parseFloat(rating) / maxScore * GenericTagMapper_1.CommonTagMapper.maxRatingScore
        };
      }
      constructor() {
        super(["vorbis"], vorbisTagMap);
      }
      postMap(tag) {
        if (tag.id === "RATING")
          tag.value = _VorbisTagMapper.toRating(void 0, tag.value, 100);
        else if (tag.id.indexOf("RATING:") === 0) {
          let keys = tag.id.split(":");
          tag.value = _VorbisTagMapper.toRating(keys[1], tag.value, 1), tag.id = keys[0];
        }
      }
    };
    exports2.VorbisTagMapper = VorbisTagMapper;
  }
});

// node_modules/music-metadata/lib/riff/RiffInfoTagMap.js
var require_RiffInfoTagMap = __commonJS({
  "node_modules/music-metadata/lib/riff/RiffInfoTagMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.RiffInfoTagMapper = exports2.riffInfoTagMap = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper();
    exports2.riffInfoTagMap = {
      IART: "artist",
      ICRD: "date",
      INAM: "title",
      TITL: "title",
      IPRD: "album",
      ITRK: "track",
      IPRT: "track",
      COMM: "comment",
      ICMT: "comment",
      ICNT: "releasecountry",
      GNRE: "genre",
      IWRI: "writer",
      RATE: "rating",
      YEAR: "year",
      ISFT: "encodedby",
      CODE: "encodedby",
      TURL: "website",
      IGNR: "genre",
      IENG: "engineer",
      ITCH: "technician",
      IMED: "media",
      IRPD: "album"
      // Product, where the file was intended for
    };
    var RiffInfoTagMapper = class extends GenericTagMapper_1.CommonTagMapper {
      constructor() {
        super(["exif"], exports2.riffInfoTagMap);
      }
    };
    exports2.RiffInfoTagMapper = RiffInfoTagMapper;
  }
});

// node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js
var require_MatroskaTagMapper = __commonJS({
  "node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MatroskaTagMapper = void 0;
    var CaseInsensitiveTagMap_1 = require_CaseInsensitiveTagMap(), ebmlTagMap = {
      "segment:title": "title",
      "album:ARTIST": "albumartist",
      "album:ARTISTSORT": "albumartistsort",
      "album:TITLE": "album",
      "album:DATE_RECORDED": "originaldate",
      "album:PART_NUMBER": "disk",
      "album:TOTAL_PARTS": "totaltracks",
      "track:ARTIST": "artist",
      "track:ARTISTSORT": "artistsort",
      "track:TITLE": "title",
      "track:PART_NUMBER": "track",
      "track:MUSICBRAINZ_TRACKID": "musicbrainz_recordingid",
      "track:MUSICBRAINZ_ALBUMID": "musicbrainz_albumid",
      "track:MUSICBRAINZ_ARTISTID": "musicbrainz_artistid",
      "track:PUBLISHER": "label",
      "track:GENRE": "genre",
      "track:ENCODER": "encodedby",
      "track:ENCODER_OPTIONS": "encodersettings",
      "edition:TOTAL_PARTS": "totaldiscs",
      picture: "picture"
    }, MatroskaTagMapper = class extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {
      constructor() {
        super(["matroska"], ebmlTagMap);
      }
    };
    exports2.MatroskaTagMapper = MatroskaTagMapper;
  }
});

// node_modules/music-metadata/lib/aiff/AiffTagMap.js
var require_AiffTagMap = __commonJS({
  "node_modules/music-metadata/lib/aiff/AiffTagMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AiffTagMapper = void 0;
    var GenericTagMapper_1 = require_GenericTagMapper(), tagMap = {
      NAME: "title",
      AUTH: "artist",
      "(c) ": "copyright",
      ANNO: "comment"
    }, AiffTagMapper = class extends GenericTagMapper_1.CommonTagMapper {
      constructor() {
        super(["AIFF"], tagMap);
      }
    };
    exports2.AiffTagMapper = AiffTagMapper;
  }
});

// node_modules/music-metadata/lib/common/CombinedTagMapper.js
var require_CombinedTagMapper = __commonJS({
  "node_modules/music-metadata/lib/common/CombinedTagMapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.CombinedTagMapper = void 0;
    var ID3v1TagMap_1 = require_ID3v1TagMap(), ID3v24TagMapper_1 = require_ID3v24TagMapper(), AsfTagMapper_1 = require_AsfTagMapper(), ID3v22TagMapper_1 = require_ID3v22TagMapper(), APEv2TagMapper_1 = require_APEv2TagMapper(), MP4TagMapper_1 = require_MP4TagMapper(), VorbisTagMapper_1 = require_VorbisTagMapper(), RiffInfoTagMap_1 = require_RiffInfoTagMap(), MatroskaTagMapper_1 = require_MatroskaTagMapper(), AiffTagMap_1 = require_AiffTagMap(), CombinedTagMapper = class {
      constructor() {
        this.tagMappers = {}, [
          new ID3v1TagMap_1.ID3v1TagMapper(),
          new ID3v22TagMapper_1.ID3v22TagMapper(),
          new ID3v24TagMapper_1.ID3v24TagMapper(),
          new MP4TagMapper_1.MP4TagMapper(),
          new MP4TagMapper_1.MP4TagMapper(),
          new VorbisTagMapper_1.VorbisTagMapper(),
          new APEv2TagMapper_1.APEv2TagMapper(),
          new AsfTagMapper_1.AsfTagMapper(),
          new RiffInfoTagMap_1.RiffInfoTagMapper(),
          new MatroskaTagMapper_1.MatroskaTagMapper(),
          new AiffTagMap_1.AiffTagMapper()
        ].forEach((mapper) => {
          this.registerTagMapper(mapper);
        });
      }
      /**
       * Convert native to generic (common) tags
       * @param tagType Originating tag format
       * @param tag     Native tag to map to a generic tag id
       * @param warnings
       * @return Generic tag result (output of this function)
       */
      mapTag(tagType, tag, warnings) {
        if (this.tagMappers[tagType])
          return this.tagMappers[tagType].mapGenericTag(tag, warnings);
        throw new Error("No generic tag mapper defined for tag-format: " + tagType);
      }
      registerTagMapper(genericTagMapper) {
        for (let tagType of genericTagMapper.tagTypes)
          this.tagMappers[tagType] = genericTagMapper;
      }
    };
    exports2.CombinedTagMapper = CombinedTagMapper;
  }
});

// node_modules/music-metadata/lib/common/MetadataCollector.js
var require_MetadataCollector = __commonJS({
  "node_modules/music-metadata/lib/common/MetadataCollector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.joinArtists = exports2.MetadataCollector = void 0;
    var type_1 = require_type(), debug_1 = require_browser(), GenericTagTypes_1 = require_GenericTagTypes(), CombinedTagMapper_1 = require_CombinedTagMapper(), GenericTagMapper_1 = require_GenericTagMapper(), Util_1 = require_Util(), FileType = require_core2(), debug = (0, debug_1.default)("music-metadata:collector"), TagPriority = ["matroska", "APEv2", "vorbis", "ID3v2.4", "ID3v2.3", "ID3v2.2", "exif", "asf", "iTunes", "AIFF", "ID3v1"], MetadataCollector = class {
      constructor(opts) {
        this.opts = opts, this.format = {
          tagTypes: [],
          trackInfo: []
        }, this.native = {}, this.common = {
          track: { no: null, of: null },
          disk: { no: null, of: null },
          movementIndex: {}
        }, this.quality = {
          warnings: []
        }, this.commonOrigin = {}, this.originPriority = {}, this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();
        let priority = 1;
        for (let tagType of TagPriority)
          this.originPriority[tagType] = priority++;
        this.originPriority.artificial = 500, this.originPriority.id3v1 = 600;
      }
      /**
       * @returns {boolean} true if one or more tags have been found
       */
      hasAny() {
        return Object.keys(this.native).length > 0;
      }
      addStreamInfo(streamInfo) {
        debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`), this.format.trackInfo.push(streamInfo);
      }
      setFormat(key, value) {
        debug(`format: ${key} = ${value}`), this.format[key] = value, this.opts.observer && this.opts.observer({ metadata: this, tag: { type: "format", id: key, value } });
      }
      addTag(tagType, tagId, value) {
        debug(`tag ${tagType}.${tagId} = ${value}`), this.native[tagType] || (this.format.tagTypes.push(tagType), this.native[tagType] = []), this.native[tagType].push({ id: tagId, value }), this.toCommon(tagType, tagId, value);
      }
      addWarning(warning) {
        this.quality.warnings.push({ message: warning });
      }
      postMap(tagType, tag) {
        switch (tag.id) {
          case "artist":
            if (this.commonOrigin.artist === this.originPriority[tagType])
              return this.postMap("artificial", { id: "artists", value: tag.value });
            this.common.artists || this.setGenericTag("artificial", { id: "artists", value: tag.value });
            break;
          case "artists":
            if ((!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) && (!this.common.artists || this.common.artists.indexOf(tag.value) === -1)) {
              let artists = (this.common.artists || []).concat([tag.value]), artistTag = { id: "artist", value: joinArtists(artists) };
              this.setGenericTag("artificial", artistTag);
            }
            break;
          case "picture":
            this.postFixPicture(tag.value).then((picture) => {
              picture !== null && (tag.value = picture, this.setGenericTag(tagType, tag));
            });
            return;
          case "totaltracks":
            this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
            return;
          case "totaldiscs":
            this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
            return;
          case "movementTotal":
            this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
            return;
          case "track":
          case "disk":
          case "movementIndex":
            let of = this.common[tag.id].of;
            this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value), this.common[tag.id].of = of != null ? of : this.common[tag.id].of;
            return;
          case "bpm":
          case "year":
          case "originalyear":
            tag.value = parseInt(tag.value, 10);
            break;
          case "date":
            let year = parseInt(tag.value.substr(0, 4), 10);
            isNaN(year) || (this.common.year = year);
            break;
          case "discogs_label_id":
          case "discogs_release_id":
          case "discogs_master_release_id":
          case "discogs_artist_id":
          case "discogs_votes":
            tag.value = typeof tag.value == "string" ? parseInt(tag.value, 10) : tag.value;
            break;
          case "replaygain_track_gain":
          case "replaygain_track_peak":
          case "replaygain_album_gain":
          case "replaygain_album_peak":
            tag.value = (0, Util_1.toRatio)(tag.value);
            break;
          case "replaygain_track_minmax":
            tag.value = tag.value.split(",").map((v) => parseInt(v, 10));
            break;
          case "replaygain_undo":
            let minMix = tag.value.split(",").map((v) => parseInt(v, 10));
            tag.value = {
              leftChannel: minMix[0],
              rightChannel: minMix[1]
            };
            break;
          case "gapless":
          case "compilation":
          case "podcast":
          case "showMovement":
            tag.value = tag.value === "1" || tag.value === 1;
            break;
          case "isrc":
            if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1)
              return;
            break;
          default:
        }
        tag.value !== null && this.setGenericTag(tagType, tag);
      }
      /**
       * Convert native tags to common tags
       * @returns {IAudioMetadata} Native + common tags
       */
      toCommonMetadata() {
        return {
          format: this.format,
          native: this.native,
          quality: this.quality,
          common: this.common
        };
      }
      /**
       * Fix some common issues with picture object
       * @param picture Picture
       */
      async postFixPicture(picture) {
        if (picture.data && picture.data.length > 0) {
          if (!picture.format) {
            let fileType2 = await FileType.fromBuffer(picture.data);
            if (fileType2)
              picture.format = fileType2.mime;
            else
              return null;
          }
          switch (picture.format = picture.format.toLocaleLowerCase(), picture.format) {
            case "image/jpg":
              picture.format = "image/jpeg";
          }
          return picture;
        }
        return this.addWarning("Empty picture tag found"), null;
      }
      /**
       * Convert native tag to common tags
       */
      toCommon(tagType, tagId, value) {
        let tag = { id: tagId, value }, genericTag = this.tagMapper.mapTag(tagType, tag, this);
        genericTag && this.postMap(tagType, genericTag);
      }
      /**
       * Set generic tag
       */
      setGenericTag(tagType, tag) {
        debug(`common.${tag.id} = ${tag.value}`);
        let prio0 = this.commonOrigin[tag.id] || 1e3, prio1 = this.originPriority[tagType];
        if ((0, GenericTagTypes_1.isSingleton)(tag.id))
          if (prio1 <= prio0)
            this.common[tag.id] = tag.value, this.commonOrigin[tag.id] = prio1;
          else
            return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);
        else if (prio1 === prio0)
          !(0, GenericTagTypes_1.isUnique)(tag.id) || this.common[tag.id].indexOf(tag.value) === -1 ? this.common[tag.id].push(tag.value) : debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);
        else if (prio1 < prio0)
          this.common[tag.id] = [tag.value], this.commonOrigin[tag.id] = prio1;
        else
          return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);
        this.opts.observer && this.opts.observer({ metadata: this, tag: { type: "common", id: tag.id, value: tag.value } });
      }
    };
    exports2.MetadataCollector = MetadataCollector;
    function joinArtists(artists) {
      return artists.length > 2 ? artists.slice(0, artists.length - 1).join(", ") + " & " + artists[artists.length - 1] : artists.join(" & ");
    }
    exports2.joinArtists = joinArtists;
  }
});

// node_modules/music-metadata/lib/id3v2/ID3v2Token.js
var require_ID3v2Token = __commonJS({
  "node_modules/music-metadata/lib/id3v2/ID3v2Token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.TextEncodingToken = exports2.ExtendedHeader = exports2.ID3v2Header = exports2.UINT32SYNCSAFE = exports2.AttachedPictureType = void 0;
    var Token2 = require_lib3(), util = require_Util(), AttachedPictureType;
    (function(AttachedPictureType2) {
      AttachedPictureType2[AttachedPictureType2.Other = 0] = "Other", AttachedPictureType2[AttachedPictureType2["32x32 pixels 'file icon' (PNG only)"] = 1] = "32x32 pixels 'file icon' (PNG only)", AttachedPictureType2[AttachedPictureType2["Other file icon"] = 2] = "Other file icon", AttachedPictureType2[AttachedPictureType2["Cover (front)"] = 3] = "Cover (front)", AttachedPictureType2[AttachedPictureType2["Cover (back)"] = 4] = "Cover (back)", AttachedPictureType2[AttachedPictureType2["Leaflet page"] = 5] = "Leaflet page", AttachedPictureType2[AttachedPictureType2["Media (e.g. label side of CD)"] = 6] = "Media (e.g. label side of CD)", AttachedPictureType2[AttachedPictureType2["Lead artist/lead performer/soloist"] = 7] = "Lead artist/lead performer/soloist", AttachedPictureType2[AttachedPictureType2["Artist/performer"] = 8] = "Artist/performer", AttachedPictureType2[AttachedPictureType2.Conductor = 9] = "Conductor", AttachedPictureType2[AttachedPictureType2["Band/Orchestra"] = 10] = "Band/Orchestra", AttachedPictureType2[AttachedPictureType2.Composer = 11] = "Composer", AttachedPictureType2[AttachedPictureType2["Lyricist/text writer"] = 12] = "Lyricist/text writer", AttachedPictureType2[AttachedPictureType2["Recording Location"] = 13] = "Recording Location", AttachedPictureType2[AttachedPictureType2["During recording"] = 14] = "During recording", AttachedPictureType2[AttachedPictureType2["During performance"] = 15] = "During performance", AttachedPictureType2[AttachedPictureType2["Movie/video screen capture"] = 16] = "Movie/video screen capture", AttachedPictureType2[AttachedPictureType2["A bright coloured fish"] = 17] = "A bright coloured fish", AttachedPictureType2[AttachedPictureType2.Illustration = 18] = "Illustration", AttachedPictureType2[AttachedPictureType2["Band/artist logotype"] = 19] = "Band/artist logotype", AttachedPictureType2[AttachedPictureType2["Publisher/Studio logotype"] = 20] = "Publisher/Studio logotype";
    })(AttachedPictureType = exports2.AttachedPictureType || (exports2.AttachedPictureType = {}));
    exports2.UINT32SYNCSAFE = {
      get: (buf, off) => buf[off + 3] & 127 | buf[off + 2] << 7 | buf[off + 1] << 14 | buf[off] << 21,
      len: 4
    };
    exports2.ID3v2Header = {
      len: 10,
      get: (buf, off) => ({
        // ID3v2/file identifier   "ID3"
        fileIdentifier: new Token2.StringType(3, "ascii").get(buf, off),
        // ID3v2 versionIndex
        version: {
          major: Token2.INT8.get(buf, off + 3),
          revision: Token2.INT8.get(buf, off + 4)
        },
        // ID3v2 flags
        flags: {
          // Unsynchronisation
          unsynchronisation: util.getBit(buf, off + 5, 7),
          // Extended header
          isExtendedHeader: util.getBit(buf, off + 5, 6),
          // Experimental indicator
          expIndicator: util.getBit(buf, off + 5, 5),
          footer: util.getBit(buf, off + 5, 4)
        },
        size: exports2.UINT32SYNCSAFE.get(buf, off + 6)
      })
    };
    exports2.ExtendedHeader = {
      len: 10,
      get: (buf, off) => ({
        // Extended header size
        size: Token2.UINT32_BE.get(buf, off),
        // Extended Flags
        extendedFlags: Token2.UINT16_BE.get(buf, off + 4),
        // Size of padding
        sizeOfPadding: Token2.UINT32_BE.get(buf, off + 6),
        // CRC data present
        crcDataPresent: util.getBit(buf, off + 4, 31)
      })
    };
    exports2.TextEncodingToken = {
      len: 1,
      get: (uint8Array, off) => {
        switch (uint8Array[off]) {
          case 0:
            return { encoding: "latin1" };
          case 1:
            return { encoding: "utf16le", bom: !0 };
          case 2:
            return { encoding: "utf16le", bom: !1 };
          case 3:
            return { encoding: "utf8", bom: !1 };
          default:
            return { encoding: "utf8", bom: !1 };
        }
      }
    };
  }
});

// node_modules/music-metadata/lib/common/BasicParser.js
var require_BasicParser = __commonJS({
  "node_modules/music-metadata/lib/common/BasicParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.BasicParser = void 0;
    var BasicParser = class {
      /**
       * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
       * @param {INativeMetadataCollector} metadata Output
       * @param {ITokenizer} tokenizer Input
       * @param {IOptions} options Parsing options
       */
      init(metadata, tokenizer, options) {
        return this.metadata = metadata, this.tokenizer = tokenizer, this.options = options, this;
      }
    };
    exports2.BasicParser = BasicParser;
  }
});

// node_modules/music-metadata/lib/common/FourCC.js
var require_FourCC = __commonJS({
  "node_modules/music-metadata/lib/common/FourCC.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.FourCcToken = void 0;
    var util = require_Util(), validFourCC = /^[\x21-\x7e][\x20-\x7e\x00()]{3}/;
    exports2.FourCcToken = {
      len: 4,
      get: (buf, off) => {
        let id = buf.toString("binary", off, off + exports2.FourCcToken.len);
        if (!id.match(validFourCC))
          throw new Error(`FourCC contains invalid characters: ${util.a2hex(id)} "${id}"`);
        return id;
      },
      put: (buffer, offset, id) => {
        let str = Buffer.from(id, "binary");
        if (str.length !== 4)
          throw new Error("Invalid length");
        return str.copy(buffer, offset);
      }
    };
  }
});

// node_modules/music-metadata/lib/apev2/APEv2Token.js
var require_APEv2Token = __commonJS({
  "node_modules/music-metadata/lib/apev2/APEv2Token.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isBitSet = exports2.parseTagFlags = exports2.TagField = exports2.TagItemHeader = exports2.TagFooter = exports2.Header = exports2.DescriptorParser = exports2.DataType = void 0;
    var Token2 = require_lib3(), FourCC_1 = require_FourCC(), DataType;
    (function(DataType2) {
      DataType2[DataType2.text_utf8 = 0] = "text_utf8", DataType2[DataType2.binary = 1] = "binary", DataType2[DataType2.external_info = 2] = "external_info", DataType2[DataType2.reserved = 3] = "reserved";
    })(DataType = exports2.DataType || (exports2.DataType = {}));
    exports2.DescriptorParser = {
      len: 52,
      get: (buf, off) => ({
        // should equal 'MAC '
        ID: FourCC_1.FourCcToken.get(buf, off),
        // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
        version: Token2.UINT32_LE.get(buf, off + 4) / 1e3,
        // the number of descriptor bytes (allows later expansion of this header)
        descriptorBytes: Token2.UINT32_LE.get(buf, off + 8),
        // the number of header APE_HEADER bytes
        headerBytes: Token2.UINT32_LE.get(buf, off + 12),
        // the number of header APE_HEADER bytes
        seekTableBytes: Token2.UINT32_LE.get(buf, off + 16),
        // the number of header data bytes (from original file)
        headerDataBytes: Token2.UINT32_LE.get(buf, off + 20),
        // the number of bytes of APE frame data
        apeFrameDataBytes: Token2.UINT32_LE.get(buf, off + 24),
        // the high order number of APE frame data bytes
        apeFrameDataBytesHigh: Token2.UINT32_LE.get(buf, off + 28),
        // the terminating data of the file (not including tag data)
        terminatingDataBytes: Token2.UINT32_LE.get(buf, off + 32),
        // the MD5 hash of the file (see notes for usage... it's a little tricky)
        fileMD5: new Token2.Uint8ArrayType(16).get(buf, off + 36)
      })
    };
    exports2.Header = {
      len: 24,
      get: (buf, off) => ({
        // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
        compressionLevel: Token2.UINT16_LE.get(buf, off),
        // any format flags (for future use)
        formatFlags: Token2.UINT16_LE.get(buf, off + 2),
        // the number of audio blocks in one frame
        blocksPerFrame: Token2.UINT32_LE.get(buf, off + 4),
        // the number of audio blocks in the final frame
        finalFrameBlocks: Token2.UINT32_LE.get(buf, off + 8),
        // the total number of frames
        totalFrames: Token2.UINT32_LE.get(buf, off + 12),
        // the bits per sample (typically 16)
        bitsPerSample: Token2.UINT16_LE.get(buf, off + 16),
        // the number of channels (1 or 2)
        channel: Token2.UINT16_LE.get(buf, off + 18),
        // the sample rate (typically 44100)
        sampleRate: Token2.UINT32_LE.get(buf, off + 20)
      })
    };
    exports2.TagFooter = {
      len: 32,
      get: (buf, off) => ({
        // should equal 'APETAGEX'
        ID: new Token2.StringType(8, "ascii").get(buf, off),
        // equals CURRENT_APE_TAG_VERSION
        version: Token2.UINT32_LE.get(buf, off + 8),
        // the complete size of the tag, including this footer (excludes header)
        size: Token2.UINT32_LE.get(buf, off + 12),
        // the number of fields in the tag
        fields: Token2.UINT32_LE.get(buf, off + 16),
        // reserved for later use (must be zero),
        flags: parseTagFlags(Token2.UINT32_LE.get(buf, off + 20))
      })
    };
    exports2.TagItemHeader = {
      len: 8,
      get: (buf, off) => ({
        // Length of assigned value in bytes
        size: Token2.UINT32_LE.get(buf, off),
        // reserved for later use (must be zero),
        flags: parseTagFlags(Token2.UINT32_LE.get(buf, off + 4))
      })
    };
    var TagField = (footer) => new Token2.Uint8ArrayType(footer.size - exports2.TagFooter.len);
    exports2.TagField = TagField;
    function parseTagFlags(flags) {
      return {
        containsHeader: isBitSet(flags, 31),
        containsFooter: isBitSet(flags, 30),
        isHeader: isBitSet(flags, 31),
        readOnly: isBitSet(flags, 0),
        dataType: (flags & 6) >> 1
      };
    }
    exports2.parseTagFlags = parseTagFlags;
    function isBitSet(num, bit) {
      return (num & 1 << bit) !== 0;
    }
    exports2.isBitSet = isBitSet;
  }
});

// node_modules/music-metadata/lib/apev2/APEv2Parser.js
var require_APEv2Parser = __commonJS({
  "node_modules/music-metadata/lib/apev2/APEv2Parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.APEv2Parser = void 0;
    var debug_1 = require_browser(), strtok32 = require_core(), token_types_1 = require_lib3(), util = require_Util(), BasicParser_1 = require_BasicParser(), APEv2Token_1 = require_APEv2Token(), debug = (0, debug_1.default)("music-metadata:parser:APEv2"), tagFormat = "APEv2", preamble = "APETAGEX", APEv2Parser = class _APEv2Parser extends BasicParser_1.BasicParser {
      constructor() {
        super(...arguments), this.ape = {};
      }
      static tryParseApeHeader(metadata, tokenizer, options) {
        let apeParser = new _APEv2Parser();
        return apeParser.init(metadata, tokenizer, options), apeParser.tryParseApeHeader();
      }
      /**
       * Calculate the media file duration
       * @param ah ApeHeader
       * @return {number} duration in seconds
       */
      static calculateDuration(ah) {
        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
        return duration += ah.finalFrameBlocks, duration / ah.sampleRate;
      }
      /**
       * Calculates the APEv1 / APEv2 first field offset
       * @param reader
       * @param offset
       */
      static async findApeFooterOffset(reader, offset) {
        let apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);
        await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);
        let tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);
        if (tagFooter.ID === "APETAGEX")
          return debug(`APE footer header at offset=${offset}`), { footer: tagFooter, offset: offset - tagFooter.size };
      }
      static parseTagFooter(metadata, buffer, options) {
        let footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);
        if (footer.ID !== preamble)
          throw new Error("Unexpected APEv2 Footer ID preamble value.");
        strtok32.fromBuffer(buffer);
        let apeParser = new _APEv2Parser();
        return apeParser.init(metadata, strtok32.fromBuffer(buffer), options), apeParser.parseTags(footer);
      }
      /**
       * Parse APEv1 / APEv2 header if header signature found
       */
      async tryParseApeHeader() {
        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {
          debug("No APEv2 header found, end-of-file reached");
          return;
        }
        let footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);
        if (footer.ID === preamble)
          return await this.tokenizer.ignore(APEv2Token_1.TagFooter.len), this.parseTags(footer);
        if (debug(`APEv2 header not found at offset=${this.tokenizer.position}`), this.tokenizer.fileInfo.size) {
          let remaining = this.tokenizer.fileInfo.size - this.tokenizer.position, buffer = Buffer.alloc(remaining);
          return await this.tokenizer.readBuffer(buffer), _APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);
        }
      }
      async parse() {
        let descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);
        if (descriptor.ID !== "MAC ")
          throw new Error("Unexpected descriptor ID");
        this.ape.descriptor = descriptor;
        let lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len, header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());
        return await this.tokenizer.ignore(header.forwardBytes), this.tryParseApeHeader();
      }
      async parseTags(footer) {
        let keyBuffer = Buffer.alloc(256), bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;
        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);
        for (let i = 0; i < footer.fields; i++) {
          if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {
            this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);
            break;
          }
          let tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);
          bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size, await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });
          let zero = util.findZero(keyBuffer, 0, keyBuffer.length), key = await this.tokenizer.readToken(new token_types_1.StringType(zero, "ascii"));
          switch (await this.tokenizer.ignore(1), bytesRemaining -= key.length + 1, tagItemHeader.flags.dataType) {
            case APEv2Token_1.DataType.text_utf8: {
              let values = (await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, "utf8"))).split(/\x00/g);
              for (let val of values)
                this.metadata.addTag(tagFormat, key, val);
              break;
            }
            case APEv2Token_1.DataType.binary:
              if (this.options.skipCovers)
                await this.tokenizer.ignore(tagItemHeader.size);
              else {
                let picData = Buffer.alloc(tagItemHeader.size);
                await this.tokenizer.readBuffer(picData), zero = util.findZero(picData, 0, picData.length);
                let description = picData.toString("utf8", 0, zero), data = Buffer.from(picData.slice(zero + 1));
                this.metadata.addTag(tagFormat, key, {
                  description,
                  data
                });
              }
              break;
            case APEv2Token_1.DataType.external_info:
              debug(`Ignore external info ${key}`), await this.tokenizer.ignore(tagItemHeader.size);
              break;
            case APEv2Token_1.DataType.reserved:
              debug(`Ignore external info ${key}`), this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${key}"`), await this.tokenizer.ignore(tagItemHeader.size);
              break;
          }
        }
      }
      async parseDescriptorExpansion(lenExp) {
        return await this.tokenizer.ignore(lenExp), this.parseHeader();
      }
      async parseHeader() {
        let header = await this.tokenizer.readToken(APEv2Token_1.Header);
        return this.metadata.setFormat("lossless", !0), this.metadata.setFormat("container", "Monkey's Audio"), this.metadata.setFormat("bitsPerSample", header.bitsPerSample), this.metadata.setFormat("sampleRate", header.sampleRate), this.metadata.setFormat("numberOfChannels", header.channel), this.metadata.setFormat("duration", _APEv2Parser.calculateDuration(header)), {
          forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
        };
      }
    };
    exports2.APEv2Parser = APEv2Parser;
  }
});

// node_modules/music-metadata/lib/id3v1/ID3v1Parser.js
var require_ID3v1Parser = __commonJS({
  "node_modules/music-metadata/lib/id3v1/ID3v1Parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.hasID3v1Header = exports2.ID3v1Parser = exports2.Genres = void 0;
    var debug_1 = require_browser(), token_types_1 = require_lib3(), util = require_Util(), BasicParser_1 = require_BasicParser(), APEv2Parser_1 = require_APEv2Parser(), debug = (0, debug_1.default)("music-metadata:parser:ID3v1");
    exports2.Genres = [
      "Blues",
      "Classic Rock",
      "Country",
      "Dance",
      "Disco",
      "Funk",
      "Grunge",
      "Hip-Hop",
      "Jazz",
      "Metal",
      "New Age",
      "Oldies",
      "Other",
      "Pop",
      "R&B",
      "Rap",
      "Reggae",
      "Rock",
      "Techno",
      "Industrial",
      "Alternative",
      "Ska",
      "Death Metal",
      "Pranks",
      "Soundtrack",
      "Euro-Techno",
      "Ambient",
      "Trip-Hop",
      "Vocal",
      "Jazz+Funk",
      "Fusion",
      "Trance",
      "Classical",
      "Instrumental",
      "Acid",
      "House",
      "Game",
      "Sound Clip",
      "Gospel",
      "Noise",
      "Alt. Rock",
      "Bass",
      "Soul",
      "Punk",
      "Space",
      "Meditative",
      "Instrumental Pop",
      "Instrumental Rock",
      "Ethnic",
      "Gothic",
      "Darkwave",
      "Techno-Industrial",
      "Electronic",
      "Pop-Folk",
      "Eurodance",
      "Dream",
      "Southern Rock",
      "Comedy",
      "Cult",
      "Gangsta Rap",
      "Top 40",
      "Christian Rap",
      "Pop/Funk",
      "Jungle",
      "Native American",
      "Cabaret",
      "New Wave",
      "Psychedelic",
      "Rave",
      "Showtunes",
      "Trailer",
      "Lo-Fi",
      "Tribal",
      "Acid Punk",
      "Acid Jazz",
      "Polka",
      "Retro",
      "Musical",
      "Rock & Roll",
      "Hard Rock",
      "Folk",
      "Folk/Rock",
      "National Folk",
      "Swing",
      "Fast-Fusion",
      "Bebob",
      "Latin",
      "Revival",
      "Celtic",
      "Bluegrass",
      "Avantgarde",
      "Gothic Rock",
      "Progressive Rock",
      "Psychedelic Rock",
      "Symphonic Rock",
      "Slow Rock",
      "Big Band",
      "Chorus",
      "Easy Listening",
      "Acoustic",
      "Humour",
      "Speech",
      "Chanson",
      "Opera",
      "Chamber Music",
      "Sonata",
      "Symphony",
      "Booty Bass",
      "Primus",
      "Porn Groove",
      "Satire",
      "Slow Jam",
      "Club",
      "Tango",
      "Samba",
      "Folklore",
      "Ballad",
      "Power Ballad",
      "Rhythmic Soul",
      "Freestyle",
      "Duet",
      "Punk Rock",
      "Drum Solo",
      "A Cappella",
      "Euro-House",
      "Dance Hall",
      "Goa",
      "Drum & Bass",
      "Club-House",
      "Hardcore",
      "Terror",
      "Indie",
      "BritPop",
      "Negerpunk",
      "Polsk Punk",
      "Beat",
      "Christian Gangsta Rap",
      "Heavy Metal",
      "Black Metal",
      "Crossover",
      "Contemporary Christian",
      "Christian Rock",
      "Merengue",
      "Salsa",
      "Thrash Metal",
      "Anime",
      "JPop",
      "Synthpop",
      "Abstract",
      "Art Rock",
      "Baroque",
      "Bhangra",
      "Big Beat",
      "Breakbeat",
      "Chillout",
      "Downtempo",
      "Dub",
      "EBM",
      "Eclectic",
      "Electro",
      "Electroclash",
      "Emo",
      "Experimental",
      "Garage",
      "Global",
      "IDM",
      "Illbient",
      "Industro-Goth",
      "Jam Band",
      "Krautrock",
      "Leftfield",
      "Lounge",
      "Math Rock",
      "New Romantic",
      "Nu-Breakz",
      "Post-Punk",
      "Post-Rock",
      "Psytrance",
      "Shoegaze",
      "Space Rock",
      "Trop Rock",
      "World Music",
      "Neoclassical",
      "Audiobook",
      "Audio Theatre",
      "Neue Deutsche Welle",
      "Podcast",
      "Indie Rock",
      "G-Funk",
      "Dubstep",
      "Garage Rock",
      "Psybient"
    ];
    var Iid3v1Token = {
      len: 128,
      /**
       * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header
       * @param off Offset in buffer in bytes
       * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned
       */
      get: (buf, off) => {
        let header = new Id3v1StringType(3).get(buf, off);
        return header === "TAG" ? {
          header,
          title: new Id3v1StringType(30).get(buf, off + 3),
          artist: new Id3v1StringType(30).get(buf, off + 33),
          album: new Id3v1StringType(30).get(buf, off + 63),
          year: new Id3v1StringType(4).get(buf, off + 93),
          comment: new Id3v1StringType(28).get(buf, off + 97),
          // ID3v1.1 separator for track
          zeroByte: token_types_1.UINT8.get(buf, off + 127),
          // track: ID3v1.1 field added by Michael Mutschler
          track: token_types_1.UINT8.get(buf, off + 126),
          genre: token_types_1.UINT8.get(buf, off + 127)
        } : null;
      }
    }, Id3v1StringType = class extends token_types_1.StringType {
      constructor(len) {
        super(len, "binary");
      }
      get(buf, off) {
        let value = super.get(buf, off);
        return value = util.trimRightNull(value), value = value.trim(), value.length > 0 ? value : void 0;
      }
    }, ID3v1Parser = class _ID3v1Parser extends BasicParser_1.BasicParser {
      static getGenre(genreIndex) {
        if (genreIndex < exports2.Genres.length)
          return exports2.Genres[genreIndex];
      }
      async parse() {
        if (!this.tokenizer.fileInfo.size) {
          debug("Skip checking for ID3v1 because the file-size is unknown");
          return;
        }
        if (this.options.apeHeader) {
          this.tokenizer.ignore(this.options.apeHeader.offset - this.tokenizer.position);
          let apeParser = new APEv2Parser_1.APEv2Parser();
          apeParser.init(this.metadata, this.tokenizer, this.options), await apeParser.parseTags(this.options.apeHeader.footer);
        }
        let offset = this.tokenizer.fileInfo.size - Iid3v1Token.len;
        if (this.tokenizer.position > offset) {
          debug("Already consumed the last 128 bytes");
          return;
        }
        let header = await this.tokenizer.readToken(Iid3v1Token, offset);
        if (header) {
          debug("ID3v1 header found at: pos=%s", this.tokenizer.fileInfo.size - Iid3v1Token.len);
          for (let id of ["title", "artist", "album", "comment", "track", "year"])
            header[id] && header[id] !== "" && this.addTag(id, header[id]);
          let genre = _ID3v1Parser.getGenre(header.genre);
          genre && this.addTag("genre", genre);
        } else
          debug("ID3v1 header not found at: pos=%s", this.tokenizer.fileInfo.size - Iid3v1Token.len);
      }
      addTag(id, value) {
        this.metadata.addTag("ID3v1", id, value);
      }
    };
    exports2.ID3v1Parser = ID3v1Parser;
    async function hasID3v1Header(reader) {
      if (reader.fileSize >= 128) {
        let tag = Buffer.alloc(3);
        return await reader.randomRead(tag, 0, tag.length, reader.fileSize - 128), tag.toString("binary") === "TAG";
      }
      return !1;
    }
    exports2.hasID3v1Header = hasID3v1Header;
  }
});

// node_modules/music-metadata/lib/id3v2/FrameParser.js
var require_FrameParser = __commonJS({
  "node_modules/music-metadata/lib/id3v2/FrameParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.FrameParser = exports2.parseGenre = void 0;
    var debug_1 = require_browser(), Token2 = require_lib3(), util = require_Util(), ID3v2Token_1 = require_ID3v2Token(), ID3v1Parser_1 = require_ID3v1Parser(), debug = (0, debug_1.default)("music-metadata:id3v2:frame-parser"), defaultEnc = "latin1";
    function parseGenre(origVal) {
      let genres = [], code, word = "";
      for (let c of origVal)
        if (typeof code == "string")
          if (c === "(" && code === "")
            word += "(", code = void 0;
          else if (c === ")") {
            word !== "" && (genres.push(word), word = "");
            let genre = parseGenreCode(code);
            genre && genres.push(genre), code = void 0;
          } else
            code += c;
        else
          c === "(" ? code = "" : word += c;
      return word && (genres.length === 0 && word.match(/^\d*$/) && (word = ID3v1Parser_1.Genres[word]), genres.push(word)), genres;
    }
    exports2.parseGenre = parseGenre;
    function parseGenreCode(code) {
      if (code === "RX")
        return "Remix";
      if (code === "CR")
        return "Cover";
      if (code.match(/^\d*$/))
        return ID3v1Parser_1.Genres[code];
    }
    var FrameParser = class _FrameParser {
      /**
       * Create id3v2 frame parser
       * @param major - Major version, e.g. (4) for  id3v2.4
       * @param warningCollector - Used to collect decode issue
       */
      constructor(major, warningCollector) {
        this.major = major, this.warningCollector = warningCollector;
      }
      readData(uint8Array, type, includeCovers) {
        if (uint8Array.length === 0) {
          this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);
          return;
        }
        let { encoding, bom } = ID3v2Token_1.TextEncodingToken.get(uint8Array, 0), length = uint8Array.length, offset = 0, output = [], nullTerminatorLength = _FrameParser.getNullTerminatorLength(encoding), fzero, out = {};
        switch (debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`), type !== "TXXX" && type[0] === "T" ? "T*" : type) {
          case "T*":
          case "IPLS":
          case "MVIN":
          case "MVNM":
          case "PCS":
          case "PCST":
            let text;
            try {
              text = util.decodeString(uint8Array.slice(1), encoding).replace(/\x00+$/, "");
            } catch (error) {
              this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);
            }
            switch (type) {
              case "TMCL":
              case "TIPL":
              case "IPLS":
                output = this.splitValue(type, text), output = _FrameParser.functionList(output);
                break;
              case "TRK":
              case "TRCK":
              case "TPOS":
                output = text;
                break;
              case "TCOM":
              case "TEXT":
              case "TOLY":
              case "TOPE":
              case "TPE1":
              case "TSRC":
                output = this.splitValue(type, text);
                break;
              case "TCO":
              case "TCON":
                output = this.splitValue(type, text).map((v) => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);
                break;
              case "PCS":
              case "PCST":
                output = this.major >= 4 ? this.splitValue(type, text) : [text], output = Array.isArray(output) && output[0] === "" ? 1 : 0;
                break;
              default:
                output = this.major >= 4 ? this.splitValue(type, text) : [text];
            }
            break;
          case "TXXX":
            output = _FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding), output = {
              description: output.id,
              text: this.splitValue(type, util.decodeString(output.data, encoding).replace(/\x00+$/, ""))
            };
            break;
          case "PIC":
          case "APIC":
            if (includeCovers) {
              let pic = {};
              switch (offset += 1, this.major) {
                case 2:
                  pic.format = util.decodeString(uint8Array.slice(offset, offset + 3), "latin1"), offset += 3;
                  break;
                case 3:
                case 4:
                  fzero = util.findZero(uint8Array, offset, length, defaultEnc), pic.format = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc), offset = fzero + 1;
                  break;
                default:
                  throw new Error("Warning: unexpected major versionIndex: " + this.major);
              }
              pic.format = _FrameParser.fixPictureMimeType(pic.format), pic.type = ID3v2Token_1.AttachedPictureType[uint8Array[offset]], offset += 1, fzero = util.findZero(uint8Array, offset, length, encoding), pic.description = util.decodeString(uint8Array.slice(offset, fzero), encoding), offset = fzero + nullTerminatorLength, pic.data = Buffer.from(uint8Array.slice(offset, length)), output = pic;
            }
            break;
          case "CNT":
          case "PCNT":
            output = Token2.UINT32_BE.get(uint8Array, 0);
            break;
          case "SYLT":
            for (offset += 7, output = []; offset < length; ) {
              let txt = uint8Array.slice(offset, offset = util.findZero(uint8Array, offset, length, encoding));
              offset += 5, output.push(util.decodeString(txt, encoding));
            }
            break;
          case "ULT":
          case "USLT":
          case "COM":
          case "COMM":
            offset += 1, out.language = util.decodeString(uint8Array.slice(offset, offset + 3), defaultEnc), offset += 3, fzero = util.findZero(uint8Array, offset, length, encoding), out.description = util.decodeString(uint8Array.slice(offset, fzero), encoding), offset = fzero + nullTerminatorLength, out.text = util.decodeString(uint8Array.slice(offset, length), encoding).replace(/\x00+$/, ""), output = [out];
            break;
          case "UFID":
            output = _FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc), output = { owner_identifier: output.id, identifier: output.data };
            break;
          case "PRIV":
            output = _FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc), output = { owner_identifier: output.id, data: output.data };
            break;
          case "POPM":
            fzero = util.findZero(uint8Array, offset, length, defaultEnc);
            let email = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
            offset = fzero + 1;
            let dataLen = length - offset;
            output = {
              email,
              rating: Token2.UINT8.get(uint8Array, offset),
              counter: dataLen >= 5 ? Token2.UINT32_BE.get(uint8Array, offset + 1) : void 0
            };
            break;
          case "GEOB": {
            fzero = util.findZero(uint8Array, offset + 1, length, encoding);
            let mimeType = util.decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);
            offset = fzero + 1, fzero = util.findZero(uint8Array, offset, length - offset, encoding);
            let filename = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
            offset = fzero + 1, fzero = util.findZero(uint8Array, offset, length - offset, encoding);
            let description = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
            output = {
              type: mimeType,
              filename,
              description,
              data: uint8Array.slice(offset + 1, length)
            };
            break;
          }
          case "WCOM":
          case "WCOP":
          case "WOAF":
          case "WOAR":
          case "WOAS":
          case "WORS":
          case "WPAY":
          case "WPUB":
            output = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);
            break;
          case "WXXX": {
            fzero = util.findZero(uint8Array, offset + 1, length, encoding);
            let description = util.decodeString(uint8Array.slice(offset + 1, fzero), encoding);
            offset = fzero + (encoding === "utf16le" ? 2 : 1), output = { description, url: util.decodeString(uint8Array.slice(offset, length), defaultEnc) };
            break;
          }
          case "WFD":
          case "WFED":
            output = util.decodeString(uint8Array.slice(offset + 1, util.findZero(uint8Array, offset + 1, length, encoding)), encoding);
            break;
          case "MCDI": {
            output = uint8Array.slice(0, length);
            break;
          }
          default:
            debug("Warning: unsupported id3v2-tag-type: " + type);
            break;
        }
        return output;
      }
      static fixPictureMimeType(pictureType) {
        switch (pictureType = pictureType.toLocaleLowerCase(), pictureType) {
          case "jpg":
            return "image/jpeg";
          case "png":
            return "image/png";
        }
        return pictureType;
      }
      /**
       * Converts TMCL (Musician credits list) or TIPL (Involved people list)
       * @param entries
       */
      static functionList(entries) {
        let res = {};
        for (let i = 0; i + 1 < entries.length; i += 2) {
          let names = entries[i + 1].split(",");
          res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;
        }
        return res;
      }
      /**
       * id3v2.4 defines that multiple T* values are separated by 0x00
       * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
       * @param tag - Tag name
       * @param text - Concatenated tag value
       * @returns Split tag value
       */
      splitValue(tag, text) {
        let values;
        return this.major < 4 ? (values = text.split(/\x00/g), values.length > 1 ? this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`) : values = text.split(/\//g)) : values = text.split(/\x00/g), _FrameParser.trimArray(values);
      }
      static trimArray(values) {
        return values.map((value) => value.replace(/\x00+$/, "").trim());
      }
      static readIdentifierAndData(uint8Array, offset, length, encoding) {
        let fzero = util.findZero(uint8Array, offset, length, encoding), id = util.decodeString(uint8Array.slice(offset, fzero), encoding);
        return offset = fzero + _FrameParser.getNullTerminatorLength(encoding), { id, data: uint8Array.slice(offset, length) };
      }
      static getNullTerminatorLength(enc) {
        return enc === "utf16le" ? 2 : 1;
      }
    };
    exports2.FrameParser = FrameParser;
  }
});

// node_modules/music-metadata/lib/id3v2/ID3v2Parser.js
var require_ID3v2Parser = __commonJS({
  "node_modules/music-metadata/lib/id3v2/ID3v2Parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ID3v2Parser = void 0;
    var Token2 = require_lib3(), util = require_Util(), FrameParser_1 = require_FrameParser(), ID3v2Token_1 = require_ID3v2Token(), ID3v2Parser = class _ID3v2Parser {
      static removeUnsyncBytes(buffer) {
        let readI = 0, writeI = 0;
        for (; readI < buffer.length - 1; )
          readI !== writeI && (buffer[writeI] = buffer[readI]), readI += buffer[readI] === 255 && buffer[readI + 1] === 0 ? 2 : 1, writeI++;
        return readI < buffer.length && (buffer[writeI++] = buffer[readI]), buffer.slice(0, writeI);
      }
      static getFrameHeaderLength(majorVer) {
        switch (majorVer) {
          case 2:
            return 6;
          case 3:
          case 4:
            return 10;
          default:
            throw new Error("header versionIndex is incorrect");
        }
      }
      static readFrameFlags(b) {
        return {
          status: {
            tag_alter_preservation: util.getBit(b, 0, 6),
            file_alter_preservation: util.getBit(b, 0, 5),
            read_only: util.getBit(b, 0, 4)
          },
          format: {
            grouping_identity: util.getBit(b, 1, 7),
            compression: util.getBit(b, 1, 3),
            encryption: util.getBit(b, 1, 2),
            unsynchronisation: util.getBit(b, 1, 1),
            data_length_indicator: util.getBit(b, 1, 0)
          }
        };
      }
      static readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {
        let frameParser = new FrameParser_1.FrameParser(majorVer, warningCollector);
        switch (majorVer) {
          case 2:
            return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
          case 3:
          case 4:
            return frameHeader.flags.format.unsynchronisation && (uint8Array = _ID3v2Parser.removeUnsyncBytes(uint8Array)), frameHeader.flags.format.data_length_indicator && (uint8Array = uint8Array.slice(4, uint8Array.length)), frameParser.readData(uint8Array, frameHeader.id, includeCovers);
          default:
            throw new Error("Unexpected majorVer: " + majorVer);
        }
      }
      /**
       * Create a combined tag key, of tag & description
       * @param tag e.g.: COM
       * @param description e.g. iTunPGAP
       * @returns string e.g. COM:iTunPGAP
       */
      static makeDescriptionTagName(tag, description) {
        return tag + (description ? ":" + description : "");
      }
      async parse(metadata, tokenizer, options) {
        this.tokenizer = tokenizer, this.metadata = metadata, this.options = options;
        let id3Header = await this.tokenizer.readToken(ID3v2Token_1.ID3v2Header);
        if (id3Header.fileIdentifier !== "ID3")
          throw new Error("expected ID3-header file-identifier 'ID3' was not found");
        return this.id3Header = id3Header, this.headerType = "ID3v2." + id3Header.version.major, id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size);
      }
      async parseExtendedHeader() {
        let extendedHeader = await this.tokenizer.readToken(ID3v2Token_1.ExtendedHeader), dataRemaining = extendedHeader.size - ID3v2Token_1.ExtendedHeader.len;
        return dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size);
      }
      async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {
        return await this.tokenizer.ignore(dataRemaining), this.parseId3Data(this.id3Header.size - extendedHeaderSize);
      }
      async parseId3Data(dataLen) {
        let uint8Array = await this.tokenizer.readToken(new Token2.Uint8ArrayType(dataLen));
        for (let tag of this.parseMetadata(uint8Array))
          if (tag.id === "TXXX") {
            if (tag.value)
              for (let text of tag.value.text)
                this.addTag(_ID3v2Parser.makeDescriptionTagName(tag.id, tag.value.description), text);
          } else if (tag.id === "COM")
            for (let value of tag.value)
              this.addTag(_ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value.text);
          else if (tag.id === "COMM")
            for (let value of tag.value)
              this.addTag(_ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value);
          else if (Array.isArray(tag.value))
            for (let value of tag.value)
              this.addTag(tag.id, value);
          else
            this.addTag(tag.id, tag.value);
      }
      addTag(id, value) {
        this.metadata.addTag(this.headerType, id, value);
      }
      parseMetadata(data) {
        let offset = 0, tags = [];
        for (; offset !== data.length; ) {
          let frameHeaderLength = _ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
          if (offset + frameHeaderLength > data.length) {
            this.metadata.addWarning("Illegal ID3v2 tag length");
            break;
          }
          let frameHeaderBytes = data.slice(offset, offset += frameHeaderLength), frameHeader = this.readFrameHeader(frameHeaderBytes, this.id3Header.version.major), frameDataBytes = data.slice(offset, offset += frameHeader.length), values = _ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
          values && tags.push({ id: frameHeader.id, value: values });
        }
        return tags;
      }
      readFrameHeader(uint8Array, majorVer) {
        let header;
        switch (majorVer) {
          case 2:
            header = {
              id: Buffer.from(uint8Array.slice(0, 3)).toString("ascii"),
              length: Token2.UINT24_BE.get(uint8Array, 3)
            }, header.id.match(/[A-Z0-9]{3}/g) || this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
            break;
          case 3:
          case 4:
            header = {
              id: Buffer.from(uint8Array.slice(0, 4)).toString("ascii"),
              length: (majorVer === 4 ? ID3v2Token_1.UINT32SYNCSAFE : Token2.UINT32_BE).get(uint8Array, 4),
              flags: _ID3v2Parser.readFrameFlags(uint8Array.slice(8, 10))
            }, header.id.match(/[A-Z0-9]{4}/g) || this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
            break;
          default:
            throw new Error("Unexpected majorVer: " + majorVer);
        }
        return header;
      }
    };
    exports2.ID3v2Parser = ID3v2Parser;
  }
});

// node_modules/music-metadata/lib/aiff/AiffToken.js
var require_AiffToken = __commonJS({
  "node_modules/music-metadata/lib/aiff/AiffToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Common = void 0;
    var Token2 = require_lib3(), FourCC_1 = require_FourCC(), Common = class {
      constructor(header, isAifc) {
        this.isAifc = isAifc;
        let minimumChunkSize = isAifc ? 22 : 18;
        if (header.chunkSize < minimumChunkSize)
          throw new Error(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);
        this.len = header.chunkSize;
      }
      get(buf, off) {
        let shift = buf.readUInt16BE(off + 8) - 16398, baseSampleRate = buf.readUInt16BE(off + 8 + 2), res = {
          numChannels: buf.readUInt16BE(off),
          numSampleFrames: buf.readUInt32BE(off + 2),
          sampleSize: buf.readUInt16BE(off + 6),
          sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift
        };
        if (this.isAifc) {
          if (res.compressionType = FourCC_1.FourCcToken.get(buf, off + 18), this.len > 22) {
            let strLen = buf.readInt8(off + 22);
            if (strLen > 0) {
              let padding = (strLen + 1) % 2;
              if (23 + strLen + padding === this.len)
                res.compressionName = new Token2.StringType(strLen, "binary").get(buf, off + 23);
              else
                throw new Error("Illegal pstring length");
            } else
              res.compressionName = void 0;
          }
        } else
          res.compressionName = "PCM";
        return res;
      }
    };
    exports2.Common = Common;
  }
});

// node_modules/music-metadata/lib/iff/index.js
var require_iff = __commonJS({
  "node_modules/music-metadata/lib/iff/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Header = void 0;
    var Token2 = require_lib3(), FourCC_1 = require_FourCC();
    exports2.Header = {
      len: 8,
      get: (buf, off) => ({
        // Chunk type ID
        chunkID: FourCC_1.FourCcToken.get(buf, off),
        // Chunk size
        chunkSize: Number(BigInt(Token2.UINT32_BE.get(buf, off + 4)))
      })
    };
  }
});

// node_modules/music-metadata/lib/aiff/AiffParser.js
var require_AiffParser = __commonJS({
  "node_modules/music-metadata/lib/aiff/AiffParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AIFFParser = void 0;
    var Token2 = require_lib3(), debug_1 = require_browser(), strtok32 = require_core(), ID3v2Parser_1 = require_ID3v2Parser(), FourCC_1 = require_FourCC(), BasicParser_1 = require_BasicParser(), AiffToken = require_AiffToken(), iff = require_iff(), debug = (0, debug_1.default)("music-metadata:parser:aiff"), compressionTypes = {
      NONE: "not compressed	PCM	Apple Computer",
      sowt: "PCM (byte swapped)",
      fl32: "32-bit floating point IEEE 32-bit float",
      fl64: "64-bit floating point IEEE 64-bit float	Apple Computer",
      alaw: "ALaw 2:1	8-bit ITU-T G.711 A-law",
      ulaw: "\xB5Law 2:1	8-bit ITU-T G.711 \xB5-law	Apple Computer",
      ULAW: "CCITT G.711 u-law 8-bit ITU-T G.711 \xB5-law",
      ALAW: "CCITT G.711 A-law 8-bit ITU-T G.711 A-law",
      FL32: "Float 32	IEEE 32-bit float "
    }, AIFFParser = class extends BasicParser_1.BasicParser {
      async parse() {
        if ((await this.tokenizer.readToken(iff.Header)).chunkID !== "FORM")
          throw new Error("Invalid Chunk-ID, expected 'FORM'");
        let type = await this.tokenizer.readToken(FourCC_1.FourCcToken);
        switch (type) {
          case "AIFF":
            this.metadata.setFormat("container", type), this.isCompressed = !1;
            break;
          case "AIFC":
            this.metadata.setFormat("container", "AIFF-C"), this.isCompressed = !0;
            break;
          default:
            throw Error("Unsupported AIFF type: " + type);
        }
        this.metadata.setFormat("lossless", !this.isCompressed);
        try {
          for (; !this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len; ) {
            debug("Reading AIFF chunk at offset=" + this.tokenizer.position);
            let chunkHeader = await this.tokenizer.readToken(iff.Header), nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2), bytesRead = await this.readData(chunkHeader);
            await this.tokenizer.ignore(nextChunk - bytesRead);
          }
        } catch (err) {
          if (err instanceof strtok32.EndOfStreamError)
            debug("End-of-stream");
          else
            throw err;
        }
      }
      async readData(header) {
        var _a;
        switch (header.chunkID) {
          case "COMM":
            let common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));
            return this.metadata.setFormat("bitsPerSample", common.sampleSize), this.metadata.setFormat("sampleRate", common.sampleRate), this.metadata.setFormat("numberOfChannels", common.numChannels), this.metadata.setFormat("numberOfSamples", common.numSampleFrames), this.metadata.setFormat("duration", common.numSampleFrames / common.sampleRate), this.metadata.setFormat("codec", (_a = common.compressionName) !== null && _a !== void 0 ? _a : compressionTypes[common.compressionType]), header.chunkSize;
          case "ID3 ":
            let id3_data = await this.tokenizer.readToken(new Token2.Uint8ArrayType(header.chunkSize)), rst = strtok32.fromBuffer(id3_data);
            return await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options), header.chunkSize;
          case "SSND":
            return this.metadata.format.duration && this.metadata.setFormat("bitrate", 8 * header.chunkSize / this.metadata.format.duration), 0;
          case "NAME":
          case "AUTH":
          case "(c) ":
          case "ANNO":
            return this.readTextChunk(header);
          default:
            return debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`), 0;
        }
      }
      async readTextChunk(header) {
        return (await this.tokenizer.readToken(new Token2.StringType(header.chunkSize, "ascii"))).split("\0").map((v) => v.trim()).filter((v) => v && v.length > 0).forEach((v) => {
          this.metadata.addTag("AIFF", header.chunkID, v.trim());
        }), header.chunkSize;
      }
    };
    exports2.AIFFParser = AIFFParser;
  }
});

// node_modules/music-metadata/lib/asf/GUID.js
var require_GUID = __commonJS({
  "node_modules/music-metadata/lib/asf/GUID.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var GUID = class _GUID {
      static fromBin(bin, offset = 0) {
        return new _GUID(this.decode(bin, offset));
      }
      /**
       * Decode GUID in format like "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
       * @param objectId Binary GUID
       * @param offset Read offset in bytes, default 0
       * @returns GUID as dashed hexadecimal representation
       */
      static decode(objectId, offset = 0) {
        return (objectId.readUInt32LE(offset).toString(16) + "-" + objectId.readUInt16LE(offset + 4).toString(16) + "-" + objectId.readUInt16LE(offset + 6).toString(16) + "-" + objectId.readUInt16BE(offset + 8).toString(16) + "-" + objectId.slice(offset + 10, offset + 16).toString("hex")).toUpperCase();
      }
      /**
       * Decode stream type
       * @param mediaType Media type GUID
       * @returns Media type
       */
      static decodeMediaType(mediaType) {
        switch (mediaType.str) {
          case _GUID.AudioMedia.str:
            return "audio";
          case _GUID.VideoMedia.str:
            return "video";
          case _GUID.CommandMedia.str:
            return "command";
          case _GUID.Degradable_JPEG_Media.str:
            return "degradable-jpeg";
          case _GUID.FileTransferMedia.str:
            return "file-transfer";
          case _GUID.BinaryMedia.str:
            return "binary";
        }
      }
      /**
       * Encode GUID
       * @param guid GUID like: "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
       * @returns Encoded Binary GUID
       */
      static encode(str) {
        let bin = Buffer.alloc(16);
        return bin.writeUInt32LE(parseInt(str.slice(0, 8), 16), 0), bin.writeUInt16LE(parseInt(str.slice(9, 13), 16), 4), bin.writeUInt16LE(parseInt(str.slice(14, 18), 16), 6), Buffer.from(str.slice(19, 23), "hex").copy(bin, 8), Buffer.from(str.slice(24), "hex").copy(bin, 10), bin;
      }
      constructor(str) {
        this.str = str;
      }
      equals(guid) {
        return this.str === guid.str;
      }
      toBin() {
        return _GUID.encode(this.str);
      }
    };
    GUID.HeaderObject = new GUID("75B22630-668E-11CF-A6D9-00AA0062CE6C");
    GUID.DataObject = new GUID("75B22636-668E-11CF-A6D9-00AA0062CE6C");
    GUID.SimpleIndexObject = new GUID("33000890-E5B1-11CF-89F4-00A0C90349CB");
    GUID.IndexObject = new GUID("D6E229D3-35DA-11D1-9034-00A0C90349BE");
    GUID.MediaObjectIndexObject = new GUID("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C");
    GUID.TimecodeIndexObject = new GUID("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C");
    GUID.FilePropertiesObject = new GUID("8CABDCA1-A947-11CF-8EE4-00C00C205365");
    GUID.StreamPropertiesObject = new GUID("B7DC0791-A9B7-11CF-8EE6-00C00C205365");
    GUID.HeaderExtensionObject = new GUID("5FBF03B5-A92E-11CF-8EE3-00C00C205365");
    GUID.CodecListObject = new GUID("86D15240-311D-11D0-A3A4-00A0C90348F6");
    GUID.ScriptCommandObject = new GUID("1EFB1A30-0B62-11D0-A39B-00A0C90348F6");
    GUID.MarkerObject = new GUID("F487CD01-A951-11CF-8EE6-00C00C205365");
    GUID.BitrateMutualExclusionObject = new GUID("D6E229DC-35DA-11D1-9034-00A0C90349BE");
    GUID.ErrorCorrectionObject = new GUID("75B22635-668E-11CF-A6D9-00AA0062CE6C");
    GUID.ContentDescriptionObject = new GUID("75B22633-668E-11CF-A6D9-00AA0062CE6C");
    GUID.ExtendedContentDescriptionObject = new GUID("D2D0A440-E307-11D2-97F0-00A0C95EA850");
    GUID.ContentBrandingObject = new GUID("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E");
    GUID.StreamBitratePropertiesObject = new GUID("7BF875CE-468D-11D1-8D82-006097C9A2B2");
    GUID.ContentEncryptionObject = new GUID("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E");
    GUID.ExtendedContentEncryptionObject = new GUID("298AE614-2622-4C17-B935-DAE07EE9289C");
    GUID.DigitalSignatureObject = new GUID("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E");
    GUID.PaddingObject = new GUID("1806D474-CADF-4509-A4BA-9AABCB96AAE8");
    GUID.ExtendedStreamPropertiesObject = new GUID("14E6A5CB-C672-4332-8399-A96952065B5A");
    GUID.AdvancedMutualExclusionObject = new GUID("A08649CF-4775-4670-8A16-6E35357566CD");
    GUID.GroupMutualExclusionObject = new GUID("D1465A40-5A79-4338-B71B-E36B8FD6C249");
    GUID.StreamPrioritizationObject = new GUID("D4FED15B-88D3-454F-81F0-ED5C45999E24");
    GUID.BandwidthSharingObject = new GUID("A69609E6-517B-11D2-B6AF-00C04FD908E9");
    GUID.LanguageListObject = new GUID("7C4346A9-EFE0-4BFC-B229-393EDE415C85");
    GUID.MetadataObject = new GUID("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA");
    GUID.MetadataLibraryObject = new GUID("44231C94-9498-49D1-A141-1D134E457054");
    GUID.IndexParametersObject = new GUID("D6E229DF-35DA-11D1-9034-00A0C90349BE");
    GUID.MediaObjectIndexParametersObject = new GUID("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7");
    GUID.TimecodeIndexParametersObject = new GUID("F55E496D-9797-4B5D-8C8B-604DFE9BFB24");
    GUID.CompatibilityObject = new GUID("26F18B5D-4584-47EC-9F5F-0E651F0452C9");
    GUID.AdvancedContentEncryptionObject = new GUID("43058533-6981-49E6-9B74-AD12CB86D58C");
    GUID.AudioMedia = new GUID("F8699E40-5B4D-11CF-A8FD-00805F5C442B");
    GUID.VideoMedia = new GUID("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B");
    GUID.CommandMedia = new GUID("59DACFC0-59E6-11D0-A3AC-00A0C90348F6");
    GUID.JFIF_Media = new GUID("B61BE100-5B4E-11CF-A8FD-00805F5C442B");
    GUID.Degradable_JPEG_Media = new GUID("35907DE0-E415-11CF-A917-00805F5C442B");
    GUID.FileTransferMedia = new GUID("91BD222C-F21C-497A-8B6D-5AA86BFC0185");
    GUID.BinaryMedia = new GUID("3AFB65E2-47EF-40F2-AC2C-70A90D71D343");
    GUID.ASF_Index_Placeholder_Object = new GUID("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2");
    exports2.default = GUID;
  }
});

// node_modules/music-metadata/lib/asf/AsfUtil.js
var require_AsfUtil = __commonJS({
  "node_modules/music-metadata/lib/asf/AsfUtil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AsfUtil = void 0;
    var Token2 = require_lib3(), util = require_Util(), AsfUtil = class _AsfUtil {
      static getParserForAttr(i) {
        return _AsfUtil.attributeParsers[i];
      }
      static parseUnicodeAttr(uint8Array) {
        return util.stripNulls(util.decodeString(uint8Array, "utf16le"));
      }
      static parseByteArrayAttr(buf) {
        return Buffer.from(buf);
      }
      static parseBoolAttr(buf, offset = 0) {
        return _AsfUtil.parseWordAttr(buf, offset) === 1;
      }
      static parseDWordAttr(buf, offset = 0) {
        return buf.readUInt32LE(offset);
      }
      static parseQWordAttr(buf, offset = 0) {
        return Token2.UINT64_LE.get(buf, offset);
      }
      static parseWordAttr(buf, offset = 0) {
        return buf.readUInt16LE(offset);
      }
    };
    AsfUtil.attributeParsers = [
      AsfUtil.parseUnicodeAttr,
      AsfUtil.parseByteArrayAttr,
      AsfUtil.parseBoolAttr,
      AsfUtil.parseDWordAttr,
      AsfUtil.parseQWordAttr,
      AsfUtil.parseWordAttr,
      AsfUtil.parseByteArrayAttr
    ];
    exports2.AsfUtil = AsfUtil;
  }
});

// node_modules/music-metadata/lib/asf/AsfObject.js
var require_AsfObject = __commonJS({
  "node_modules/music-metadata/lib/asf/AsfObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.WmPictureToken = exports2.MetadataLibraryObjectState = exports2.MetadataObjectState = exports2.ExtendedStreamPropertiesObjectState = exports2.ExtendedContentDescriptionObjectState = exports2.ContentDescriptionObjectState = exports2.readCodecEntries = exports2.HeaderExtensionObject = exports2.StreamPropertiesObject = exports2.FilePropertiesObject = exports2.IgnoreObjectState = exports2.State = exports2.HeaderObjectToken = exports2.TopLevelHeaderObjectToken = exports2.DataType = void 0;
    var util = require_Util(), Token2 = require_lib3(), GUID_1 = require_GUID(), AsfUtil_1 = require_AsfUtil(), ID3v2Token_1 = require_ID3v2Token(), DataType;
    (function(DataType2) {
      DataType2[DataType2.UnicodeString = 0] = "UnicodeString", DataType2[DataType2.ByteArray = 1] = "ByteArray", DataType2[DataType2.Bool = 2] = "Bool", DataType2[DataType2.DWord = 3] = "DWord", DataType2[DataType2.QWord = 4] = "QWord", DataType2[DataType2.Word = 5] = "Word";
    })(DataType = exports2.DataType || (exports2.DataType = {}));
    exports2.TopLevelHeaderObjectToken = {
      len: 30,
      get: (buf, off) => ({
        objectId: GUID_1.default.fromBin(new Token2.BufferType(16).get(buf, off)),
        objectSize: Number(Token2.UINT64_LE.get(buf, off + 16)),
        numberOfHeaderObjects: Token2.UINT32_LE.get(buf, off + 24)
        // Reserved: 2 bytes
      })
    };
    exports2.HeaderObjectToken = {
      len: 24,
      get: (buf, off) => ({
        objectId: GUID_1.default.fromBin(new Token2.BufferType(16).get(buf, off)),
        objectSize: Number(Token2.UINT64_LE.get(buf, off + 16))
      })
    };
    var State = class {
      constructor(header) {
        this.len = Number(header.objectSize) - exports2.HeaderObjectToken.len;
      }
      postProcessTag(tags, name, valueType, data) {
        if (name === "WM/Picture")
          tags.push({ id: name, value: WmPictureToken.fromBuffer(data) });
        else {
          let parseAttr = AsfUtil_1.AsfUtil.getParserForAttr(valueType);
          if (!parseAttr)
            throw new Error("unexpected value headerType: " + valueType);
          tags.push({ id: name, value: parseAttr(data) });
        }
      }
    };
    exports2.State = State;
    var IgnoreObjectState = class extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        return null;
      }
    };
    exports2.IgnoreObjectState = IgnoreObjectState;
    var FilePropertiesObject = class extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        return {
          fileId: GUID_1.default.fromBin(buf, off),
          fileSize: Token2.UINT64_LE.get(buf, off + 16),
          creationDate: Token2.UINT64_LE.get(buf, off + 24),
          dataPacketsCount: Token2.UINT64_LE.get(buf, off + 32),
          playDuration: Token2.UINT64_LE.get(buf, off + 40),
          sendDuration: Token2.UINT64_LE.get(buf, off + 48),
          preroll: Token2.UINT64_LE.get(buf, off + 56),
          flags: {
            broadcast: util.getBit(buf, off + 64, 24),
            seekable: util.getBit(buf, off + 64, 25)
          },
          // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
          minimumDataPacketSize: Token2.UINT32_LE.get(buf, off + 68),
          maximumDataPacketSize: Token2.UINT32_LE.get(buf, off + 72),
          maximumBitrate: Token2.UINT32_LE.get(buf, off + 76)
        };
      }
    };
    FilePropertiesObject.guid = GUID_1.default.FilePropertiesObject;
    exports2.FilePropertiesObject = FilePropertiesObject;
    var StreamPropertiesObject = class extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        return {
          streamType: GUID_1.default.decodeMediaType(GUID_1.default.fromBin(buf, off)),
          errorCorrectionType: GUID_1.default.fromBin(buf, off + 8)
          // ToDo
        };
      }
    };
    StreamPropertiesObject.guid = GUID_1.default.StreamPropertiesObject;
    exports2.StreamPropertiesObject = StreamPropertiesObject;
    var HeaderExtensionObject = class {
      constructor() {
        this.len = 22;
      }
      get(buf, off) {
        return {
          reserved1: GUID_1.default.fromBin(buf, off),
          reserved2: buf.readUInt16LE(off + 16),
          extensionDataSize: buf.readUInt32LE(off + 18)
        };
      }
    };
    HeaderExtensionObject.guid = GUID_1.default.HeaderExtensionObject;
    exports2.HeaderExtensionObject = HeaderExtensionObject;
    var CodecListObjectHeader = {
      len: 20,
      get: (buf, off) => ({
        entryCount: buf.readUInt16LE(off + 16)
      })
    };
    async function readString(tokenizer) {
      let length = await tokenizer.readNumber(Token2.UINT16_LE);
      return (await tokenizer.readToken(new Token2.StringType(length * 2, "utf16le"))).replace("\0", "");
    }
    async function readCodecEntries(tokenizer) {
      let codecHeader = await tokenizer.readToken(CodecListObjectHeader), entries = [];
      for (let i = 0; i < codecHeader.entryCount; ++i)
        entries.push(await readCodecEntry(tokenizer));
      return entries;
    }
    exports2.readCodecEntries = readCodecEntries;
    async function readInformation(tokenizer) {
      let length = await tokenizer.readNumber(Token2.UINT16_LE), buf = Buffer.alloc(length);
      return await tokenizer.readBuffer(buf), buf;
    }
    async function readCodecEntry(tokenizer) {
      let type = await tokenizer.readNumber(Token2.UINT16_LE);
      return {
        type: {
          videoCodec: (type & 1) === 1,
          audioCodec: (type & 2) === 2
        },
        codecName: await readString(tokenizer),
        description: await readString(tokenizer),
        information: await readInformation(tokenizer)
      };
    }
    var ContentDescriptionObjectState = class _ContentDescriptionObjectState extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        let tags = [], pos = off + 10;
        for (let i = 0; i < _ContentDescriptionObjectState.contentDescTags.length; ++i) {
          let length = buf.readUInt16LE(off + i * 2);
          if (length > 0) {
            let tagName = _ContentDescriptionObjectState.contentDescTags[i], end = pos + length;
            tags.push({ id: tagName, value: AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, end)) }), pos = end;
          }
        }
        return tags;
      }
    };
    ContentDescriptionObjectState.guid = GUID_1.default.ContentDescriptionObject;
    ContentDescriptionObjectState.contentDescTags = ["Title", "Author", "Copyright", "Description", "Rating"];
    exports2.ContentDescriptionObjectState = ContentDescriptionObjectState;
    var ExtendedContentDescriptionObjectState = class extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        let tags = [], attrCount = buf.readUInt16LE(off), pos = off + 2;
        for (let i = 0; i < attrCount; i += 1) {
          let nameLen = buf.readUInt16LE(pos);
          pos += 2;
          let name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));
          pos += nameLen;
          let valueType = buf.readUInt16LE(pos);
          pos += 2;
          let valueLen = buf.readUInt16LE(pos);
          pos += 2;
          let value = buf.slice(pos, pos + valueLen);
          pos += valueLen, this.postProcessTag(tags, name, valueType, value);
        }
        return tags;
      }
    };
    ExtendedContentDescriptionObjectState.guid = GUID_1.default.ExtendedContentDescriptionObject;
    exports2.ExtendedContentDescriptionObjectState = ExtendedContentDescriptionObjectState;
    var ExtendedStreamPropertiesObjectState = class extends State {
      constructor(header) {
        super(header);
      }
      get(buf, off) {
        return {
          startTime: Token2.UINT64_LE.get(buf, off),
          endTime: Token2.UINT64_LE.get(buf, off + 8),
          dataBitrate: buf.readInt32LE(off + 12),
          bufferSize: buf.readInt32LE(off + 16),
          initialBufferFullness: buf.readInt32LE(off + 20),
          alternateDataBitrate: buf.readInt32LE(off + 24),
          alternateBufferSize: buf.readInt32LE(off + 28),
          alternateInitialBufferFullness: buf.readInt32LE(off + 32),
          maximumObjectSize: buf.readInt32LE(off + 36),
          flags: {
            reliableFlag: util.getBit(buf, off + 40, 0),
            seekableFlag: util.getBit(buf, off + 40, 1),
            resendLiveCleanpointsFlag: util.getBit(buf, off + 40, 2)
          },
          // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
          streamNumber: buf.readInt16LE(off + 42),
          streamLanguageId: buf.readInt16LE(off + 44),
          averageTimePerFrame: buf.readInt32LE(off + 52),
          streamNameCount: buf.readInt32LE(off + 54),
          payloadExtensionSystems: buf.readInt32LE(off + 56),
          streamNames: [],
          streamPropertiesObject: null
        };
      }
    };
    ExtendedStreamPropertiesObjectState.guid = GUID_1.default.ExtendedStreamPropertiesObject;
    exports2.ExtendedStreamPropertiesObjectState = ExtendedStreamPropertiesObjectState;
    var MetadataObjectState = class extends State {
      constructor(header) {
        super(header);
      }
      get(uint8Array, off) {
        let tags = [], buf = Buffer.from(uint8Array), descriptionRecordsCount = buf.readUInt16LE(off), pos = off + 2;
        for (let i = 0; i < descriptionRecordsCount; i += 1) {
          pos += 4;
          let nameLen = buf.readUInt16LE(pos);
          pos += 2;
          let dataType = buf.readUInt16LE(pos);
          pos += 2;
          let dataLen = buf.readUInt32LE(pos);
          pos += 4;
          let name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));
          pos += nameLen;
          let data = buf.slice(pos, pos + dataLen);
          pos += dataLen, this.postProcessTag(tags, name, dataType, data);
        }
        return tags;
      }
    };
    MetadataObjectState.guid = GUID_1.default.MetadataObject;
    exports2.MetadataObjectState = MetadataObjectState;
    var MetadataLibraryObjectState = class extends MetadataObjectState {
      constructor(header) {
        super(header);
      }
    };
    MetadataLibraryObjectState.guid = GUID_1.default.MetadataLibraryObject;
    exports2.MetadataLibraryObjectState = MetadataLibraryObjectState;
    var WmPictureToken = class _WmPictureToken {
      static fromBase64(base64str) {
        return this.fromBuffer(Buffer.from(base64str, "base64"));
      }
      static fromBuffer(buffer) {
        return new _WmPictureToken(buffer.length).get(buffer, 0);
      }
      constructor(len) {
        this.len = len;
      }
      get(buffer, offset) {
        let typeId = buffer.readUInt8(offset++), size = buffer.readInt32LE(offset), index = 5;
        for (; buffer.readUInt16BE(index) !== 0; )
          index += 2;
        let format = buffer.slice(5, index).toString("utf16le");
        for (; buffer.readUInt16BE(index) !== 0; )
          index += 2;
        let description = buffer.slice(5, index).toString("utf16le");
        return {
          type: ID3v2Token_1.AttachedPictureType[typeId],
          format,
          description,
          size,
          data: buffer.slice(index + 4)
        };
      }
    };
    exports2.WmPictureToken = WmPictureToken;
  }
});

// node_modules/music-metadata/lib/asf/AsfParser.js
var require_AsfParser = __commonJS({
  "node_modules/music-metadata/lib/asf/AsfParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AsfParser = void 0;
    var debug_1 = require_browser(), type_1 = require_type(), GUID_1 = require_GUID(), AsfObject = require_AsfObject(), BasicParser_1 = require_BasicParser(), debug = (0, debug_1.default)("music-metadata:parser:ASF"), headerType = "asf", AsfParser = class extends BasicParser_1.BasicParser {
      async parse() {
        let header = await this.tokenizer.readToken(AsfObject.TopLevelHeaderObjectToken);
        if (!header.objectId.equals(GUID_1.default.HeaderObject))
          throw new Error("expected asf header; but was not found; got: " + header.objectId.str);
        try {
          await this.parseObjectHeader(header.numberOfHeaderObjects);
        } catch (err) {
          debug("Error while parsing ASF: %s", err);
        }
      }
      async parseObjectHeader(numberOfObjectHeaders) {
        let tags;
        do {
          let header = await this.tokenizer.readToken(AsfObject.HeaderObjectToken);
          switch (debug("header GUID=%s", header.objectId.str), header.objectId.str) {
            case AsfObject.FilePropertiesObject.guid.str:
              let fpo = await this.tokenizer.readToken(new AsfObject.FilePropertiesObject(header));
              this.metadata.setFormat("duration", Number(fpo.playDuration / BigInt(1e3)) / 1e4 - Number(fpo.preroll) / 1e3), this.metadata.setFormat("bitrate", fpo.maximumBitrate);
              break;
            case AsfObject.StreamPropertiesObject.guid.str:
              let spo = await this.tokenizer.readToken(new AsfObject.StreamPropertiesObject(header));
              this.metadata.setFormat("container", "ASF/" + spo.streamType);
              break;
            case AsfObject.HeaderExtensionObject.guid.str:
              let extHeader = await this.tokenizer.readToken(new AsfObject.HeaderExtensionObject());
              await this.parseExtensionObject(extHeader.extensionDataSize);
              break;
            case AsfObject.ContentDescriptionObjectState.guid.str:
              tags = await this.tokenizer.readToken(new AsfObject.ContentDescriptionObjectState(header)), this.addTags(tags);
              break;
            case AsfObject.ExtendedContentDescriptionObjectState.guid.str:
              tags = await this.tokenizer.readToken(new AsfObject.ExtendedContentDescriptionObjectState(header)), this.addTags(tags);
              break;
            case GUID_1.default.CodecListObject.str:
              let codecs = await AsfObject.readCodecEntries(this.tokenizer);
              codecs.forEach((codec) => {
                this.metadata.addStreamInfo({
                  type: codec.type.videoCodec ? type_1.TrackType.video : type_1.TrackType.audio,
                  codecName: codec.codecName
                });
              });
              let audioCodecs = codecs.filter((codec) => codec.type.audioCodec).map((codec) => codec.codecName).join("/");
              this.metadata.setFormat("codec", audioCodecs);
              break;
            case GUID_1.default.StreamBitratePropertiesObject.str:
              await this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
              break;
            case GUID_1.default.PaddingObject.str:
              debug("Padding: %s bytes", header.objectSize - AsfObject.HeaderObjectToken.len), await this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
              break;
            default:
              this.metadata.addWarning("Ignore ASF-Object-GUID: " + header.objectId.str), debug("Ignore ASF-Object-GUID: %s", header.objectId.str), await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));
          }
        } while (--numberOfObjectHeaders);
      }
      addTags(tags) {
        tags.forEach((tag) => {
          this.metadata.addTag(headerType, tag.id, tag.value);
        });
      }
      async parseExtensionObject(extensionSize) {
        do {
          let header = await this.tokenizer.readToken(AsfObject.HeaderObjectToken), remaining = header.objectSize - AsfObject.HeaderObjectToken.len;
          switch (header.objectId.str) {
            case AsfObject.ExtendedStreamPropertiesObjectState.guid.str:
              await this.tokenizer.readToken(new AsfObject.ExtendedStreamPropertiesObjectState(header));
              break;
            case AsfObject.MetadataObjectState.guid.str:
              let moTags = await this.tokenizer.readToken(new AsfObject.MetadataObjectState(header));
              this.addTags(moTags);
              break;
            case AsfObject.MetadataLibraryObjectState.guid.str:
              let mlTags = await this.tokenizer.readToken(new AsfObject.MetadataLibraryObjectState(header));
              this.addTags(mlTags);
              break;
            case GUID_1.default.PaddingObject.str:
              await this.tokenizer.ignore(remaining);
              break;
            case GUID_1.default.CompatibilityObject.str:
              this.tokenizer.ignore(remaining);
              break;
            case GUID_1.default.ASF_Index_Placeholder_Object.str:
              await this.tokenizer.ignore(remaining);
              break;
            default:
              this.metadata.addWarning("Ignore ASF-Object-GUID: " + header.objectId.str), await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));
              break;
          }
          extensionSize -= header.objectSize;
        } while (extensionSize > 0);
      }
    };
    exports2.AsfParser = AsfParser;
  }
});

// node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js
var require_Vorbis = __commonJS({
  "node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.IdentificationHeader = exports2.CommonHeader = exports2.VorbisPictureToken = void 0;
    var Token2 = require_lib3(), ID3v2Token_1 = require_ID3v2Token(), VorbisPictureToken = class _VorbisPictureToken {
      static fromBase64(base64str) {
        return this.fromBuffer(Buffer.from(base64str, "base64"));
      }
      static fromBuffer(buffer) {
        return new _VorbisPictureToken(buffer.length).get(buffer, 0);
      }
      constructor(len) {
        this.len = len;
      }
      get(buffer, offset) {
        let type = ID3v2Token_1.AttachedPictureType[Token2.UINT32_BE.get(buffer, offset)], mimeLen = Token2.UINT32_BE.get(buffer, offset += 4), format = buffer.toString("utf-8", offset += 4, offset + mimeLen), descLen = Token2.UINT32_BE.get(buffer, offset += mimeLen), description = buffer.toString("utf-8", offset += 4, offset + descLen), width = Token2.UINT32_BE.get(buffer, offset += descLen), height = Token2.UINT32_BE.get(buffer, offset += 4), colour_depth = Token2.UINT32_BE.get(buffer, offset += 4), indexed_color = Token2.UINT32_BE.get(buffer, offset += 4), picDataLen = Token2.UINT32_BE.get(buffer, offset += 4), data = Buffer.from(buffer.slice(offset += 4, offset + picDataLen));
        return {
          type,
          format,
          description,
          width,
          height,
          colour_depth,
          indexed_color,
          data
        };
      }
    };
    exports2.VorbisPictureToken = VorbisPictureToken;
    exports2.CommonHeader = {
      len: 7,
      get: (buf, off) => ({
        packetType: buf.readUInt8(off),
        vorbis: new Token2.StringType(6, "ascii").get(buf, off + 1)
      })
    };
    exports2.IdentificationHeader = {
      len: 23,
      get: (uint8Array, off) => {
        let dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset);
        return {
          version: dataView.getUint32(off + 0, !0),
          channelMode: dataView.getUint8(off + 4),
          sampleRate: dataView.getUint32(off + 5, !0),
          bitrateMax: dataView.getUint32(off + 9, !0),
          bitrateNominal: dataView.getUint32(off + 13, !0),
          bitrateMin: dataView.getUint32(off + 17, !0)
        };
      }
    };
  }
});

// node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js
var require_AbstractID3Parser = __commonJS({
  "node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AbstractID3Parser = void 0;
    var core_1 = require_core(), debug_1 = require_browser(), ID3v2Token_1 = require_ID3v2Token(), ID3v2Parser_1 = require_ID3v2Parser(), ID3v1Parser_1 = require_ID3v1Parser(), BasicParser_1 = require_BasicParser(), debug = (0, debug_1.default)("music-metadata:parser:ID3"), AbstractID3Parser = class extends BasicParser_1.BasicParser {
      constructor() {
        super(...arguments), this.id3parser = new ID3v2Parser_1.ID3v2Parser();
      }
      static async startsWithID3v2Header(tokenizer) {
        return (await tokenizer.peekToken(ID3v2Token_1.ID3v2Header)).fileIdentifier === "ID3";
      }
      async parse() {
        try {
          await this.parseID3v2();
        } catch (err) {
          if (err instanceof core_1.EndOfStreamError)
            debug("End-of-stream");
          else
            throw err;
        }
      }
      finalize() {
      }
      async parseID3v2() {
        await this.tryReadId3v2Headers(), debug("End of ID3v2 header, go to MPEG-parser: pos=%s", this.tokenizer.position), await this.postId3v2Parse(), this.options.skipPostHeaders && this.metadata.hasAny() ? this.finalize() : (await new ID3v1Parser_1.ID3v1Parser().init(this.metadata, this.tokenizer, this.options).parse(), this.finalize());
      }
      async tryReadId3v2Headers() {
        if ((await this.tokenizer.peekToken(ID3v2Token_1.ID3v2Header)).fileIdentifier === "ID3")
          return debug("Found ID3v2 header, pos=%s", this.tokenizer.position), await this.id3parser.parse(this.metadata, this.tokenizer, this.options), this.tryReadId3v2Headers();
      }
    };
    exports2.AbstractID3Parser = AbstractID3Parser;
  }
});

// node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js
var require_VorbisDecoder = __commonJS({
  "node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.VorbisDecoder = void 0;
    var Token2 = require_lib3(), VorbisDecoder = class {
      constructor(data, offset) {
        this.data = data, this.offset = offset;
      }
      readInt32() {
        let value = Token2.UINT32_LE.get(this.data, this.offset);
        return this.offset += 4, value;
      }
      readStringUtf8() {
        let len = this.readInt32(), value = Buffer.from(this.data).toString("utf-8", this.offset, this.offset + len);
        return this.offset += len, value;
      }
      parseUserComment() {
        let offset0 = this.offset, v = this.readStringUtf8(), idx = v.indexOf("=");
        return {
          key: v.slice(0, idx).toUpperCase(),
          value: v.slice(idx + 1),
          len: this.offset - offset0
        };
      }
    };
    exports2.VorbisDecoder = VorbisDecoder;
  }
});

// node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js
var require_VorbisParser = __commonJS({
  "node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.VorbisParser = void 0;
    var Token2 = require_lib3(), debug_1 = require_browser(), VorbisDecoder_1 = require_VorbisDecoder(), Vorbis_1 = require_Vorbis(), debug = (0, debug_1.default)("music-metadata:parser:ogg:vorbis1"), VorbisParser = class {
      constructor(metadata, options) {
        this.metadata = metadata, this.options = options, this.pageSegments = [];
      }
      /**
       * Vorbis 1 parser
       * @param header Ogg Page Header
       * @param pageData Page data
       */
      parsePage(header, pageData) {
        if (header.headerType.firstPage)
          this.parseFirstPage(header, pageData);
        else {
          if (header.headerType.continued) {
            if (this.pageSegments.length === 0)
              throw new Error("Cannot continue on previous page");
            this.pageSegments.push(pageData);
          }
          if (header.headerType.lastPage || !header.headerType.continued) {
            if (this.pageSegments.length > 0) {
              let fullPage = Buffer.concat(this.pageSegments);
              this.parseFullPage(fullPage);
            }
            this.pageSegments = header.headerType.lastPage ? [] : [pageData];
          }
        }
        header.headerType.lastPage && this.calculateDuration(header);
      }
      flush() {
        this.parseFullPage(Buffer.concat(this.pageSegments));
      }
      parseUserComment(pageData, offset) {
        let tag = new VorbisDecoder_1.VorbisDecoder(pageData, offset).parseUserComment();
        return this.addTag(tag.key, tag.value), tag.len;
      }
      addTag(id, value) {
        if (id === "METADATA_BLOCK_PICTURE" && typeof value == "string") {
          if (this.options.skipCovers) {
            debug("Ignore picture");
            return;
          }
          value = Vorbis_1.VorbisPictureToken.fromBase64(value), debug(`Push picture: id=${id}, format=${value.format}`);
        } else
          debug(`Push tag: id=${id}, value=${value}`);
        this.metadata.addTag("vorbis", id, value);
      }
      calculateDuration(header) {
        this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0 && (this.metadata.setFormat("numberOfSamples", header.absoluteGranulePosition), this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate));
      }
      /**
       * Parse first Ogg/Vorbis page
       * @param {IPageHeader} header
       * @param {Buffer} pageData
       */
      parseFirstPage(header, pageData) {
        this.metadata.setFormat("codec", "Vorbis I"), debug("Parse first page");
        let commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);
        if (commonHeader.vorbis !== "vorbis")
          throw new Error("Metadata does not look like Vorbis");
        if (commonHeader.packetType === 1) {
          let idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);
          this.metadata.setFormat("sampleRate", idHeader.sampleRate), this.metadata.setFormat("bitrate", idHeader.bitrateNominal), this.metadata.setFormat("numberOfChannels", idHeader.channelMode), debug("sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);
        } else
          throw new Error("First Ogg page should be type 1: the identification header");
      }
      parseFullPage(pageData) {
        let commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);
        switch (debug("Parse full page: type=%s, byteLength=%s", commonHeader.packetType, pageData.byteLength), commonHeader.packetType) {
          case 3:
            return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);
          case 1:
          case 5:
            break;
        }
      }
      /**
       * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2
       */
      parseUserCommentList(pageData, offset) {
        let strLen = Token2.UINT32_LE.get(pageData, offset);
        offset += 4, offset += strLen;
        let userCommentListLength = Token2.UINT32_LE.get(pageData, offset);
        for (offset += 4; userCommentListLength-- > 0; )
          offset += this.parseUserComment(pageData, offset);
      }
    };
    exports2.VorbisParser = VorbisParser;
  }
});

// node_modules/music-metadata/lib/flac/FlacParser.js
var require_FlacParser = __commonJS({
  "node_modules/music-metadata/lib/flac/FlacParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.FlacParser = void 0;
    var token_types_1 = require_lib3(), debug_1 = require_browser(), util = require_Util(), Vorbis_1 = require_Vorbis(), AbstractID3Parser_1 = require_AbstractID3Parser(), FourCC_1 = require_FourCC(), VorbisParser_1 = require_VorbisParser(), VorbisDecoder_1 = require_VorbisDecoder(), debug = (0, debug_1.default)("music-metadata:parser:FLAC"), BlockType;
    (function(BlockType2) {
      BlockType2[BlockType2.STREAMINFO = 0] = "STREAMINFO", BlockType2[BlockType2.PADDING = 1] = "PADDING", BlockType2[BlockType2.APPLICATION = 2] = "APPLICATION", BlockType2[BlockType2.SEEKTABLE = 3] = "SEEKTABLE", BlockType2[BlockType2.VORBIS_COMMENT = 4] = "VORBIS_COMMENT", BlockType2[BlockType2.CUESHEET = 5] = "CUESHEET", BlockType2[BlockType2.PICTURE = 6] = "PICTURE";
    })(BlockType || (BlockType = {}));
    var FlacParser = class extends AbstractID3Parser_1.AbstractID3Parser {
      constructor() {
        super(...arguments), this.padding = 0;
      }
      /**
       * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
       * @param {INativeMetadataCollector} metadata Output
       * @param {ITokenizer} tokenizer Input
       * @param {IOptions} options Parsing options
       */
      init(metadata, tokenizer, options) {
        return super.init(metadata, tokenizer, options), this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options), this;
      }
      async postId3v2Parse() {
        if ((await this.tokenizer.readToken(FourCC_1.FourCcToken)).toString() !== "fLaC")
          throw new Error("Invalid FLAC preamble");
        let blockHeader;
        do
          blockHeader = await this.tokenizer.readToken(Metadata.BlockHeader), await this.parseDataBlock(blockHeader);
        while (!blockHeader.lastBlock);
        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {
          let dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;
          this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
        }
      }
      parseDataBlock(blockHeader) {
        switch (debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`), blockHeader.type) {
          case BlockType.STREAMINFO:
            return this.parseBlockStreamInfo(blockHeader.length);
          case BlockType.PADDING:
            this.padding += blockHeader.length;
            break;
          case BlockType.APPLICATION:
            break;
          case BlockType.SEEKTABLE:
            break;
          case BlockType.VORBIS_COMMENT:
            return this.parseComment(blockHeader.length);
          case BlockType.CUESHEET:
            break;
          case BlockType.PICTURE:
            return this.parsePicture(blockHeader.length).then();
          default:
            this.metadata.addWarning("Unknown block type: " + blockHeader.type);
        }
        return this.tokenizer.ignore(blockHeader.length).then();
      }
      /**
       * Parse STREAMINFO
       */
      async parseBlockStreamInfo(dataLen) {
        if (dataLen !== Metadata.BlockStreamInfo.len)
          throw new Error("Unexpected block-stream-info length");
        let streamInfo = await this.tokenizer.readToken(Metadata.BlockStreamInfo);
        this.metadata.setFormat("container", "FLAC"), this.metadata.setFormat("codec", "FLAC"), this.metadata.setFormat("lossless", !0), this.metadata.setFormat("numberOfChannels", streamInfo.channels), this.metadata.setFormat("bitsPerSample", streamInfo.bitsPerSample), this.metadata.setFormat("sampleRate", streamInfo.sampleRate), streamInfo.totalSamples > 0 && this.metadata.setFormat("duration", streamInfo.totalSamples / streamInfo.sampleRate);
      }
      /**
       * Parse VORBIS_COMMENT
       * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3
       */
      async parseComment(dataLen) {
        let data = await this.tokenizer.readToken(new token_types_1.Uint8ArrayType(dataLen)), decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);
        decoder.readStringUtf8();
        let commentListLength = decoder.readInt32();
        for (let i = 0; i < commentListLength; i++) {
          let tag = decoder.parseUserComment();
          this.vorbisParser.addTag(tag.key, tag.value);
        }
      }
      async parsePicture(dataLen) {
        if (this.options.skipCovers)
          return this.tokenizer.ignore(dataLen);
        {
          let picture = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));
          this.vorbisParser.addTag("METADATA_BLOCK_PICTURE", picture);
        }
      }
    };
    exports2.FlacParser = FlacParser;
    var Metadata = class {
    };
    Metadata.BlockHeader = {
      len: 4,
      get: (buf, off) => ({
        lastBlock: util.getBit(buf, off, 7),
        type: util.getBitAllignedNumber(buf, off, 1, 7),
        length: token_types_1.UINT24_BE.get(buf, off + 1)
      })
    };
    Metadata.BlockStreamInfo = {
      len: 34,
      get: (buf, off) => ({
        // The minimum block size (in samples) used in the stream.
        minimumBlockSize: token_types_1.UINT16_BE.get(buf, off),
        // The maximum block size (in samples) used in the stream.
        // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.
        maximumBlockSize: token_types_1.UINT16_BE.get(buf, off + 2) / 1e3,
        // The minimum frame size (in bytes) used in the stream.
        // May be 0 to imply the value is not known.
        minimumFrameSize: token_types_1.UINT24_BE.get(buf, off + 4),
        // The maximum frame size (in bytes) used in the stream.
        // May be 0 to imply the value is not known.
        maximumFrameSize: token_types_1.UINT24_BE.get(buf, off + 7),
        // Sample rate in Hz. Though 20 bits are available,
        // the maximum sample rate is limited by the structure of frame headers to 655350Hz.
        // Also, a value of 0 is invalid.
        sampleRate: token_types_1.UINT24_BE.get(buf, off + 10) >> 4,
        // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),
        // (number of channels)-1. FLAC supports from 1 to 8 channels
        channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,
        // bits per sample)-1.
        // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.
        bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,
        // Total samples in stream.
        // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.
        // A value of zero here means the number of total samples is unknown.
        totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),
        // the MD5 hash of the file (see notes for usage... it's a littly tricky)
        fileMD5: new token_types_1.Uint8ArrayType(16).get(buf, off + 18)
      })
    };
  }
});

// node_modules/music-metadata/lib/mp4/AtomToken.js
var require_AtomToken = __commonJS({
  "node_modules/music-metadata/lib/mp4/AtomToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ChapterText = exports2.StcoAtom = exports2.StszAtom = exports2.StscAtom = exports2.SampleToChunkToken = exports2.SttsAtom = exports2.TimeToSampleToken = exports2.SoundSampleDescriptionV0 = exports2.SoundSampleDescriptionVersion = exports2.StsdAtom = exports2.TrackHeaderAtom = exports2.NameAtom = exports2.DataAtom = exports2.MvhdAtom = exports2.MdhdAtom = exports2.FixedLengthAtom = exports2.mhdr = exports2.tkhd = exports2.ftyp = exports2.ExtendedSize = exports2.Header = void 0;
    var Token2 = require_lib3(), debug_1 = require_browser(), FourCC_1 = require_FourCC(), debug = (0, debug_1.default)("music-metadata:parser:MP4:atom");
    exports2.Header = {
      len: 8,
      get: (buf, off) => {
        let length = Token2.UINT32_BE.get(buf, off);
        if (length < 0)
          throw new Error("Invalid atom header length");
        return {
          length: BigInt(length),
          name: new Token2.StringType(4, "binary").get(buf, off + 4)
        };
      },
      put: (buf, off, hdr) => (Token2.UINT32_BE.put(buf, off, Number(hdr.length)), FourCC_1.FourCcToken.put(buf, off + 4, hdr.name))
    };
    exports2.ExtendedSize = Token2.UINT64_BE;
    exports2.ftyp = {
      len: 4,
      get: (buf, off) => ({
        type: new Token2.StringType(4, "ascii").get(buf, off)
      })
    };
    exports2.tkhd = {
      len: 4,
      get: (buf, off) => ({
        type: new Token2.StringType(4, "ascii").get(buf, off)
      })
    };
    exports2.mhdr = {
      len: 8,
      get: (buf, off) => ({
        version: Token2.UINT8.get(buf, off),
        flags: Token2.UINT24_BE.get(buf, off + 1),
        nextItemID: Token2.UINT32_BE.get(buf, off + 4)
      })
    };
    var FixedLengthAtom = class {
      /**
       *
       * @param {number} len Length as specified in the size field
       * @param {number} expLen Total length of sum of specified fields in the standard
       */
      constructor(len, expLen, atomId) {
        if (this.len = len, len < expLen)
          throw new Error(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);
        len > expLen && debug(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);
      }
    };
    exports2.FixedLengthAtom = FixedLengthAtom;
    var SecondsSinceMacEpoch = {
      len: 4,
      get: (buf, off) => {
        let secondsSinceUnixEpoch = Token2.UINT32_BE.get(buf, off) - 2082844800;
        return new Date(secondsSinceUnixEpoch * 1e3);
      }
    }, MdhdAtom = class extends FixedLengthAtom {
      constructor(len) {
        super(len, 24, "mdhd"), this.len = len;
      }
      get(buf, off) {
        return {
          version: Token2.UINT8.get(buf, off + 0),
          flags: Token2.UINT24_BE.get(buf, off + 1),
          creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
          modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
          timeScale: Token2.UINT32_BE.get(buf, off + 12),
          duration: Token2.UINT32_BE.get(buf, off + 16),
          language: Token2.UINT16_BE.get(buf, off + 20),
          quality: Token2.UINT16_BE.get(buf, off + 22)
        };
      }
    };
    exports2.MdhdAtom = MdhdAtom;
    var MvhdAtom = class extends FixedLengthAtom {
      constructor(len) {
        super(len, 100, "mvhd"), this.len = len;
      }
      get(buf, off) {
        return {
          version: Token2.UINT8.get(buf, off),
          flags: Token2.UINT24_BE.get(buf, off + 1),
          creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
          modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
          timeScale: Token2.UINT32_BE.get(buf, off + 12),
          duration: Token2.UINT32_BE.get(buf, off + 16),
          preferredRate: Token2.UINT32_BE.get(buf, off + 20),
          preferredVolume: Token2.UINT16_BE.get(buf, off + 24),
          // ignore reserver: 10 bytes
          // ignore matrix structure: 36 bytes
          previewTime: Token2.UINT32_BE.get(buf, off + 72),
          previewDuration: Token2.UINT32_BE.get(buf, off + 76),
          posterTime: Token2.UINT32_BE.get(buf, off + 80),
          selectionTime: Token2.UINT32_BE.get(buf, off + 84),
          selectionDuration: Token2.UINT32_BE.get(buf, off + 88),
          currentTime: Token2.UINT32_BE.get(buf, off + 92),
          nextTrackID: Token2.UINT32_BE.get(buf, off + 96)
        };
      }
    };
    exports2.MvhdAtom = MvhdAtom;
    var DataAtom = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        return {
          type: {
            set: Token2.UINT8.get(buf, off + 0),
            type: Token2.UINT24_BE.get(buf, off + 1)
          },
          locale: Token2.UINT24_BE.get(buf, off + 4),
          value: Buffer.from(new Token2.Uint8ArrayType(this.len - 8).get(buf, off + 8))
        };
      }
    };
    exports2.DataAtom = DataAtom;
    var NameAtom = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        return {
          version: Token2.UINT8.get(buf, off),
          flags: Token2.UINT24_BE.get(buf, off + 1),
          name: new Token2.StringType(this.len - 4, "utf-8").get(buf, off + 4)
        };
      }
    };
    exports2.NameAtom = NameAtom;
    var TrackHeaderAtom = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        return {
          version: Token2.UINT8.get(buf, off),
          flags: Token2.UINT24_BE.get(buf, off + 1),
          creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
          modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
          trackId: Token2.UINT32_BE.get(buf, off + 12),
          // reserved 4 bytes
          duration: Token2.UINT32_BE.get(buf, off + 20),
          layer: Token2.UINT16_BE.get(buf, off + 24),
          alternateGroup: Token2.UINT16_BE.get(buf, off + 26),
          volume: Token2.UINT16_BE.get(buf, off + 28)
          // ToDo: fixed point
          // ToDo: add remaining fields
        };
      }
    };
    exports2.TrackHeaderAtom = TrackHeaderAtom;
    var stsdHeader = {
      len: 8,
      get: (buf, off) => ({
        version: Token2.UINT8.get(buf, off),
        flags: Token2.UINT24_BE.get(buf, off + 1),
        numberOfEntries: Token2.UINT32_BE.get(buf, off + 4)
      })
    }, SampleDescriptionTable = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        return {
          dataFormat: FourCC_1.FourCcToken.get(buf, off),
          dataReferenceIndex: Token2.UINT16_BE.get(buf, off + 10),
          description: new Token2.Uint8ArrayType(this.len - 12).get(buf, off + 12)
        };
      }
    }, StsdAtom = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        let header = stsdHeader.get(buf, off);
        off += stsdHeader.len;
        let table = [];
        for (let n = 0; n < header.numberOfEntries; ++n) {
          let size = Token2.UINT32_BE.get(buf, off);
          off += Token2.UINT32_BE.len, table.push(new SampleDescriptionTable(size).get(buf, off)), off += size;
        }
        return {
          header,
          table
        };
      }
    };
    exports2.StsdAtom = StsdAtom;
    exports2.SoundSampleDescriptionVersion = {
      len: 8,
      get(buf, off) {
        return {
          version: Token2.INT16_BE.get(buf, off),
          revision: Token2.INT16_BE.get(buf, off + 2),
          vendor: Token2.INT32_BE.get(buf, off + 4)
        };
      }
    };
    exports2.SoundSampleDescriptionV0 = {
      len: 12,
      get(buf, off) {
        return {
          numAudioChannels: Token2.INT16_BE.get(buf, off + 0),
          sampleSize: Token2.INT16_BE.get(buf, off + 2),
          compressionId: Token2.INT16_BE.get(buf, off + 4),
          packetSize: Token2.INT16_BE.get(buf, off + 6),
          sampleRate: Token2.UINT16_BE.get(buf, off + 8) + Token2.UINT16_BE.get(buf, off + 10) / 1e4
        };
      }
    };
    var SimpleTableAtom = class {
      constructor(len, token) {
        this.len = len, this.token = token;
      }
      get(buf, off) {
        let nrOfEntries = Token2.INT32_BE.get(buf, off + 4);
        return {
          version: Token2.INT8.get(buf, off + 0),
          flags: Token2.INT24_BE.get(buf, off + 1),
          numberOfEntries: nrOfEntries,
          entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)
        };
      }
    };
    exports2.TimeToSampleToken = {
      len: 8,
      get(buf, off) {
        return {
          count: Token2.INT32_BE.get(buf, off + 0),
          duration: Token2.INT32_BE.get(buf, off + 4)
        };
      }
    };
    var SttsAtom = class extends SimpleTableAtom {
      constructor(len) {
        super(len, exports2.TimeToSampleToken), this.len = len;
      }
    };
    exports2.SttsAtom = SttsAtom;
    exports2.SampleToChunkToken = {
      len: 12,
      get(buf, off) {
        return {
          firstChunk: Token2.INT32_BE.get(buf, off),
          samplesPerChunk: Token2.INT32_BE.get(buf, off + 4),
          sampleDescriptionId: Token2.INT32_BE.get(buf, off + 8)
        };
      }
    };
    var StscAtom = class extends SimpleTableAtom {
      constructor(len) {
        super(len, exports2.SampleToChunkToken), this.len = len;
      }
    };
    exports2.StscAtom = StscAtom;
    var StszAtom = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        let nrOfEntries = Token2.INT32_BE.get(buf, off + 8);
        return {
          version: Token2.INT8.get(buf, off),
          flags: Token2.INT24_BE.get(buf, off + 1),
          sampleSize: Token2.INT32_BE.get(buf, off + 4),
          numberOfEntries: nrOfEntries,
          entries: readTokenTable(buf, Token2.INT32_BE, off + 12, this.len - 12, nrOfEntries)
        };
      }
    };
    exports2.StszAtom = StszAtom;
    var StcoAtom = class extends SimpleTableAtom {
      constructor(len) {
        super(len, Token2.INT32_BE), this.len = len;
      }
    };
    exports2.StcoAtom = StcoAtom;
    var ChapterText = class {
      constructor(len) {
        this.len = len;
      }
      get(buf, off) {
        let titleLen = Token2.INT16_BE.get(buf, off + 0);
        return new Token2.StringType(titleLen, "utf-8").get(buf, off + 2);
      }
    };
    exports2.ChapterText = ChapterText;
    function readTokenTable(buf, token, off, remainingLen, numberOfEntries) {
      if (debug(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`), remainingLen === 0)
        return [];
      if (remainingLen !== numberOfEntries * token.len)
        throw new Error("mismatch number-of-entries with remaining atom-length");
      let entries = [];
      for (let n = 0; n < numberOfEntries; ++n)
        entries.push(token.get(buf, off)), off += token.len;
      return entries;
    }
  }
});

// node_modules/music-metadata/lib/mp4/Atom.js
var require_Atom = __commonJS({
  "node_modules/music-metadata/lib/mp4/Atom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Atom = void 0;
    var debug_1 = require_browser(), AtomToken = require_AtomToken(), debug = (0, debug_1.default)("music-metadata:parser:MP4:Atom"), Atom = class _Atom {
      static async readAtom(tokenizer, dataHandler, parent, remaining) {
        let offset = tokenizer.position, header = await tokenizer.readToken(AtomToken.Header);
        header.length === BigInt(1) && (header.length = await tokenizer.readToken(AtomToken.ExtendedSize));
        let atomBean = new _Atom(header, header.length === BigInt(1), parent), payloadLength = atomBean.getPayloadLength(remaining);
        return debug(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`), await atomBean.readData(tokenizer, dataHandler, payloadLength), atomBean;
      }
      constructor(header, extended, parent) {
        this.header = header, this.extended = extended, this.parent = parent, this.children = [], this.atomPath = (this.parent ? this.parent.atomPath + "." : "") + this.header.name;
      }
      getHeaderLength() {
        return this.extended ? 16 : 8;
      }
      getPayloadLength(remaining) {
        return (this.header.length === BigInt(0) ? remaining : Number(this.header.length)) - this.getHeaderLength();
      }
      async readAtoms(tokenizer, dataHandler, size) {
        for (; size > 0; ) {
          let atomBean = await _Atom.readAtom(tokenizer, dataHandler, this, size);
          this.children.push(atomBean), size -= atomBean.header.length === BigInt(0) ? size : Number(atomBean.header.length);
        }
      }
      async readData(tokenizer, dataHandler, remaining) {
        switch (this.header.name) {
          case "moov":
          case "udta":
          case "trak":
          case "mdia":
          case "minf":
          case "stbl":
          case "<id>":
          case "ilst":
          case "tref":
            return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));
          case "meta":
            let paddingLength = (await tokenizer.peekToken(AtomToken.Header)).name === "hdlr" ? 0 : 4;
            return await tokenizer.ignore(paddingLength), this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);
          case "mdhd":
          case "mvhd":
          case "tkhd":
          case "stsz":
          case "mdat":
          default:
            return dataHandler(this, remaining);
        }
      }
    };
    exports2.Atom = Atom;
  }
});

// node_modules/music-metadata/lib/mp4/MP4Parser.js
var require_MP4Parser = __commonJS({
  "node_modules/music-metadata/lib/mp4/MP4Parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MP4Parser = void 0;
    var debug_1 = require_browser(), Token2 = require_lib3(), BasicParser_1 = require_BasicParser(), ID3v1Parser_1 = require_ID3v1Parser(), type_1 = require_type(), Atom_1 = require_Atom(), AtomToken = require_AtomToken(), debug = (0, debug_1.default)("music-metadata:parser:MP4"), tagFormat = "iTunes", encoderDict = {
      raw: {
        lossy: !1,
        format: "raw"
      },
      MAC3: {
        lossy: !0,
        format: "MACE 3:1"
      },
      MAC6: {
        lossy: !0,
        format: "MACE 6:1"
      },
      ima4: {
        lossy: !0,
        format: "IMA 4:1"
      },
      ulaw: {
        lossy: !0,
        format: "uLaw 2:1"
      },
      alaw: {
        lossy: !0,
        format: "uLaw 2:1"
      },
      Qclp: {
        lossy: !0,
        format: "QUALCOMM PureVoice"
      },
      ".mp3": {
        lossy: !0,
        format: "MPEG-1 layer 3"
      },
      alac: {
        lossy: !1,
        format: "ALAC"
      },
      "ac-3": {
        lossy: !0,
        format: "AC-3"
      },
      mp4a: {
        lossy: !0,
        format: "MPEG-4/AAC"
      },
      mp4s: {
        lossy: !0,
        format: "MP4S"
      },
      // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87
      c608: {
        lossy: !0,
        format: "CEA-608"
      },
      c708: {
        lossy: !0,
        format: "CEA-708"
      }
    };
    function distinct(value, index, self) {
      return self.indexOf(value) === index;
    }
    var MP4Parser = class _MP4Parser extends BasicParser_1.BasicParser {
      constructor() {
        super(...arguments), this.atomParsers = {
          /**
           * Parse movie header (mvhd) atom
           * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313
           */
          mvhd: async (len) => {
            let mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));
            this.metadata.setFormat("creationTime", mvhd.creationTime), this.metadata.setFormat("modificationTime", mvhd.modificationTime);
          },
          /**
           * Parse media header (mdhd) atom
           * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615
           */
          mdhd: async (len) => {
            let mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(len)), td = this.getTrackDescription();
            td.creationTime = mdhd_data.creationTime, td.modificationTime = mdhd_data.modificationTime, td.timeScale = mdhd_data.timeScale, td.duration = mdhd_data.duration;
          },
          chap: async (len) => {
            let td = this.getTrackDescription(), trackIds = [];
            for (; len >= Token2.UINT32_BE.len; )
              trackIds.push(await this.tokenizer.readNumber(Token2.UINT32_BE)), len -= Token2.UINT32_BE.len;
            td.chapterList = trackIds;
          },
          tkhd: async (len) => {
            let track = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len));
            this.tracks.push(track);
          },
          /**
           * Parse mdat atom.
           * Will scan for chapters
           */
          mdat: async (len) => {
            if (this.audioLengthInBytes = len, this.calculateBitRate(), this.options.includeChapters) {
              let trackWithChapters = this.tracks.filter((track) => track.chapterList);
              if (trackWithChapters.length === 1) {
                let chapterTrackIds = trackWithChapters[0].chapterList, chapterTracks = this.tracks.filter((track) => chapterTrackIds.indexOf(track.trackId) !== -1);
                if (chapterTracks.length === 1)
                  return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);
              }
            }
            await this.tokenizer.ignore(len);
          },
          ftyp: async (len) => {
            let types = [];
            for (; len > 0; ) {
              let ftype = await this.tokenizer.readToken(AtomToken.ftyp);
              len -= AtomToken.ftyp.len;
              let value = ftype.type.replace(/\W/g, "");
              value.length > 0 && types.push(value);
            }
            debug(`ftyp: ${types.join("/")}`);
            let x = types.filter(distinct).join("/");
            this.metadata.setFormat("container", x);
          },
          /**
           * Parse sample description atom
           */
          stsd: async (len) => {
            let stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len)), trackDescription = this.getTrackDescription();
            trackDescription.soundSampleDescription = stsd.table.map((dfEntry) => this.parseSoundSampleDescription(dfEntry));
          },
          /**
           * sample-to-Chunk Atoms
           */
          stsc: async (len) => {
            let stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));
            this.getTrackDescription().sampleToChunkTable = stsc.entries;
          },
          /**
           * time-to-sample table
           */
          stts: async (len) => {
            let stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));
            this.getTrackDescription().timeToSampleTable = stts.entries;
          },
          /**
           * Parse sample-sizes atom ('stsz')
           */
          stsz: async (len) => {
            let stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len)), td = this.getTrackDescription();
            td.sampleSize = stsz.sampleSize, td.sampleSizeTable = stsz.entries;
          },
          /**
           * Parse chunk-offset atom ('stco')
           */
          stco: async (len) => {
            let stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));
            this.getTrackDescription().chunkOffsetTable = stco.entries;
          },
          date: async (len) => {
            let date = await this.tokenizer.readToken(new Token2.StringType(len, "utf-8"));
            this.addTag("date", date);
          }
        };
      }
      static read_BE_Integer(array, signed) {
        let integerType = (signed ? "INT" : "UINT") + array.length * 8 + (array.length > 1 ? "_BE" : ""), token = Token2[integerType];
        if (!token)
          throw new Error('Token for integer type not found: "' + integerType + '"');
        return Number(token.get(array, 0));
      }
      async parse() {
        this.tracks = [];
        let remainingFileSize = this.tokenizer.fileInfo.size;
        for (; !this.tokenizer.fileInfo.size || remainingFileSize > 0; ) {
          try {
            if ((await this.tokenizer.peekToken(AtomToken.Header)).name === "\0\0\0\0") {
              let errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;
              debug(errMsg), this.addWarning(errMsg);
              break;
            }
          } catch (error) {
            let errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;
            debug(errMsg), this.addWarning(errMsg);
            break;
          }
          let rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);
          remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);
        }
        let formatList = [];
        this.tracks.forEach((track) => {
          let trackFormats = [];
          track.soundSampleDescription.forEach((ssd) => {
            let streamInfo = {}, encoderInfo = encoderDict[ssd.dataFormat];
            if (encoderInfo ? (trackFormats.push(encoderInfo.format), streamInfo.codecName = encoderInfo.format) : streamInfo.codecName = `<${ssd.dataFormat}>`, ssd.description) {
              let { description } = ssd;
              description.sampleRate > 0 && (streamInfo.type = type_1.TrackType.audio, streamInfo.audio = {
                samplingFrequency: description.sampleRate,
                bitDepth: description.sampleSize,
                channels: description.numAudioChannels
              });
            }
            this.metadata.addStreamInfo(streamInfo);
          }), trackFormats.length >= 1 && formatList.push(trackFormats.join("/"));
        }), formatList.length > 0 && this.metadata.setFormat("codec", formatList.filter(distinct).join("+"));
        let audioTracks = this.tracks.filter((track) => track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0);
        if (audioTracks.length >= 1) {
          let audioTrack = audioTracks[0];
          if (audioTrack.timeScale > 0) {
            let duration = audioTrack.duration / audioTrack.timeScale;
            this.metadata.setFormat("duration", duration);
          }
          let ssd = audioTrack.soundSampleDescription[0];
          if (ssd.description && (this.metadata.setFormat("sampleRate", ssd.description.sampleRate), this.metadata.setFormat("bitsPerSample", ssd.description.sampleSize), this.metadata.setFormat("numberOfChannels", ssd.description.numAudioChannels), audioTrack.timeScale === 0 && audioTrack.timeToSampleTable.length > 0)) {
            let duration = audioTrack.timeToSampleTable.map((ttstEntry) => ttstEntry.count * ttstEntry.duration).reduce((total, sampleSize) => total + sampleSize) / ssd.description.sampleRate;
            this.metadata.setFormat("duration", duration);
          }
          let encoderInfo = encoderDict[ssd.dataFormat];
          encoderInfo && this.metadata.setFormat("lossless", !encoderInfo.lossy), this.calculateBitRate();
        }
      }
      async handleAtom(atom, remaining) {
        if (atom.parent)
          switch (atom.parent.header.name) {
            case "ilst":
            case "<id>":
              return this.parseMetadataItemData(atom);
          }
        if (this.atomParsers[atom.header.name])
          return this.atomParsers[atom.header.name](remaining);
        debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`), await this.tokenizer.ignore(remaining);
      }
      getTrackDescription() {
        return this.tracks[this.tracks.length - 1];
      }
      calculateBitRate() {
        this.audioLengthInBytes && this.metadata.format.duration && this.metadata.setFormat("bitrate", 8 * this.audioLengthInBytes / this.metadata.format.duration);
      }
      addTag(id, value) {
        this.metadata.addTag(tagFormat, id, value);
      }
      addWarning(message) {
        debug("Warning: " + message), this.metadata.addWarning(message);
      }
      /**
       * Parse data of Meta-item-list-atom (item of 'ilst' atom)
       * @param metaAtom
       * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
       */
      parseMetadataItemData(metaAtom) {
        let tagKey = metaAtom.header.name;
        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {
          let payLoadLength = child.getPayloadLength(remaining);
          switch (child.header.name) {
            case "data":
              return this.parseValueAtom(tagKey, child);
            case "name":
            case "mean":
            case "rate":
              let name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));
              tagKey += ":" + name.name;
              break;
            default:
              let dataAtom = await this.tokenizer.readToken(new Token2.BufferType(payLoadLength));
              this.addWarning("Unsupported meta-item: " + tagKey + "[" + child.header.name + "] => value=" + dataAtom.toString("hex") + " ascii=" + dataAtom.toString("ascii"));
          }
        }, metaAtom.getPayloadLength(0));
      }
      async parseValueAtom(tagKey, metaAtom) {
        let dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));
        if (dataAtom.type.set !== 0)
          throw new Error("Unsupported type-set != 0: " + dataAtom.type.set);
        switch (dataAtom.type.type) {
          case 0:
            switch (tagKey) {
              case "trkn":
              case "disk":
                let num = Token2.UINT8.get(dataAtom.value, 3), of = Token2.UINT8.get(dataAtom.value, 5);
                this.addTag(tagKey, num + "/" + of);
                break;
              case "gnre":
                let genreInt = Token2.UINT8.get(dataAtom.value, 1), genreStr = ID3v1Parser_1.Genres[genreInt - 1];
                this.addTag(tagKey, genreStr);
                break;
              case "rate":
                let rate = dataAtom.value.toString("ascii");
                this.addTag(tagKey, rate);
                break;
              default:
                debug("unknown proprietary value type for: " + metaAtom.atomPath);
            }
            break;
          case 1:
          case 18:
            this.addTag(tagKey, dataAtom.value.toString("utf-8"));
            break;
          case 13:
            if (this.options.skipCovers)
              break;
            this.addTag(tagKey, {
              format: "image/jpeg",
              data: Buffer.from(dataAtom.value)
            });
            break;
          case 14:
            if (this.options.skipCovers)
              break;
            this.addTag(tagKey, {
              format: "image/png",
              data: Buffer.from(dataAtom.value)
            });
            break;
          case 21:
            this.addTag(tagKey, _MP4Parser.read_BE_Integer(dataAtom.value, !0));
            break;
          case 22:
            this.addTag(tagKey, _MP4Parser.read_BE_Integer(dataAtom.value, !1));
            break;
          case 65:
            this.addTag(tagKey, dataAtom.value.readInt8(0));
            break;
          case 66:
            this.addTag(tagKey, dataAtom.value.readInt16BE(0));
            break;
          case 67:
            this.addTag(tagKey, dataAtom.value.readInt32BE(0));
            break;
          default:
            this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);
        }
      }
      /**
       * @param sampleDescription
       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916
       */
      parseSoundSampleDescription(sampleDescription) {
        let ssd = {
          dataFormat: sampleDescription.dataFormat,
          dataReferenceIndex: sampleDescription.dataReferenceIndex
        }, offset = 0, version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);
        return offset += AtomToken.SoundSampleDescriptionVersion.len, version.version === 0 || version.version === 1 ? ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset) : debug(`Warning: sound-sample-description ${version} not implemented`), ssd;
      }
      async parseChapterTrack(chapterTrack, track, len) {
        if (!chapterTrack.sampleSize && chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)
          throw new Error("Expected equal chunk-offset-table & sample-size-table length.");
        let chapters = [];
        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {
          let nextChunkLen = chapterTrack.chunkOffsetTable[i] - this.tokenizer.position, sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];
          if (len -= nextChunkLen + sampleSize, len < 0)
            throw new Error("Chapter chunk exceeding token length");
          await this.tokenizer.ignore(nextChunkLen);
          let title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));
          debug(`Chapter ${i + 1}: ${title}`);
          let chapter = {
            title,
            sampleOffset: this.findSampleOffset(track, this.tokenizer.position)
          };
          debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`), chapters.push(chapter);
        }
        this.metadata.setFormat("chapters", chapters), await this.tokenizer.ignore(len);
      }
      findSampleOffset(track, chapterOffset) {
        let totalDuration = 0;
        track.timeToSampleTable.forEach((e) => {
          totalDuration += e.count * e.duration;
        }), debug(`Total duration=${totalDuration}`);
        let chunkIndex = 0;
        for (; chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset; )
          ++chunkIndex;
        return this.getChunkDuration(chunkIndex + 1, track);
      }
      getChunkDuration(chunkId, track) {
        let ttsi = 0, ttsc = track.timeToSampleTable[ttsi].count, ttsd = track.timeToSampleTable[ttsi].duration, curChunkId = 1, samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable), totalDuration = 0;
        for (; curChunkId < chunkId; ) {
          let nrOfSamples = Math.min(ttsc, samplesPerChunk);
          totalDuration += nrOfSamples * ttsd, ttsc -= nrOfSamples, samplesPerChunk -= nrOfSamples, samplesPerChunk === 0 ? (++curChunkId, samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable)) : (++ttsi, ttsc = track.timeToSampleTable[ttsi].count, ttsd = track.timeToSampleTable[ttsi].duration);
        }
        return totalDuration;
      }
      getSamplesPerChunk(chunkId, stcTable) {
        for (let i = 0; i < stcTable.length - 1; ++i)
          if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk)
            return stcTable[i].samplesPerChunk;
        return stcTable[stcTable.length - 1].samplesPerChunk;
      }
    };
    exports2.MP4Parser = MP4Parser;
  }
});

// node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js
var require_ReplayGainDataFormat = __commonJS({
  "node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ReplayGain = void 0;
    var common = require_Util(), NameCode;
    (function(NameCode2) {
      NameCode2[NameCode2.not_set = 0] = "not_set", NameCode2[NameCode2.radio = 1] = "radio", NameCode2[NameCode2.audiophile = 2] = "audiophile";
    })(NameCode || (NameCode = {}));
    var ReplayGainOriginator;
    (function(ReplayGainOriginator2) {
      ReplayGainOriginator2[ReplayGainOriginator2.unspecified = 0] = "unspecified", ReplayGainOriginator2[ReplayGainOriginator2.engineer = 1] = "engineer", ReplayGainOriginator2[ReplayGainOriginator2.user = 2] = "user", ReplayGainOriginator2[ReplayGainOriginator2.automatic = 3] = "automatic", ReplayGainOriginator2[ReplayGainOriginator2.rms_average = 4] = "rms_average";
    })(ReplayGainOriginator || (ReplayGainOriginator = {}));
    exports2.ReplayGain = {
      len: 2,
      get: (buf, off) => {
        let gain_type = common.getBitAllignedNumber(buf, off, 0, 3), sign = common.getBitAllignedNumber(buf, off, 6, 1), gain_adj = common.getBitAllignedNumber(buf, off, 7, 9) / 10;
        if (gain_type > 0)
          return {
            type: common.getBitAllignedNumber(buf, off, 0, 3),
            origin: common.getBitAllignedNumber(buf, off, 3, 3),
            adjustment: sign ? -gain_adj : gain_adj
          };
      }
    };
  }
});

// node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js
var require_ExtendedLameHeader = __commonJS({
  "node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ExtendedLameHeader = void 0;
    var Token2 = require_lib3(), common = require_Util(), ReplayGainDataFormat_1 = require_ReplayGainDataFormat();
    exports2.ExtendedLameHeader = {
      len: 27,
      get: (buf, off) => {
        let track_peak = Token2.UINT32_BE.get(buf, off + 2);
        return {
          revision: common.getBitAllignedNumber(buf, off, 0, 4),
          vbr_method: common.getBitAllignedNumber(buf, off, 4, 4),
          lowpass_filter: 100 * Token2.UINT8.get(buf, off + 1),
          track_peak: track_peak === 0 ? void 0 : track_peak / Math.pow(2, 23),
          track_gain: ReplayGainDataFormat_1.ReplayGain.get(buf, 6),
          album_gain: ReplayGainDataFormat_1.ReplayGain.get(buf, 8),
          music_length: Token2.UINT32_BE.get(buf, off + 20),
          music_crc: Token2.UINT8.get(buf, off + 24),
          header_crc: Token2.UINT16_BE.get(buf, off + 24)
        };
      }
    };
  }
});

// node_modules/music-metadata/lib/mpeg/XingTag.js
var require_XingTag = __commonJS({
  "node_modules/music-metadata/lib/mpeg/XingTag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.readXingHeader = exports2.XingHeaderFlags = exports2.LameEncoderVersion = exports2.InfoTagHeaderTag = void 0;
    var Token2 = require_lib3(), util = require_Util(), ExtendedLameHeader_1 = require_ExtendedLameHeader();
    exports2.InfoTagHeaderTag = new Token2.StringType(4, "ascii");
    exports2.LameEncoderVersion = new Token2.StringType(6, "ascii");
    exports2.XingHeaderFlags = {
      len: 4,
      get: (buf, off) => ({
        frames: util.isBitSet(buf, off, 31),
        bytes: util.isBitSet(buf, off, 30),
        toc: util.isBitSet(buf, off, 29),
        vbrScale: util.isBitSet(buf, off, 28)
      })
    };
    async function readXingHeader(tokenizer) {
      let flags = await tokenizer.readToken(exports2.XingHeaderFlags), xingInfoTag = {};
      if (flags.frames && (xingInfoTag.numFrames = await tokenizer.readToken(Token2.UINT32_BE)), flags.bytes && (xingInfoTag.streamSize = await tokenizer.readToken(Token2.UINT32_BE)), flags.toc && (xingInfoTag.toc = Buffer.alloc(100), await tokenizer.readBuffer(xingInfoTag.toc)), flags.vbrScale && (xingInfoTag.vbrScale = await tokenizer.readToken(Token2.UINT32_BE)), await tokenizer.peekToken(new Token2.StringType(4, "ascii")) === "LAME" && (await tokenizer.ignore(4), xingInfoTag.lame = {
        version: await tokenizer.readToken(new Token2.StringType(5, "ascii"))
      }, xingInfoTag.lame.version.match(/\d+.\d+/g))) {
        let version = xingInfoTag.lame.version.match(/\d+.\d+/g)[0].split(".").map((n) => parseInt(n, 10));
        version[0] >= 3 && version[1] >= 90 && (xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader_1.ExtendedLameHeader));
      }
      return xingInfoTag;
    }
    exports2.readXingHeader = readXingHeader;
  }
});

// node_modules/music-metadata/lib/mpeg/MpegParser.js
var require_MpegParser = __commonJS({
  "node_modules/music-metadata/lib/mpeg/MpegParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MpegParser = void 0;
    var Token2 = require_lib3(), core_1 = require_core(), debug_1 = require_browser(), common = require_Util(), AbstractID3Parser_1 = require_AbstractID3Parser(), XingTag_1 = require_XingTag(), debug = (0, debug_1.default)("music-metadata:parser:mpeg"), maxPeekLen = 1024, MPEG4 = {
      /**
       * Audio Object Types
       */
      AudioObjectTypes: [
        "AAC Main",
        "AAC LC",
        "AAC SSR",
        "AAC LTP"
        // Long Term Prediction
      ],
      /**
       * Sampling Frequencies
       * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies
       */
      SamplingFrequencies: [
        96e3,
        88200,
        64e3,
        48e3,
        44100,
        32e3,
        24e3,
        22050,
        16e3,
        12e3,
        11025,
        8e3,
        7350,
        void 0,
        void 0,
        -1
      ]
      /**
       * Channel Configurations
       */
    }, MPEG4_ChannelConfigurations = [
      void 0,
      ["front-center"],
      ["front-left", "front-right"],
      ["front-center", "front-left", "front-right"],
      ["front-center", "front-left", "front-right", "back-center"],
      ["front-center", "front-left", "front-right", "back-left", "back-right"],
      ["front-center", "front-left", "front-right", "back-left", "back-right", "LFE-channel"],
      ["front-center", "front-left", "front-right", "side-left", "side-right", "back-left", "back-right", "LFE-channel"]
    ], MpegFrameHeader = class _MpegFrameHeader {
      constructor(buf, off) {
        this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2), this.layer = _MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)], this.versionIndex > 1 && this.layer === 0 ? this.parseAdtsHeader(buf, off) : this.parseMpegHeader(buf, off), this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);
      }
      calcDuration(numFrames) {
        return numFrames * this.calcSamplesPerFrame() / this.samplingRate;
      }
      calcSamplesPerFrame() {
        return _MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
      }
      calculateSideInfoLength() {
        if (this.layer !== 3)
          return 2;
        if (this.channelModeIndex === 3) {
          if (this.version === 1)
            return 17;
          if (this.version === 2 || this.version === 2.5)
            return 9;
        } else {
          if (this.version === 1)
            return 32;
          if (this.version === 2 || this.version === 2.5)
            return 17;
        }
      }
      calcSlotSize() {
        return [null, 4, 1, 1][this.layer];
      }
      parseMpegHeader(buf, off) {
        this.container = "MPEG", this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4), this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2), this.padding = common.isBitSet(buf, off + 2, 6), this.privateBit = common.isBitSet(buf, off + 2, 7), this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2), this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2), this.isCopyrighted = common.isBitSet(buf, off + 3, 4), this.isOriginalMedia = common.isBitSet(buf, off + 3, 5), this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2), this.version = _MpegFrameHeader.VersionID[this.versionIndex], this.channelMode = _MpegFrameHeader.ChannelMode[this.channelModeIndex], this.codec = `MPEG ${this.version} Layer ${this.layer}`;
        let bitrateInKbps = this.calcBitrate();
        if (!bitrateInKbps)
          throw new Error("Cannot determine bit-rate");
        if (this.bitrate = bitrateInKbps * 1e3, this.samplingRate = this.calcSamplingRate(), this.samplingRate == null)
          throw new Error("Cannot determine sampling-rate");
      }
      parseAdtsHeader(buf, off) {
        debug("layer=0 => ADTS"), this.version = this.versionIndex === 2 ? 4 : 2, this.container = "ADTS/MPEG-" + this.version;
        let profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);
        this.codec = "AAC", this.codecProfile = MPEG4.AudioObjectTypes[profileIndex], debug(`MPEG-4 audio-codec=${this.codec}`);
        let samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);
        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex], debug(`sampling-rate=${this.samplingRate}`);
        let channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);
        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex], debug(`channel-config=${this.mp4ChannelConfig.join("+")}`), this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;
      }
      calcBitrate() {
        if (this.bitrateIndex === 0 || // free
        this.bitrateIndex === 15)
          return;
        let codecIndex = `${Math.floor(this.version)}${this.layer}`;
        return _MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];
      }
      calcSamplingRate() {
        return this.sampRateFreqIndex === 3 ? null : _MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
      }
    };
    MpegFrameHeader.SyncByte1 = 255;
    MpegFrameHeader.SyncByte2 = 224;
    MpegFrameHeader.VersionID = [2.5, null, 2, 1];
    MpegFrameHeader.LayerDescription = [0, 3, 2, 1];
    MpegFrameHeader.ChannelMode = ["stereo", "joint_stereo", "dual_channel", "mono"];
    MpegFrameHeader.bitrate_index = {
      1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
      2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
      3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
      4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
      5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
      6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
      7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
      8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
      9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
      10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
      11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
      12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
      13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
      14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
    };
    MpegFrameHeader.sampling_rate_freq_index = {
      1: { 0: 44100, 1: 48e3, 2: 32e3 },
      2: { 0: 22050, 1: 24e3, 2: 16e3 },
      2.5: { 0: 11025, 1: 12e3, 2: 8e3 }
    };
    MpegFrameHeader.samplesInFrameTable = [
      /* Layer   I    II   III */
      [0, 384, 1152, 1152],
      [0, 384, 1152, 576]
      // MPEG-2(.5
    ];
    var FrameHeader = {
      len: 4,
      get: (buf, off) => new MpegFrameHeader(buf, off)
    };
    function getVbrCodecProfile(vbrScale) {
      return "V" + Math.floor((100 - vbrScale) / 10);
    }
    var MpegParser = class extends AbstractID3Parser_1.AbstractID3Parser {
      constructor() {
        super(...arguments), this.frameCount = 0, this.syncFrameCount = -1, this.countSkipFrameData = 0, this.totalDataLength = 0, this.bitrates = [], this.calculateEofDuration = !1, this.buf_frame_header = Buffer.alloc(4), this.syncPeek = {
          buf: Buffer.alloc(maxPeekLen),
          len: 0
        };
      }
      /**
       * Called after ID3 headers have been parsed
       */
      async postId3v2Parse() {
        this.metadata.setFormat("lossless", !1);
        try {
          let quit = !1;
          for (; !quit; )
            await this.sync(), quit = await this.parseCommonMpegHeader();
        } catch (err) {
          if (err instanceof core_1.EndOfStreamError) {
            if (debug("End-of-stream"), this.calculateEofDuration) {
              let numberOfSamples = this.frameCount * this.samplesPerFrame;
              this.metadata.setFormat("numberOfSamples", numberOfSamples);
              let duration = numberOfSamples / this.metadata.format.sampleRate;
              debug(`Calculate duration at EOF: ${duration} sec.`, duration), this.metadata.setFormat("duration", duration);
            }
          } else
            throw err;
        }
      }
      /**
       * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
       */
      finalize() {
        let format = this.metadata.format, hasID3v1 = this.metadata.native.hasOwnProperty("ID3v1");
        if (format.duration && this.tokenizer.fileInfo.size) {
          let mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
          format.codecProfile && format.codecProfile[0] === "V" && this.metadata.setFormat("bitrate", mpegSize * 8 / format.duration);
        } else if (this.tokenizer.fileInfo.size && format.codecProfile === "CBR") {
          let mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0), numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;
          this.metadata.setFormat("numberOfSamples", numberOfSamples);
          let duration = numberOfSamples / format.sampleRate;
          debug("Calculate CBR duration based on file size: %s", duration), this.metadata.setFormat("duration", duration);
        }
      }
      async sync() {
        let gotFirstSync = !1;
        for (; ; ) {
          let bo = 0;
          if (this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: !0 }), this.syncPeek.len <= 163)
            throw new core_1.EndOfStreamError();
          for (; ; )
            if (gotFirstSync && (this.syncPeek.buf[bo] & 224) === 224) {
              this.buf_frame_header[0] = MpegFrameHeader.SyncByte1, this.buf_frame_header[1] = this.syncPeek.buf[bo], await this.tokenizer.ignore(bo), debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`), this.syncFrameCount === this.frameCount && (debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`), this.frameCount = 0, this.frame_size = 0), this.syncFrameCount = this.frameCount;
              return;
            } else if (gotFirstSync = !1, bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo), bo === -1) {
              if (this.syncPeek.len < this.syncPeek.buf.length)
                throw new core_1.EndOfStreamError();
              await this.tokenizer.ignore(this.syncPeek.len);
              break;
            } else
              ++bo, gotFirstSync = !0;
        }
      }
      /**
       * Combined ADTS & MPEG (MP2 & MP3) header handling
       * @return {Promise<boolean>} true if parser should quit
       */
      async parseCommonMpegHeader() {
        this.frameCount === 0 && (this.mpegOffset = this.tokenizer.position - 1), await this.tokenizer.peekBuffer(this.buf_frame_header, { offset: 1, length: 3 });
        let header;
        try {
          header = FrameHeader.get(this.buf_frame_header, 0);
        } catch (err) {
          return await this.tokenizer.ignore(1), this.metadata.addWarning("Parse error: " + err.message), !1;
        }
        return await this.tokenizer.ignore(3), this.metadata.setFormat("container", header.container), this.metadata.setFormat("codec", header.codec), this.metadata.setFormat("lossless", !1), this.metadata.setFormat("sampleRate", header.samplingRate), this.frameCount++, header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);
      }
      /**
       * @return {Promise<boolean>} true if parser should quit
       */
      async parseAudioFrameHeader(header) {
        this.metadata.setFormat("numberOfChannels", header.channelMode === "mono" ? 1 : 2), this.metadata.setFormat("bitrate", header.bitrate), this.frameCount < 20 * 1e4 && debug("offset=%s MP%s bitrate=%s sample-rate=%s", this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);
        let slot_size = header.calcSlotSize();
        if (slot_size === null)
          throw new Error("invalid slot_size");
        let samples_per_frame = header.calcSamplesPerFrame();
        debug(`samples_per_frame=${samples_per_frame}`);
        let fsize = samples_per_frame / 8 * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);
        if (this.frame_size = Math.floor(fsize), this.audioFrameHeader = header, this.bitrates.push(header.bitrate), this.frameCount === 1)
          return this.offset = FrameHeader.len, await this.skipSideInformation(), !1;
        if (this.frameCount === 3) {
          if (this.areAllSame(this.bitrates)) {
            if (this.samplesPerFrame = samples_per_frame, this.metadata.setFormat("codecProfile", "CBR"), this.tokenizer.fileInfo.size)
              return !0;
          } else if (this.metadata.format.duration)
            return !0;
          if (!this.options.duration)
            return !0;
        }
        return this.options.duration && this.frameCount === 4 && (this.samplesPerFrame = samples_per_frame, this.calculateEofDuration = !0), this.offset = 4, header.isProtectedByCRC ? (await this.parseCrc(), !1) : (await this.skipSideInformation(), !1);
      }
      async parseAdts(header) {
        let buf = Buffer.alloc(3);
        await this.tokenizer.readBuffer(buf), header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11), this.totalDataLength += header.frameLength, this.samplesPerFrame = 1024;
        let framesPerSec = header.samplingRate / this.samplesPerFrame, bitrate = 8 * (this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount) * framesPerSec + 0.5;
        if (this.metadata.setFormat("bitrate", bitrate), debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`), await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1), this.frameCount === 3)
          if (this.metadata.setFormat("codecProfile", header.codecProfile), header.mp4ChannelConfig && this.metadata.setFormat("numberOfChannels", header.mp4ChannelConfig.length), this.options.duration)
            this.calculateEofDuration = !0;
          else
            return !0;
        return !1;
      }
      async parseCrc() {
        return this.crc = await this.tokenizer.readNumber(Token2.INT16_BE), this.offset += 2, this.skipSideInformation();
      }
      async skipSideInformation() {
        let sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();
        await this.tokenizer.readToken(new Token2.Uint8ArrayType(sideinfo_length)), this.offset += sideinfo_length, await this.readXtraInfoHeader();
      }
      async readXtraInfoHeader() {
        let headerTag = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);
        switch (this.offset += XingTag_1.InfoTagHeaderTag.len, headerTag) {
          case "Info":
            return this.metadata.setFormat("codecProfile", "CBR"), this.readXingInfoHeader();
          case "Xing":
            let infoTag = await this.readXingInfoHeader(), codecProfile = getVbrCodecProfile(infoTag.vbrScale);
            return this.metadata.setFormat("codecProfile", codecProfile), null;
          case "Xtra":
            break;
          case "LAME":
            let version = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);
            if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len)
              return this.offset += XingTag_1.LameEncoderVersion.len, this.metadata.setFormat("tool", "LAME " + version), await this.skipFrameData(this.frame_size - this.offset), null;
            this.metadata.addWarning("Corrupt LAME header");
            break;
        }
        let frameDataLeft = this.frame_size - this.offset;
        return frameDataLeft < 0 ? this.metadata.addWarning("Frame " + this.frameCount + "corrupt: negative frameDataLeft") : await this.skipFrameData(frameDataLeft), null;
      }
      /**
       * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
       * @returns {Promise<string>}
       */
      async readXingInfoHeader() {
        let offset = this.tokenizer.position, infoTag = await (0, XingTag_1.readXingHeader)(this.tokenizer);
        if (this.offset += this.tokenizer.position - offset, infoTag.lame && (this.metadata.setFormat("tool", "LAME " + common.stripNulls(infoTag.lame.version)), infoTag.lame.extended && (this.metadata.setFormat("trackPeakLevel", infoTag.lame.extended.track_peak), infoTag.lame.extended.track_gain && this.metadata.setFormat("trackGain", infoTag.lame.extended.track_gain.adjustment), infoTag.lame.extended.album_gain && this.metadata.setFormat("albumGain", infoTag.lame.extended.album_gain.adjustment), this.metadata.setFormat("duration", infoTag.lame.extended.music_length / 1e3))), infoTag.streamSize) {
          let duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);
          return this.metadata.setFormat("duration", duration), debug("Get duration from Xing header: %s", this.metadata.format.duration), infoTag;
        }
        let frameDataLeft = this.frame_size - this.offset;
        return await this.skipFrameData(frameDataLeft), infoTag;
      }
      async skipFrameData(frameDataLeft) {
        if (frameDataLeft < 0)
          throw new Error("frame-data-left cannot be negative");
        await this.tokenizer.ignore(frameDataLeft), this.countSkipFrameData += frameDataLeft;
      }
      areAllSame(array) {
        let first = array[0];
        return array.every((element) => element === first);
      }
    };
    exports2.MpegParser = MpegParser;
  }
});

// node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js
var require_StreamVersion8 = __commonJS({
  "node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.StreamReader = void 0;
    var Token2 = require_lib3(), debug_1 = require_browser(), util = require_Util(), debug = (0, debug_1.default)("music-metadata:parser:musepack:sv8"), PacketKey = new Token2.StringType(2, "binary"), SH_part1 = {
      len: 5,
      get: (buf, off) => ({
        crc: Token2.UINT32_LE.get(buf, off),
        streamVersion: Token2.UINT8.get(buf, off + 4)
      })
    }, SH_part3 = {
      len: 2,
      get: (buf, off) => ({
        sampleFrequency: [44100, 48e3, 37800, 32e3][util.getBitAllignedNumber(buf, off, 0, 3)],
        maxUsedBands: util.getBitAllignedNumber(buf, off, 3, 5),
        channelCount: util.getBitAllignedNumber(buf, off + 1, 0, 4) + 1,
        msUsed: util.isBitSet(buf, off + 1, 4),
        audioBlockFrames: util.getBitAllignedNumber(buf, off + 1, 5, 3)
      })
    }, StreamReader = class {
      constructor(tokenizer) {
        this.tokenizer = tokenizer;
      }
      async readPacketHeader() {
        let key = await this.tokenizer.readToken(PacketKey), size = await this.readVariableSizeField();
        return {
          key,
          payloadLength: size.value - 2 - size.len
        };
      }
      async readStreamHeader(size) {
        let streamHeader = {};
        debug(`Reading SH at offset=${this.tokenizer.position}`);
        let part1 = await this.tokenizer.readToken(SH_part1);
        size -= SH_part1.len, Object.assign(streamHeader, part1), debug(`SH.streamVersion = ${part1.streamVersion}`);
        let sampleCount = await this.readVariableSizeField();
        size -= sampleCount.len, streamHeader.sampleCount = sampleCount.value;
        let bs = await this.readVariableSizeField();
        size -= bs.len, streamHeader.beginningOfSilence = bs.value;
        let part3 = await this.tokenizer.readToken(SH_part3);
        return size -= SH_part3.len, Object.assign(streamHeader, part3), await this.tokenizer.ignore(size), streamHeader;
      }
      async readVariableSizeField(len = 1, hb = 0) {
        let n = await this.tokenizer.readNumber(Token2.UINT8);
        return n & 128 ? (n &= 127, n += hb, this.readVariableSizeField(len + 1, n << 7)) : { len, value: hb + n };
      }
    };
    exports2.StreamReader = StreamReader;
  }
});

// node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js
var require_MpcSv8Parser = __commonJS({
  "node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MpcSv8Parser = void 0;
    var debug_1 = require_browser(), BasicParser_1 = require_BasicParser(), APEv2Parser_1 = require_APEv2Parser(), FourCC_1 = require_FourCC(), SV8 = require_StreamVersion8(), debug = (0, debug_1.default)("music-metadata:parser:musepack"), MpcSv8Parser = class extends BasicParser_1.BasicParser {
      constructor() {
        super(...arguments), this.audioLength = 0;
      }
      async parse() {
        if (await this.tokenizer.readToken(FourCC_1.FourCcToken) !== "MPCK")
          throw new Error("Invalid Magic number");
        return this.metadata.setFormat("container", "Musepack, SV8"), this.parsePacket();
      }
      async parsePacket() {
        let sv8reader = new SV8.StreamReader(this.tokenizer);
        do {
          let header = await sv8reader.readPacketHeader();
          switch (debug(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`), header.key) {
            case "SH":
              let sh = await sv8reader.readStreamHeader(header.payloadLength);
              this.metadata.setFormat("numberOfSamples", sh.sampleCount), this.metadata.setFormat("sampleRate", sh.sampleFrequency), this.metadata.setFormat("duration", sh.sampleCount / sh.sampleFrequency), this.metadata.setFormat("numberOfChannels", sh.channelCount);
              break;
            case "AP":
              this.audioLength += header.payloadLength, await this.tokenizer.ignore(header.payloadLength);
              break;
            case "RG":
            case "EI":
            case "SO":
            case "ST":
            case "CT":
              await this.tokenizer.ignore(header.payloadLength);
              break;
            case "SE":
              return this.metadata.setFormat("bitrate", this.audioLength * 8 / this.metadata.format.duration), APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
            default:
              throw new Error(`Unexpected header: ${header.key}`);
          }
        } while (!0);
      }
    };
    exports2.MpcSv8Parser = MpcSv8Parser;
  }
});

// node_modules/music-metadata/lib/musepack/sv7/BitReader.js
var require_BitReader = __commonJS({
  "node_modules/music-metadata/lib/musepack/sv7/BitReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.BitReader = void 0;
    var Token2 = require_lib3(), BitReader = class {
      constructor(tokenizer) {
        this.tokenizer = tokenizer, this.pos = 0, this.dword = void 0;
      }
      /**
       *
       * @param bits 1..30 bits
       */
      async read(bits) {
        for (; this.dword === void 0; )
          this.dword = await this.tokenizer.readToken(Token2.UINT32_LE);
        let out = this.dword;
        return this.pos += bits, this.pos < 32 ? (out >>>= 32 - this.pos, out & (1 << bits) - 1) : (this.pos -= 32, this.pos === 0 ? (this.dword = void 0, out & (1 << bits) - 1) : (this.dword = await this.tokenizer.readToken(Token2.UINT32_LE), this.pos && (out <<= this.pos, out |= this.dword >>> 32 - this.pos), out & (1 << bits) - 1));
      }
      async ignore(bits) {
        if (this.pos > 0) {
          let remaining = 32 - this.pos;
          this.dword = void 0, bits -= remaining, this.pos = 0;
        }
        let remainder = bits % 32, numOfWords = (bits - remainder) / 32;
        return await this.tokenizer.ignore(numOfWords * 4), this.read(remainder);
      }
    };
    exports2.BitReader = BitReader;
  }
});

// node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js
var require_StreamVersion7 = __commonJS({
  "node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Header = void 0;
    var Token2 = require_lib3(), util = require_Util();
    exports2.Header = {
      len: 6 * 4,
      get: (buf, off) => {
        let header = {
          // word 0
          signature: Buffer.from(buf).toString("latin1", off, off + 3),
          // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
          streamMinorVersion: util.getBitAllignedNumber(buf, off + 3, 0, 4),
          streamMajorVersion: util.getBitAllignedNumber(buf, off + 3, 4, 4),
          // word 1
          frameCount: Token2.UINT32_LE.get(buf, off + 4),
          // word 2
          maxLevel: Token2.UINT16_LE.get(buf, off + 8),
          sampleFrequency: [44100, 48e3, 37800, 32e3][util.getBitAllignedNumber(buf, off + 10, 0, 2)],
          link: util.getBitAllignedNumber(buf, off + 10, 2, 2),
          profile: util.getBitAllignedNumber(buf, off + 10, 4, 4),
          maxBand: util.getBitAllignedNumber(buf, off + 11, 0, 6),
          intensityStereo: util.isBitSet(buf, off + 11, 6),
          midSideStereo: util.isBitSet(buf, off + 11, 7),
          // word 3
          titlePeak: Token2.UINT16_LE.get(buf, off + 12),
          titleGain: Token2.UINT16_LE.get(buf, off + 14),
          // word 4
          albumPeak: Token2.UINT16_LE.get(buf, off + 16),
          albumGain: Token2.UINT16_LE.get(buf, off + 18),
          // word
          lastFrameLength: Token2.UINT32_LE.get(buf, off + 20) >>> 20 & 2047,
          trueGapless: util.isBitSet(buf, off + 23, 0)
        };
        return header.lastFrameLength = header.trueGapless ? Token2.UINT32_LE.get(buf, 20) >>> 20 & 2047 : 0, header;
      }
    };
  }
});

// node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js
var require_MpcSv7Parser = __commonJS({
  "node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MpcSv7Parser = void 0;
    var debug_1 = require_browser(), BasicParser_1 = require_BasicParser(), APEv2Parser_1 = require_APEv2Parser(), BitReader_1 = require_BitReader(), SV7 = require_StreamVersion7(), debug = (0, debug_1.default)("music-metadata:parser:musepack"), MpcSv7Parser = class extends BasicParser_1.BasicParser {
      constructor() {
        super(...arguments), this.audioLength = 0;
      }
      async parse() {
        let header = await this.tokenizer.readToken(SV7.Header);
        if (header.signature !== "MP+")
          throw new Error("Unexpected magic number");
        debug(`stream-version=${header.streamMajorVersion}.${header.streamMinorVersion}`), this.metadata.setFormat("container", "Musepack, SV7"), this.metadata.setFormat("sampleRate", header.sampleFrequency);
        let numberOfSamples = 1152 * (header.frameCount - 1) + header.lastFrameLength;
        this.metadata.setFormat("numberOfSamples", numberOfSamples), this.duration = numberOfSamples / header.sampleFrequency, this.metadata.setFormat("duration", this.duration), this.bitreader = new BitReader_1.BitReader(this.tokenizer), this.metadata.setFormat("numberOfChannels", header.midSideStereo || header.intensityStereo ? 2 : 1);
        let version = await this.bitreader.read(8);
        return this.metadata.setFormat("codec", (version / 100).toFixed(2)), await this.skipAudioData(header.frameCount), debug(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`), APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
      }
      async skipAudioData(frameCount) {
        for (; frameCount-- > 0; ) {
          let frameLength = await this.bitreader.read(20);
          this.audioLength += 20 + frameLength, await this.bitreader.ignore(frameLength);
        }
        let lastFrameLength = await this.bitreader.read(11);
        this.audioLength += lastFrameLength, this.metadata.setFormat("bitrate", this.audioLength / this.duration);
      }
    };
    exports2.MpcSv7Parser = MpcSv7Parser;
  }
});

// node_modules/music-metadata/lib/musepack/index.js
var require_musepack = __commonJS({
  "node_modules/music-metadata/lib/musepack/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var debug_1 = require_browser(), Token2 = require_lib3(), AbstractID3Parser_1 = require_AbstractID3Parser(), MpcSv8Parser_1 = require_MpcSv8Parser(), MpcSv7Parser_1 = require_MpcSv7Parser(), debug = (0, debug_1.default)("music-metadata:parser:musepack"), MusepackParser = class extends AbstractID3Parser_1.AbstractID3Parser {
      async postId3v2Parse() {
        let signature = await this.tokenizer.peekToken(new Token2.StringType(3, "binary")), mpcParser;
        switch (signature) {
          case "MP+": {
            debug("Musepack stream-version 7"), mpcParser = new MpcSv7Parser_1.MpcSv7Parser();
            break;
          }
          case "MPC": {
            debug("Musepack stream-version 8"), mpcParser = new MpcSv8Parser_1.MpcSv8Parser();
            break;
          }
          default:
            throw new Error("Invalid Musepack signature prefix");
        }
        return mpcParser.init(this.metadata, this.tokenizer, this.options), mpcParser.parse();
      }
    };
    exports2.default = MusepackParser;
  }
});

// node_modules/music-metadata/lib/ogg/opus/Opus.js
var require_Opus = __commonJS({
  "node_modules/music-metadata/lib/ogg/opus/Opus.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.IdHeader = void 0;
    var Token2 = require_lib3(), IdHeader = class {
      constructor(len) {
        if (this.len = len, len < 19)
          throw new Error("ID-header-page 0 should be at least 19 bytes long");
      }
      get(buf, off) {
        return {
          magicSignature: new Token2.StringType(8, "ascii").get(buf, off + 0),
          version: buf.readUInt8(off + 8),
          channelCount: buf.readUInt8(off + 9),
          preSkip: buf.readInt16LE(off + 10),
          inputSampleRate: buf.readInt32LE(off + 12),
          outputGain: buf.readInt16LE(off + 16),
          channelMapping: buf.readUInt8(off + 18)
        };
      }
    };
    exports2.IdHeader = IdHeader;
  }
});

// node_modules/music-metadata/lib/ogg/opus/OpusParser.js
var require_OpusParser = __commonJS({
  "node_modules/music-metadata/lib/ogg/opus/OpusParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.OpusParser = void 0;
    var Token2 = require_lib3(), VorbisParser_1 = require_VorbisParser(), Opus = require_Opus(), OpusParser = class extends VorbisParser_1.VorbisParser {
      constructor(metadata, options, tokenizer) {
        super(metadata, options), this.tokenizer = tokenizer, this.lastPos = -1;
      }
      /**
       * Parse first Opus Ogg page
       * @param {IPageHeader} header
       * @param {Buffer} pageData
       */
      parseFirstPage(header, pageData) {
        if (this.metadata.setFormat("codec", "Opus"), this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0), this.idHeader.magicSignature !== "OpusHead")
          throw new Error("Illegal ogg/Opus magic-signature");
        this.metadata.setFormat("sampleRate", this.idHeader.inputSampleRate), this.metadata.setFormat("numberOfChannels", this.idHeader.channelCount);
      }
      parseFullPage(pageData) {
        switch (new Token2.StringType(8, "ascii").get(pageData, 0)) {
          case "OpusTags":
            this.parseUserCommentList(pageData, 8), this.lastPos = this.tokenizer.position - pageData.length;
            break;
          default:
            break;
        }
      }
      calculateDuration(header) {
        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
          let pos_48bit = header.absoluteGranulePosition - this.idHeader.preSkip;
          if (this.metadata.setFormat("numberOfSamples", pos_48bit), this.metadata.setFormat("duration", pos_48bit / 48e3), this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {
            let dataSize = this.tokenizer.fileInfo.size - this.lastPos;
            this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
          }
        }
      }
    };
    exports2.OpusParser = OpusParser;
  }
});

// node_modules/music-metadata/lib/ogg/speex/Speex.js
var require_Speex = __commonJS({
  "node_modules/music-metadata/lib/ogg/speex/Speex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Header = void 0;
    var Token2 = require_lib3(), util = require_Util();
    exports2.Header = {
      len: 80,
      get: (buf, off) => ({
        speex: new Token2.StringType(8, "ascii").get(buf, off + 0),
        version: util.trimRightNull(new Token2.StringType(20, "ascii").get(buf, off + 8)),
        version_id: buf.readInt32LE(off + 28),
        header_size: buf.readInt32LE(off + 32),
        rate: buf.readInt32LE(off + 36),
        mode: buf.readInt32LE(off + 40),
        mode_bitstream_version: buf.readInt32LE(off + 44),
        nb_channels: buf.readInt32LE(off + 48),
        bitrate: buf.readInt32LE(off + 52),
        frame_size: buf.readInt32LE(off + 56),
        vbr: buf.readInt32LE(off + 60),
        frames_per_packet: buf.readInt32LE(off + 64),
        extra_headers: buf.readInt32LE(off + 68),
        reserved1: buf.readInt32LE(off + 72),
        reserved2: buf.readInt32LE(off + 76)
      })
    };
  }
});

// node_modules/music-metadata/lib/ogg/speex/SpeexParser.js
var require_SpeexParser = __commonJS({
  "node_modules/music-metadata/lib/ogg/speex/SpeexParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.SpeexParser = void 0;
    var debug_1 = require_browser(), VorbisParser_1 = require_VorbisParser(), Speex = require_Speex(), debug = (0, debug_1.default)("music-metadata:parser:ogg:speex"), SpeexParser = class extends VorbisParser_1.VorbisParser {
      constructor(metadata, options, tokenizer) {
        super(metadata, options), this.tokenizer = tokenizer;
      }
      /**
       * Parse first Speex Ogg page
       * @param {IPageHeader} header
       * @param {Buffer} pageData
       */
      parseFirstPage(header, pageData) {
        debug("First Ogg/Speex page");
        let speexHeader = Speex.Header.get(pageData, 0);
        this.metadata.setFormat("codec", `Speex ${speexHeader.version}`), this.metadata.setFormat("numberOfChannels", speexHeader.nb_channels), this.metadata.setFormat("sampleRate", speexHeader.rate), speexHeader.bitrate !== -1 && this.metadata.setFormat("bitrate", speexHeader.bitrate);
      }
    };
    exports2.SpeexParser = SpeexParser;
  }
});

// node_modules/music-metadata/lib/ogg/theora/Theora.js
var require_Theora = __commonJS({
  "node_modules/music-metadata/lib/ogg/theora/Theora.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.IdentificationHeader = void 0;
    var Token2 = require_lib3();
    exports2.IdentificationHeader = {
      len: 42,
      get: (buf, off) => ({
        id: new Token2.StringType(7, "ascii").get(buf, off),
        vmaj: buf.readUInt8(off + 7),
        vmin: buf.readUInt8(off + 8),
        vrev: buf.readUInt8(off + 9),
        vmbw: buf.readUInt16BE(off + 10),
        vmbh: buf.readUInt16BE(off + 17),
        nombr: Token2.UINT24_BE.get(buf, off + 37),
        nqual: buf.readUInt8(off + 40)
      })
    };
  }
});

// node_modules/music-metadata/lib/ogg/theora/TheoraParser.js
var require_TheoraParser = __commonJS({
  "node_modules/music-metadata/lib/ogg/theora/TheoraParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.TheoraParser = void 0;
    var debug_1 = require_browser(), Theora_1 = require_Theora(), debug = (0, debug_1.default)("music-metadata:parser:ogg:theora"), TheoraParser = class {
      constructor(metadata, options, tokenizer) {
        this.metadata = metadata, this.tokenizer = tokenizer;
      }
      /**
       * Vorbis 1 parser
       * @param header Ogg Page Header
       * @param pageData Page data
       */
      parsePage(header, pageData) {
        header.headerType.firstPage && this.parseFirstPage(header, pageData);
      }
      flush() {
        debug("flush");
      }
      calculateDuration(header) {
        debug("duration calculation not implemented");
      }
      /**
       * Parse first Theora Ogg page. the initial identification header packet
       * @param {IPageHeader} header
       * @param {Buffer} pageData
       */
      parseFirstPage(header, pageData) {
        debug("First Ogg/Theora page"), this.metadata.setFormat("codec", "Theora");
        let idHeader = Theora_1.IdentificationHeader.get(pageData, 0);
        this.metadata.setFormat("bitrate", idHeader.nombr);
      }
    };
    exports2.TheoraParser = TheoraParser;
  }
});

// node_modules/music-metadata/lib/ogg/OggParser.js
var require_OggParser = __commonJS({
  "node_modules/music-metadata/lib/ogg/OggParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.OggParser = exports2.SegmentTable = void 0;
    var Token2 = require_lib3(), core_1 = require_core(), debug_1 = require_browser(), util = require_Util(), FourCC_1 = require_FourCC(), BasicParser_1 = require_BasicParser(), VorbisParser_1 = require_VorbisParser(), OpusParser_1 = require_OpusParser(), SpeexParser_1 = require_SpeexParser(), TheoraParser_1 = require_TheoraParser(), debug = (0, debug_1.default)("music-metadata:parser:ogg"), SegmentTable = class _SegmentTable {
      static sum(buf, off, len) {
        let s = 0;
        for (let i = off; i < off + len; ++i)
          s += buf[i];
        return s;
      }
      constructor(header) {
        this.len = header.page_segments;
      }
      get(buf, off) {
        return {
          totalPageSize: _SegmentTable.sum(buf, off, this.len)
        };
      }
    };
    exports2.SegmentTable = SegmentTable;
    var OggParser = class _OggParser extends BasicParser_1.BasicParser {
      /**
       * Parse page
       * @returns {Promise<void>}
       */
      async parse() {
        debug("pos=%s, parsePage()", this.tokenizer.position);
        try {
          let header;
          do {
            if (header = await this.tokenizer.readToken(_OggParser.Header), header.capturePattern !== "OggS")
              throw new Error("Invalid Ogg capture pattern");
            this.metadata.setFormat("container", "Ogg"), this.header = header, this.pageNumber = header.pageSequenceNo, debug("page#=%s, Ogg.id=%s", header.pageSequenceNo, header.capturePattern);
            let segmentTable = await this.tokenizer.readToken(new SegmentTable(header));
            debug("totalPageSize=%s", segmentTable.totalPageSize);
            let pageData = await this.tokenizer.readToken(new Token2.Uint8ArrayType(segmentTable.totalPageSize));
            if (debug("firstPage=%s, lastPage=%s, continued=%s", header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued), header.headerType.firstPage) {
              let id = new Token2.StringType(7, "ascii").get(Buffer.from(pageData), 0);
              switch (id) {
                case "vorbis":
                  debug("Set page consumer to Ogg/Vorbis"), this.pageConsumer = new VorbisParser_1.VorbisParser(this.metadata, this.options);
                  break;
                case "OpusHea":
                  debug("Set page consumer to Ogg/Opus"), this.pageConsumer = new OpusParser_1.OpusParser(this.metadata, this.options, this.tokenizer);
                  break;
                case "Speex  ":
                  debug("Set page consumer to Ogg/Speex"), this.pageConsumer = new SpeexParser_1.SpeexParser(this.metadata, this.options, this.tokenizer);
                  break;
                case "fishead":
                case "\0theora":
                  debug("Set page consumer to Ogg/Theora"), this.pageConsumer = new TheoraParser_1.TheoraParser(this.metadata, this.options, this.tokenizer);
                  break;
                default:
                  throw new Error("gg audio-codec not recognized (id=" + id + ")");
              }
            }
            this.pageConsumer.parsePage(header, pageData);
          } while (!header.headerType.lastPage);
        } catch (err) {
          if (err instanceof core_1.EndOfStreamError)
            this.metadata.addWarning("Last OGG-page is not marked with last-page flag"), debug("End-of-stream"), this.metadata.addWarning("Last OGG-page is not marked with last-page flag"), this.header && this.pageConsumer.calculateDuration(this.header);
          else if (err.message.startsWith("FourCC"))
            this.pageNumber > 0 && (this.metadata.addWarning("Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag"), this.pageConsumer.flush());
          else
            throw err;
        }
      }
    };
    OggParser.Header = {
      len: 27,
      get: (buf, off) => ({
        capturePattern: FourCC_1.FourCcToken.get(buf, off),
        version: Token2.UINT8.get(buf, off + 4),
        headerType: {
          continued: util.getBit(buf, off + 5, 0),
          firstPage: util.getBit(buf, off + 5, 1),
          lastPage: util.getBit(buf, off + 5, 2)
        },
        // packet_flag: buf.readUInt8(off + 5),
        absoluteGranulePosition: Number(Token2.UINT64_LE.get(buf, off + 6)),
        streamSerialNumber: Token2.UINT32_LE.get(buf, off + 14),
        pageSequenceNo: Token2.UINT32_LE.get(buf, off + 18),
        pageChecksum: Token2.UINT32_LE.get(buf, off + 22),
        page_segments: Token2.UINT8.get(buf, off + 26)
      })
    };
    exports2.OggParser = OggParser;
  }
});

// node_modules/music-metadata/lib/riff/RiffChunk.js
var require_RiffChunk = __commonJS({
  "node_modules/music-metadata/lib/riff/RiffChunk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ListInfoTagValue = exports2.Header = void 0;
    var Token2 = require_lib3();
    exports2.Header = {
      len: 8,
      get: (buf, off) => ({
        // Group-ID
        chunkID: buf.toString("binary", off, off + 4),
        // Size
        chunkSize: Token2.UINT32_LE.get(buf, 4)
      })
    };
    var ListInfoTagValue = class {
      constructor(tagHeader) {
        this.tagHeader = tagHeader, this.len = tagHeader.chunkSize, this.len += this.len & 1;
      }
      get(buf, off) {
        return new Token2.StringType(this.tagHeader.chunkSize, "ascii").get(buf, off);
      }
    };
    exports2.ListInfoTagValue = ListInfoTagValue;
  }
});

// node_modules/music-metadata/lib/wav/WaveChunk.js
var require_WaveChunk = __commonJS({
  "node_modules/music-metadata/lib/wav/WaveChunk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.FactChunk = exports2.Format = exports2.WaveFormat = void 0;
    var WaveFormat;
    (function(WaveFormat2) {
      WaveFormat2[WaveFormat2.PCM = 1] = "PCM", WaveFormat2[WaveFormat2.ADPCM = 2] = "ADPCM", WaveFormat2[WaveFormat2.IEEE_FLOAT = 3] = "IEEE_FLOAT", WaveFormat2[WaveFormat2.MPEG_ADTS_AAC = 5632] = "MPEG_ADTS_AAC", WaveFormat2[WaveFormat2.MPEG_LOAS = 5634] = "MPEG_LOAS", WaveFormat2[WaveFormat2.RAW_AAC1 = 255] = "RAW_AAC1", WaveFormat2[WaveFormat2.DOLBY_AC3_SPDIF = 146] = "DOLBY_AC3_SPDIF", WaveFormat2[WaveFormat2.DVM = 8192] = "DVM", WaveFormat2[WaveFormat2.RAW_SPORT = 576] = "RAW_SPORT", WaveFormat2[WaveFormat2.ESST_AC3 = 577] = "ESST_AC3", WaveFormat2[WaveFormat2.DRM = 9] = "DRM", WaveFormat2[WaveFormat2.DTS2 = 8193] = "DTS2", WaveFormat2[WaveFormat2.MPEG = 80] = "MPEG";
    })(WaveFormat = exports2.WaveFormat || (exports2.WaveFormat = {}));
    var Format = class {
      constructor(header) {
        if (header.chunkSize < 16)
          throw new Error("Invalid chunk size");
        this.len = header.chunkSize;
      }
      get(buf, off) {
        return {
          wFormatTag: buf.readUInt16LE(off),
          nChannels: buf.readUInt16LE(off + 2),
          nSamplesPerSec: buf.readUInt32LE(off + 4),
          nAvgBytesPerSec: buf.readUInt32LE(off + 8),
          nBlockAlign: buf.readUInt16LE(off + 12),
          wBitsPerSample: buf.readUInt16LE(off + 14)
        };
      }
    };
    exports2.Format = Format;
    var FactChunk = class {
      constructor(header) {
        if (header.chunkSize < 4)
          throw new Error("Invalid fact chunk size.");
        this.len = header.chunkSize;
      }
      get(buf, off) {
        return {
          dwSampleLength: buf.readUInt32LE(off)
        };
      }
    };
    exports2.FactChunk = FactChunk;
  }
});

// node_modules/music-metadata/lib/wav/BwfChunk.js
var require_BwfChunk = __commonJS({
  "node_modules/music-metadata/lib/wav/BwfChunk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.BroadcastAudioExtensionChunk = void 0;
    var Token2 = require_lib3(), Util_1 = require_Util();
    exports2.BroadcastAudioExtensionChunk = {
      len: 420,
      get: (uint8array, off) => ({
        description: (0, Util_1.stripNulls)(new Token2.StringType(256, "ascii").get(uint8array, off)).trim(),
        originator: (0, Util_1.stripNulls)(new Token2.StringType(32, "ascii").get(uint8array, off + 256)).trim(),
        originatorReference: (0, Util_1.stripNulls)(new Token2.StringType(32, "ascii").get(uint8array, off + 288)).trim(),
        originationDate: (0, Util_1.stripNulls)(new Token2.StringType(10, "ascii").get(uint8array, off + 320)).trim(),
        originationTime: (0, Util_1.stripNulls)(new Token2.StringType(8, "ascii").get(uint8array, off + 330)).trim(),
        timeReferenceLow: Token2.UINT32_LE.get(uint8array, off + 338),
        timeReferenceHigh: Token2.UINT32_LE.get(uint8array, off + 342),
        version: Token2.UINT16_LE.get(uint8array, off + 346),
        umid: new Token2.Uint8ArrayType(64).get(uint8array, off + 348),
        loudnessValue: Token2.UINT16_LE.get(uint8array, off + 412),
        maxTruePeakLevel: Token2.UINT16_LE.get(uint8array, off + 414),
        maxMomentaryLoudness: Token2.UINT16_LE.get(uint8array, off + 416),
        maxShortTermLoudness: Token2.UINT16_LE.get(uint8array, off + 418)
      })
    };
  }
});

// node_modules/music-metadata/lib/wav/WaveParser.js
var require_WaveParser = __commonJS({
  "node_modules/music-metadata/lib/wav/WaveParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.WaveParser = void 0;
    var strtok32 = require_core(), Token2 = require_lib3(), debug_1 = require_browser(), riff = require_RiffChunk(), WaveChunk = require_WaveChunk(), ID3v2Parser_1 = require_ID3v2Parser(), util = require_Util(), FourCC_1 = require_FourCC(), BasicParser_1 = require_BasicParser(), BwfChunk_1 = require_BwfChunk(), debug = (0, debug_1.default)("music-metadata:parser:RIFF"), WaveParser = class extends BasicParser_1.BasicParser {
      async parse() {
        let riffHeader = await this.tokenizer.readToken(riff.Header);
        if (debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`), riffHeader.chunkID === "RIFF")
          return this.parseRiffChunk(riffHeader.chunkSize).catch((err) => {
            if (!(err instanceof strtok32.EndOfStreamError))
              throw err;
          });
      }
      async parseRiffChunk(chunkSize) {
        let type = await this.tokenizer.readToken(FourCC_1.FourCcToken);
        switch (this.metadata.setFormat("container", type), type) {
          case "WAVE":
            return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);
          default:
            throw new Error(`Unsupported RIFF format: RIFF/${type}`);
        }
      }
      async readWaveChunk(remaining) {
        for (; remaining >= riff.Header.len; ) {
          let header = await this.tokenizer.readToken(riff.Header);
          switch (remaining -= riff.Header.len + header.chunkSize, header.chunkSize > remaining && this.metadata.addWarning("Data chunk size exceeds file size"), this.header = header, debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`), header.chunkID) {
            case "LIST":
              await this.parseListTag(header);
              break;
            case "fact":
              this.metadata.setFormat("lossless", !1), this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));
              break;
            case "fmt ":
              let fmt = await this.tokenizer.readToken(new WaveChunk.Format(header)), subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];
              subFormat || (debug("WAVE/non-PCM format=" + fmt.wFormatTag), subFormat = "non-PCM (" + fmt.wFormatTag + ")"), this.metadata.setFormat("codec", subFormat), this.metadata.setFormat("bitsPerSample", fmt.wBitsPerSample), this.metadata.setFormat("sampleRate", fmt.nSamplesPerSec), this.metadata.setFormat("numberOfChannels", fmt.nChannels), this.metadata.setFormat("bitrate", fmt.nBlockAlign * fmt.nSamplesPerSec * 8), this.blockAlign = fmt.nBlockAlign;
              break;
            case "id3 ":
            case "ID3 ":
              let id3_data = await this.tokenizer.readToken(new Token2.Uint8ArrayType(header.chunkSize)), rst = strtok32.fromBuffer(id3_data);
              await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);
              break;
            case "data":
              this.metadata.format.lossless !== !1 && this.metadata.setFormat("lossless", !0);
              let chunkSize = header.chunkSize;
              if (this.tokenizer.fileInfo.size) {
                let calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
                calcRemaining < chunkSize && (this.metadata.addWarning("data chunk length exceeding file length"), chunkSize = calcRemaining);
              }
              let numberOfSamples = this.fact ? this.fact.dwSampleLength : chunkSize === 4294967295 ? void 0 : chunkSize / this.blockAlign;
              numberOfSamples && (this.metadata.setFormat("numberOfSamples", numberOfSamples), this.metadata.setFormat("duration", numberOfSamples / this.metadata.format.sampleRate)), this.metadata.format.codec === "ADPCM" ? this.metadata.setFormat("bitrate", 352e3) : this.metadata.setFormat("bitrate", this.blockAlign * this.metadata.format.sampleRate * 8), await this.tokenizer.ignore(header.chunkSize);
              break;
            case "bext":
              let bext = await this.tokenizer.readToken(BwfChunk_1.BroadcastAudioExtensionChunk);
              Object.keys(bext).forEach((key) => {
                this.metadata.addTag("exif", "bext." + key, bext[key]);
              });
              let bextRemaining = header.chunkSize - BwfChunk_1.BroadcastAudioExtensionChunk.len;
              await this.tokenizer.ignore(bextRemaining);
              break;
            case "\0\0\0\0":
              debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`), this.metadata.addWarning("Ignore chunk: RIFF/" + header.chunkID), await this.tokenizer.ignore(header.chunkSize);
              break;
            default:
              debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`), this.metadata.addWarning("Ignore chunk: RIFF/" + header.chunkID), await this.tokenizer.ignore(header.chunkSize);
          }
          this.header.chunkSize % 2 === 1 && (debug("Read odd padding byte"), await this.tokenizer.ignore(1));
        }
      }
      async parseListTag(listHeader) {
        let listType = await this.tokenizer.readToken(new Token2.StringType(4, "binary"));
        switch (debug("pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s", this.tokenizer.position, listType), listType) {
          case "INFO":
            return this.parseRiffInfoTags(listHeader.chunkSize - 4);
          case "adtl":
          default:
            return this.metadata.addWarning("Ignore chunk: RIFF/WAVE/LIST/" + listType), debug("Ignoring chunkID=RIFF/WAVE/LIST/" + listType), this.tokenizer.ignore(listHeader.chunkSize - 4).then();
        }
      }
      async parseRiffInfoTags(chunkSize) {
        for (; chunkSize >= 8; ) {
          let header = await this.tokenizer.readToken(riff.Header), valueToken = new riff.ListInfoTagValue(header), value = await this.tokenizer.readToken(valueToken);
          this.addTag(header.chunkID, util.stripNulls(value)), chunkSize -= 8 + valueToken.len;
        }
        if (chunkSize !== 0)
          throw Error("Illegal remaining size: " + chunkSize);
      }
      addTag(id, value) {
        this.metadata.addTag("exif", id, value);
      }
    };
    exports2.WaveParser = WaveParser;
  }
});

// node_modules/music-metadata/lib/wavpack/WavPackToken.js
var require_WavPackToken = __commonJS({
  "node_modules/music-metadata/lib/wavpack/WavPackToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.WavPack = void 0;
    var Token2 = require_lib3(), FourCC_1 = require_FourCC(), SampleRates = [
      6e3,
      8e3,
      9600,
      11025,
      12e3,
      16e3,
      22050,
      24e3,
      32e3,
      44100,
      48e3,
      64e3,
      88200,
      96e3,
      192e3,
      -1
    ], WavPack = class _WavPack {
      static isBitSet(flags, bitOffset) {
        return _WavPack.getBitAllignedNumber(flags, bitOffset, 1) === 1;
      }
      static getBitAllignedNumber(flags, bitOffset, len) {
        return flags >>> bitOffset & 4294967295 >>> 32 - len;
      }
    };
    WavPack.BlockHeaderToken = {
      len: 32,
      get: (buf, off) => {
        let flags = Token2.UINT32_LE.get(buf, off + 24), res = {
          // should equal 'wvpk'
          BlockID: FourCC_1.FourCcToken.get(buf, off),
          //  0x402 to 0x410 are valid for decode
          blockSize: Token2.UINT32_LE.get(buf, off + 4),
          //  0x402 (1026) to 0x410 are valid for decode
          version: Token2.UINT16_LE.get(buf, off + 8),
          //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
          totalSamples: (
            /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */
            Token2.UINT32_LE.get(buf, off + 12)
          ),
          // 40-bit block_index
          blockIndex: (
            /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */
            Token2.UINT32_LE.get(buf, off + 16)
          ),
          // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
          blockSamples: Token2.UINT32_LE.get(buf, off + 20),
          // various flags for id and decoding
          flags: {
            bitsPerSample: (1 + WavPack.getBitAllignedNumber(flags, 0, 2)) * 8,
            isMono: WavPack.isBitSet(flags, 2),
            isHybrid: WavPack.isBitSet(flags, 3),
            isJointStereo: WavPack.isBitSet(flags, 4),
            crossChannel: WavPack.isBitSet(flags, 5),
            hybridNoiseShaping: WavPack.isBitSet(flags, 6),
            floatingPoint: WavPack.isBitSet(flags, 7),
            samplingRate: SampleRates[WavPack.getBitAllignedNumber(flags, 23, 4)],
            isDSD: WavPack.isBitSet(flags, 31)
          },
          // crc for actual decoded data
          crc: new Token2.Uint8ArrayType(4).get(buf, off + 28)
        };
        return res.flags.isDSD && (res.totalSamples *= 8), res;
      }
    };
    WavPack.MetadataIdToken = {
      len: 1,
      get: (buf, off) => ({
        functionId: WavPack.getBitAllignedNumber(buf[off], 0, 6),
        isOptional: WavPack.isBitSet(buf[off], 5),
        isOddSize: WavPack.isBitSet(buf[off], 6),
        largeBlock: WavPack.isBitSet(buf[off], 7)
      })
    };
    exports2.WavPack = WavPack;
  }
});

// node_modules/music-metadata/lib/wavpack/WavPackParser.js
var require_WavPackParser = __commonJS({
  "node_modules/music-metadata/lib/wavpack/WavPackParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.WavPackParser = void 0;
    var Token2 = require_lib3(), APEv2Parser_1 = require_APEv2Parser(), FourCC_1 = require_FourCC(), BasicParser_1 = require_BasicParser(), WavPackToken_1 = require_WavPackToken(), debug_1 = require_browser(), debug = (0, debug_1.default)("music-metadata:parser:WavPack"), WavPackParser = class extends BasicParser_1.BasicParser {
      async parse() {
        return this.audioDataSize = 0, await this.parseWavPackBlocks(), APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
      }
      async parseWavPackBlocks() {
        do {
          if (await this.tokenizer.peekToken(FourCC_1.FourCcToken) !== "wvpk")
            break;
          let header = await this.tokenizer.readToken(WavPackToken_1.WavPack.BlockHeaderToken);
          if (header.BlockID !== "wvpk")
            throw new Error("Invalid WavPack Block-ID");
          debug(`WavPack header blockIndex=${header.blockIndex}, len=${WavPackToken_1.WavPack.BlockHeaderToken.len}`), header.blockIndex === 0 && !this.metadata.format.container && (this.metadata.setFormat("container", "WavPack"), this.metadata.setFormat("lossless", !header.flags.isHybrid), this.metadata.setFormat("bitsPerSample", header.flags.bitsPerSample), header.flags.isDSD || (this.metadata.setFormat("sampleRate", header.flags.samplingRate), this.metadata.setFormat("duration", header.totalSamples / header.flags.samplingRate)), this.metadata.setFormat("numberOfChannels", header.flags.isMono ? 1 : 2), this.metadata.setFormat("numberOfSamples", header.totalSamples), this.metadata.setFormat("codec", header.flags.isDSD ? "DSD" : "PCM"));
          let ignoreBytes = header.blockSize - (WavPackToken_1.WavPack.BlockHeaderToken.len - 8);
          await (header.blockIndex === 0 ? this.parseMetadataSubBlock(header, ignoreBytes) : this.tokenizer.ignore(ignoreBytes)), header.blockSamples > 0 && (this.audioDataSize += header.blockSize);
        } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= WavPackToken_1.WavPack.BlockHeaderToken.len);
        this.metadata.setFormat("bitrate", this.audioDataSize * 8 / this.metadata.format.duration);
      }
      /**
       * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks
       * @param remainingLength
       */
      async parseMetadataSubBlock(header, remainingLength) {
        for (; remainingLength > WavPackToken_1.WavPack.MetadataIdToken.len; ) {
          let id = await this.tokenizer.readToken(WavPackToken_1.WavPack.MetadataIdToken), dataSizeInWords = await this.tokenizer.readNumber(id.largeBlock ? Token2.UINT24_LE : Token2.UINT8), data = Buffer.alloc(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));
          switch (await this.tokenizer.readBuffer(data), debug(`Metadata Sub-Blocks functionId=0x${id.functionId.toString(16)}, id.largeBlock=${id.largeBlock},data-size=${data.length}`), id.functionId) {
            case 0:
              break;
            case 14:
              debug("ID_DSD_BLOCK");
              let mp = 1 << data.readUInt8(0), samplingRate = header.flags.samplingRate * mp * 8;
              if (!header.flags.isDSD)
                throw new Error("Only expect DSD block if DSD-flag is set");
              this.metadata.setFormat("sampleRate", samplingRate), this.metadata.setFormat("duration", header.totalSamples / samplingRate);
              break;
            case 36:
              debug("ID_ALT_TRAILER: trailer for non-wav files");
              break;
            case 38:
              this.metadata.setFormat("audioMD5", data);
              break;
            case 47:
              debug(`ID_BLOCK_CHECKSUM: checksum=${data.toString("hex")}`);
              break;
            default:
              debug(`Ignore unsupported meta-sub-block-id functionId=0x${id.functionId.toString(16)}`);
              break;
          }
          remainingLength -= WavPackToken_1.WavPack.MetadataIdToken.len + (id.largeBlock ? Token2.UINT24_LE.len : Token2.UINT8.len) + dataSizeInWords * 2, debug(`remainingLength=${remainingLength}`), id.isOddSize && this.tokenizer.ignore(1);
        }
        if (remainingLength !== 0)
          throw new Error("metadata-sub-block should fit it remaining length");
      }
    };
    exports2.WavPackParser = WavPackParser;
  }
});

// node_modules/music-metadata/lib/dsf/DsfChunk.js
var require_DsfChunk = __commonJS({
  "node_modules/music-metadata/lib/dsf/DsfChunk.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.FormatChunk = exports2.ChannelType = exports2.DsdChunk = exports2.ChunkHeader = void 0;
    var Token2 = require_lib3(), FourCC_1 = require_FourCC();
    exports2.ChunkHeader = {
      len: 12,
      get: (buf, off) => ({ id: FourCC_1.FourCcToken.get(buf, off), size: Token2.UINT64_LE.get(buf, off + 4) })
    };
    exports2.DsdChunk = {
      len: 16,
      get: (buf, off) => ({
        fileSize: Token2.INT64_LE.get(buf, off),
        metadataPointer: Token2.INT64_LE.get(buf, off + 8)
      })
    };
    var ChannelType;
    (function(ChannelType2) {
      ChannelType2[ChannelType2.mono = 1] = "mono", ChannelType2[ChannelType2.stereo = 2] = "stereo", ChannelType2[ChannelType2.channels = 3] = "channels", ChannelType2[ChannelType2.quad = 4] = "quad", ChannelType2[ChannelType2["4 channels"] = 5] = "4 channels", ChannelType2[ChannelType2["5 channels"] = 6] = "5 channels", ChannelType2[ChannelType2["5.1 channels"] = 7] = "5.1 channels";
    })(ChannelType = exports2.ChannelType || (exports2.ChannelType = {}));
    exports2.FormatChunk = {
      len: 40,
      get: (buf, off) => ({
        formatVersion: Token2.INT32_LE.get(buf, off),
        formatID: Token2.INT32_LE.get(buf, off + 4),
        channelType: Token2.INT32_LE.get(buf, off + 8),
        channelNum: Token2.INT32_LE.get(buf, off + 12),
        samplingFrequency: Token2.INT32_LE.get(buf, off + 16),
        bitsPerSample: Token2.INT32_LE.get(buf, off + 20),
        sampleCount: Token2.INT64_LE.get(buf, off + 24),
        blockSizePerChannel: Token2.INT32_LE.get(buf, off + 32)
      })
    };
  }
});

// node_modules/music-metadata/lib/dsf/DsfParser.js
var require_DsfParser = __commonJS({
  "node_modules/music-metadata/lib/dsf/DsfParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DsfParser = void 0;
    var debug_1 = require_browser(), AbstractID3Parser_1 = require_AbstractID3Parser(), DsfChunk_1 = require_DsfChunk(), ID3v2Parser_1 = require_ID3v2Parser(), debug = (0, debug_1.default)("music-metadata:parser:DSF"), DsfParser = class extends AbstractID3Parser_1.AbstractID3Parser {
      async postId3v2Parse() {
        let p0 = this.tokenizer.position, chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
        if (chunkHeader.id !== "DSD ")
          throw new Error("Invalid chunk signature");
        this.metadata.setFormat("container", "DSF"), this.metadata.setFormat("lossless", !0);
        let dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);
        if (dsdChunk.metadataPointer === BigInt(0))
          debug("No ID3v2 tag present");
        else
          return debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`), await this.parseChunks(dsdChunk.fileSize - chunkHeader.size), await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0), new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);
      }
      async parseChunks(bytesRemaining) {
        for (; bytesRemaining >= DsfChunk_1.ChunkHeader.len; ) {
          let chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
          switch (debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`), chunkHeader.id) {
            case "fmt ":
              let formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);
              this.metadata.setFormat("numberOfChannels", formatChunk.channelNum), this.metadata.setFormat("sampleRate", formatChunk.samplingFrequency), this.metadata.setFormat("bitsPerSample", formatChunk.bitsPerSample), this.metadata.setFormat("numberOfSamples", formatChunk.sampleCount), this.metadata.setFormat("duration", Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);
              let bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;
              this.metadata.setFormat("bitrate", bitrate);
              return;
            default:
              this.tokenizer.ignore(Number(chunkHeader.size) - DsfChunk_1.ChunkHeader.len);
              break;
          }
          bytesRemaining -= chunkHeader.size;
        }
      }
    };
    exports2.DsfParser = DsfParser;
  }
});

// node_modules/music-metadata/lib/dsdiff/DsdiffToken.js
var require_DsdiffToken = __commonJS({
  "node_modules/music-metadata/lib/dsdiff/DsdiffToken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ChunkHeader64 = void 0;
    var Token2 = require_lib3(), FourCC_1 = require_FourCC();
    exports2.ChunkHeader64 = {
      len: 12,
      get: (buf, off) => ({
        // Group-ID
        chunkID: FourCC_1.FourCcToken.get(buf, off),
        // Size
        chunkSize: Token2.INT64_BE.get(buf, off + 4)
      })
    };
  }
});

// node_modules/music-metadata/lib/dsdiff/DsdiffParser.js
var require_DsdiffParser = __commonJS({
  "node_modules/music-metadata/lib/dsdiff/DsdiffParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DsdiffParser = void 0;
    var Token2 = require_lib3(), debug_1 = require_browser(), strtok32 = require_core(), FourCC_1 = require_FourCC(), BasicParser_1 = require_BasicParser(), ID3v2Parser_1 = require_ID3v2Parser(), DsdiffToken_1 = require_DsdiffToken(), debug = (0, debug_1.default)("music-metadata:parser:aiff"), DsdiffParser = class extends BasicParser_1.BasicParser {
      async parse() {
        let header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
        if (header.chunkID !== "FRM8")
          throw new Error("Unexpected chunk-ID");
        let type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();
        switch (type) {
          case "DSD":
            return this.metadata.setFormat("container", `DSDIFF/${type}`), this.metadata.setFormat("lossless", !0), this.readFmt8Chunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));
          default:
            throw Error(`Unsupported DSDIFF type: ${type}`);
        }
      }
      async readFmt8Chunks(remainingSize) {
        for (; remainingSize >= DsdiffToken_1.ChunkHeader64.len; ) {
          let chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
          debug(`Chunk id=${chunkHeader.chunkID}`), await this.readData(chunkHeader), remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + chunkHeader.chunkSize;
        }
      }
      async readData(header) {
        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
        let p0 = this.tokenizer.position;
        switch (header.chunkID.trim()) {
          case "FVER":
            let version = await this.tokenizer.readToken(Token2.UINT32_LE);
            debug(`DSDIFF version=${version}`);
            break;
          case "PROP":
            if (await this.tokenizer.readToken(FourCC_1.FourCcToken) !== "SND ")
              throw new Error("Unexpected PROP-chunk ID");
            await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));
            break;
          case "ID3":
            let id3_data = await this.tokenizer.readToken(new Token2.Uint8ArrayType(Number(header.chunkSize))), rst = strtok32.fromBuffer(id3_data);
            await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);
            break;
          default:
            debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
            break;
          case "DSD":
            this.metadata.setFormat("numberOfSamples", Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels))), this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
            break;
        }
        let remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);
        remaining > 0 && (debug(`After Parsing chunk, remaining ${remaining} bytes`), await this.tokenizer.ignore(Number(remaining)));
      }
      async handleSoundPropertyChunks(remainingSize) {
        for (debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`); remainingSize > 0; ) {
          let sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);
          debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
          let p0 = this.tokenizer.position;
          switch (sndPropHeader.chunkID.trim()) {
            case "FS":
              let sampleRate = await this.tokenizer.readToken(Token2.UINT32_BE);
              this.metadata.setFormat("sampleRate", sampleRate);
              break;
            case "CHNL":
              let numChannels = await this.tokenizer.readToken(Token2.UINT16_BE);
              this.metadata.setFormat("numberOfChannels", numChannels), await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token2.UINT16_BE.len));
              break;
            case "CMPR":
              let compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim(), count = await this.tokenizer.readToken(Token2.UINT8), compressionName = await this.tokenizer.readToken(new Token2.StringType(count, "ascii"));
              compressionIdCode === "DSD" && (this.metadata.setFormat("lossless", !0), this.metadata.setFormat("bitsPerSample", 1)), this.metadata.setFormat("codec", `${compressionIdCode} (${compressionName})`);
              break;
            case "ABSS":
              let hours = await this.tokenizer.readToken(Token2.UINT16_BE), minutes = await this.tokenizer.readToken(Token2.UINT8), seconds = await this.tokenizer.readToken(Token2.UINT8), samples = await this.tokenizer.readToken(Token2.UINT32_BE);
              debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);
              break;
            case "LSCO":
              let lsConfig = await this.tokenizer.readToken(Token2.UINT16_BE);
              debug(`LSCO lsConfig=${lsConfig}`);
              break;
            case "COMT":
            default:
              debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`), await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));
          }
          let remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);
          remaining > 0 && (debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`), await this.tokenizer.ignore(Number(remaining))), remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + sndPropHeader.chunkSize, debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
        }
        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {
          let bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;
          this.metadata.setFormat("bitrate", bitrate);
        }
      }
      async handleChannelChunks(remainingSize) {
        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);
        let channels = [];
        for (; remainingSize >= FourCC_1.FourCcToken.len; ) {
          let channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);
          debug(`Channel[ID=${channelId}]`), channels.push(channelId), remainingSize -= BigInt(FourCC_1.FourCcToken.len);
        }
        return debug(`Channels: ${channels.join(", ")}`), channels;
      }
    };
    exports2.DsdiffParser = DsdiffParser;
  }
});

// node_modules/music-metadata/lib/matroska/MatroskaDtd.js
var require_MatroskaDtd = __commonJS({
  "node_modules/music-metadata/lib/matroska/MatroskaDtd.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.elements = void 0;
    var types_1 = require_types();
    exports2.elements = {
      440786851: {
        name: "ebml",
        container: {
          17030: { name: "ebmlVersion", value: types_1.DataType.uint },
          17143: { name: "ebmlReadVersion", value: types_1.DataType.uint },
          17138: { name: "ebmlMaxIDWidth", value: types_1.DataType.uint },
          17139: { name: "ebmlMaxSizeWidth", value: types_1.DataType.uint },
          17026: { name: "docType", value: types_1.DataType.string },
          17031: { name: "docTypeVersion", value: types_1.DataType.uint },
          17029: { name: "docTypeReadVersion", value: types_1.DataType.uint }
          // 5.1.7
        }
      },
      // Matroska segments
      408125543: {
        name: "segment",
        container: {
          // Meta Seek Information
          290298740: {
            name: "seekHead",
            container: {
              19899: {
                name: "seek",
                container: {
                  21419: { name: "seekId", value: types_1.DataType.binary },
                  21420: { name: "seekPosition", value: types_1.DataType.uint }
                }
              }
            }
          },
          // Segment Information
          357149030: {
            name: "info",
            container: {
              29604: { name: "uid", value: types_1.DataType.uid },
              29572: { name: "filename", value: types_1.DataType.string },
              3979555: { name: "prevUID", value: types_1.DataType.uid },
              3965867: { name: "prevFilename", value: types_1.DataType.string },
              4110627: { name: "nextUID", value: types_1.DataType.uid },
              4096955: { name: "nextFilename", value: types_1.DataType.string },
              2807729: { name: "timecodeScale", value: types_1.DataType.uint },
              17545: { name: "duration", value: types_1.DataType.float },
              17505: { name: "dateUTC", value: types_1.DataType.uint },
              31657: { name: "title", value: types_1.DataType.string },
              19840: { name: "muxingApp", value: types_1.DataType.string },
              22337: { name: "writingApp", value: types_1.DataType.string }
            }
          },
          // Cluster
          524531317: {
            name: "cluster",
            multiple: !0,
            container: {
              231: { name: "timecode", value: types_1.DataType.uid },
              163: { name: "unknown", value: types_1.DataType.binary },
              167: { name: "position", value: types_1.DataType.uid },
              171: { name: "prevSize", value: types_1.DataType.uid }
            }
          },
          // Track
          374648427: {
            name: "tracks",
            container: {
              174: {
                name: "entries",
                multiple: !0,
                container: {
                  215: { name: "trackNumber", value: types_1.DataType.uint },
                  29637: { name: "uid", value: types_1.DataType.uid },
                  131: { name: "trackType", value: types_1.DataType.uint },
                  185: { name: "flagEnabled", value: types_1.DataType.bool },
                  136: { name: "flagDefault", value: types_1.DataType.bool },
                  21930: { name: "flagForced", value: types_1.DataType.bool },
                  156: { name: "flagLacing", value: types_1.DataType.bool },
                  28135: { name: "minCache", value: types_1.DataType.uint },
                  28136: { name: "maxCache", value: types_1.DataType.uint },
                  2352003: { name: "defaultDuration", value: types_1.DataType.uint },
                  2306383: { name: "timecodeScale", value: types_1.DataType.float },
                  21358: { name: "name", value: types_1.DataType.string },
                  2274716: { name: "language", value: types_1.DataType.string },
                  134: { name: "codecID", value: types_1.DataType.string },
                  25506: { name: "codecPrivate", value: types_1.DataType.binary },
                  2459272: { name: "codecName", value: types_1.DataType.string },
                  3839639: { name: "codecSettings", value: types_1.DataType.string },
                  3883072: { name: "codecInfoUrl", value: types_1.DataType.string },
                  2536e3: { name: "codecDownloadUrl", value: types_1.DataType.string },
                  170: { name: "codecDecodeAll", value: types_1.DataType.bool },
                  28587: { name: "trackOverlay", value: types_1.DataType.uint },
                  // Video
                  224: {
                    name: "video",
                    container: {
                      154: { name: "flagInterlaced", value: types_1.DataType.bool },
                      21432: { name: "stereoMode", value: types_1.DataType.uint },
                      176: { name: "pixelWidth", value: types_1.DataType.uint },
                      186: { name: "pixelHeight", value: types_1.DataType.uint },
                      21680: { name: "displayWidth", value: types_1.DataType.uint },
                      21690: { name: "displayHeight", value: types_1.DataType.uint },
                      21683: { name: "aspectRatioType", value: types_1.DataType.uint },
                      3061028: { name: "colourSpace", value: types_1.DataType.uint },
                      3126563: { name: "gammaValue", value: types_1.DataType.float }
                    }
                  },
                  // Audio
                  225: {
                    name: "audio",
                    container: {
                      181: { name: "samplingFrequency", value: types_1.DataType.float },
                      30901: { name: "outputSamplingFrequency", value: types_1.DataType.float },
                      159: { name: "channels", value: types_1.DataType.uint },
                      148: { name: "channels", value: types_1.DataType.uint },
                      32123: { name: "channelPositions", value: types_1.DataType.binary },
                      25188: { name: "bitDepth", value: types_1.DataType.uint }
                    }
                  },
                  // Content Encoding
                  28032: {
                    name: "contentEncodings",
                    container: {
                      25152: {
                        name: "contentEncoding",
                        container: {
                          20529: { name: "order", value: types_1.DataType.uint },
                          20530: { name: "scope", value: types_1.DataType.bool },
                          20531: { name: "type", value: types_1.DataType.uint },
                          20532: {
                            name: "contentEncoding",
                            container: {
                              16980: { name: "contentCompAlgo", value: types_1.DataType.uint },
                              16981: { name: "contentCompSettings", value: types_1.DataType.binary }
                            }
                          },
                          20533: {
                            name: "contentEncoding",
                            container: {
                              18401: { name: "contentEncAlgo", value: types_1.DataType.uint },
                              18402: { name: "contentEncKeyID", value: types_1.DataType.binary },
                              18403: { name: "contentSignature ", value: types_1.DataType.binary },
                              18404: { name: "ContentSigKeyID  ", value: types_1.DataType.binary },
                              18405: { name: "contentSigAlgo ", value: types_1.DataType.uint },
                              18406: { name: "contentSigHashAlgo ", value: types_1.DataType.uint }
                            }
                          },
                          25188: { name: "bitDepth", value: types_1.DataType.uint }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          // Cueing Data
          475249515: {
            name: "cues",
            container: {
              187: {
                name: "cuePoint",
                container: {
                  179: { name: "cueTime", value: types_1.DataType.uid },
                  183: {
                    name: "positions",
                    container: {
                      247: { name: "track", value: types_1.DataType.uint },
                      241: { name: "clusterPosition", value: types_1.DataType.uint },
                      21368: { name: "blockNumber", value: types_1.DataType.uint },
                      234: { name: "codecState", value: types_1.DataType.uint },
                      219: {
                        name: "reference",
                        container: {
                          150: { name: "time", value: types_1.DataType.uint },
                          151: { name: "cluster", value: types_1.DataType.uint },
                          21343: { name: "number", value: types_1.DataType.uint },
                          235: { name: "codecState", value: types_1.DataType.uint }
                        }
                      },
                      240: { name: "relativePosition", value: types_1.DataType.uint }
                      // extended
                    }
                  }
                }
              }
            }
          },
          // Attachment
          423732329: {
            name: "attachments",
            container: {
              24999: {
                name: "attachedFiles",
                multiple: !0,
                container: {
                  18046: { name: "description", value: types_1.DataType.string },
                  18030: { name: "name", value: types_1.DataType.string },
                  18016: { name: "mimeType", value: types_1.DataType.string },
                  18012: { name: "data", value: types_1.DataType.binary },
                  18094: { name: "uid", value: types_1.DataType.uid }
                }
              }
            }
          },
          // Chapters
          272869232: {
            name: "chapters",
            container: {
              17849: {
                name: "editionEntry",
                container: {
                  182: {
                    name: "chapterAtom",
                    container: {
                      29636: { name: "uid", value: types_1.DataType.uid },
                      145: { name: "timeStart", value: types_1.DataType.uint },
                      146: { name: "timeEnd", value: types_1.DataType.uid },
                      152: { name: "hidden", value: types_1.DataType.bool },
                      17816: { name: "enabled", value: types_1.DataType.uid },
                      143: {
                        name: "track",
                        container: {
                          137: { name: "trackNumber", value: types_1.DataType.uid },
                          128: {
                            name: "display",
                            container: {
                              133: { name: "string", value: types_1.DataType.string },
                              17276: { name: "language ", value: types_1.DataType.string },
                              17278: { name: "country ", value: types_1.DataType.string }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          // Tagging
          307544935: {
            name: "tags",
            container: {
              29555: {
                name: "tag",
                multiple: !0,
                container: {
                  25536: {
                    name: "target",
                    container: {
                      25541: { name: "tagTrackUID", value: types_1.DataType.uid },
                      25540: { name: "tagChapterUID", value: types_1.DataType.uint },
                      25542: { name: "tagAttachmentUID", value: types_1.DataType.uid },
                      25546: { name: "targetType", value: types_1.DataType.string },
                      26826: { name: "targetTypeValue", value: types_1.DataType.uint },
                      25545: { name: "tagEditionUID", value: types_1.DataType.uid }
                      // extended
                    }
                  },
                  26568: {
                    name: "simpleTags",
                    multiple: !0,
                    container: {
                      17827: { name: "name", value: types_1.DataType.string },
                      17543: { name: "string", value: types_1.DataType.string },
                      17541: { name: "binary", value: types_1.DataType.binary },
                      17530: { name: "language", value: types_1.DataType.string },
                      17531: { name: "languageIETF", value: types_1.DataType.string },
                      17540: { name: "default", value: types_1.DataType.bool }
                      // extended
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/music-metadata/lib/matroska/MatroskaParser.js
var require_MatroskaParser = __commonJS({
  "node_modules/music-metadata/lib/matroska/MatroskaParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MatroskaParser = void 0;
    var token_types_1 = require_lib3(), debug_1 = require_browser(), BasicParser_1 = require_BasicParser(), types_1 = require_types(), matroskaDtd = require_MatroskaDtd(), debug = (0, debug_1.default)("music-metadata:parser:matroska"), MatroskaParser = class extends BasicParser_1.BasicParser {
      constructor() {
        super(), this.padding = 0, this.parserMap = /* @__PURE__ */ new Map(), this.ebmlMaxIDLength = 4, this.ebmlMaxSizeLength = 8, this.parserMap.set(types_1.DataType.uint, (e) => this.readUint(e)), this.parserMap.set(types_1.DataType.string, (e) => this.readString(e)), this.parserMap.set(types_1.DataType.binary, (e) => this.readBuffer(e)), this.parserMap.set(types_1.DataType.uid, async (e) => await this.readUint(e) === 1), this.parserMap.set(types_1.DataType.bool, (e) => this.readFlag(e)), this.parserMap.set(types_1.DataType.float, (e) => this.readFloat(e));
      }
      /**
       * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
       * @param {INativeMetadataCollector} metadata Output
       * @param {ITokenizer} tokenizer Input
       * @param {IOptions} options Parsing options
       */
      init(metadata, tokenizer, options) {
        return super.init(metadata, tokenizer, options), this;
      }
      async parse() {
        let matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);
        if (this.metadata.setFormat("container", `EBML/${matroska.ebml.docType}`), matroska.segment) {
          let info = matroska.segment.info;
          if (info) {
            let timecodeScale = info.timecodeScale ? info.timecodeScale : 1e6;
            if (typeof info.duration == "number") {
              let duration = info.duration * timecodeScale / 1e9;
              this.addTag("segment:title", info.title), this.metadata.setFormat("duration", duration);
            }
          }
          let audioTracks = matroska.segment.tracks;
          if (audioTracks && audioTracks.entries) {
            audioTracks.entries.forEach((entry) => {
              let stream2 = {
                codecName: entry.codecID.replace("A_", "").replace("V_", ""),
                codecSettings: entry.codecSettings,
                flagDefault: entry.flagDefault,
                flagLacing: entry.flagLacing,
                flagEnabled: entry.flagEnabled,
                language: entry.language,
                name: entry.name,
                type: entry.trackType,
                audio: entry.audio,
                video: entry.video
              };
              this.metadata.addStreamInfo(stream2);
            });
            let audioTrack = audioTracks.entries.filter((entry) => entry.trackType === types_1.TrackType.audio.valueOf()).reduce((acc, cur) => !acc || !acc.flagDefault && cur.flagDefault || cur.trackNumber && cur.trackNumber < acc.trackNumber ? cur : acc, null);
            audioTrack && (this.metadata.setFormat("codec", audioTrack.codecID.replace("A_", "")), this.metadata.setFormat("sampleRate", audioTrack.audio.samplingFrequency), this.metadata.setFormat("numberOfChannels", audioTrack.audio.channels)), matroska.segment.tags && matroska.segment.tags.tag.forEach((tag) => {
              let target = tag.target, targetType = target != null && target.targetTypeValue ? types_1.TargetType[target.targetTypeValue] : target != null && target.targetType ? target.targetType : "track";
              tag.simpleTags.forEach((simpleTag) => {
                let value = simpleTag.string ? simpleTag.string : simpleTag.binary;
                this.addTag(`${targetType}:${simpleTag.name}`, value);
              });
            }), matroska.segment.attachments && matroska.segment.attachments.attachedFiles.filter((file) => file.mimeType.startsWith("image/")).map((file) => ({
              data: file.data,
              format: file.mimeType,
              description: file.description,
              name: file.name
            })).forEach((picture) => {
              this.addTag("picture", picture);
            });
          }
        }
      }
      async parseContainer(container, posDone, path3) {
        let tree = {};
        for (; this.tokenizer.position < posDone; ) {
          let element;
          try {
            element = await this.readElement();
          } catch (error) {
            if (error.message === "End-Of-Stream")
              break;
            throw error;
          }
          let type = container[element.id];
          if (type)
            if (debug(`Element: name=${type.name}, container=${!!type.container}`), type.container) {
              let res = await this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path3.concat([type.name]));
              type.multiple ? (tree[type.name] || (tree[type.name] = []), tree[type.name].push(res)) : tree[type.name] = res;
            } else
              tree[type.name] = await this.parserMap.get(type.value)(element);
          else
            switch (element.id) {
              case 236:
                this.padding += element.len, await this.tokenizer.ignore(element.len);
                break;
              default:
                debug(`parseEbml: path=${path3.join("/")}, unknown element: id=${element.id.toString(16)}`), this.padding += element.len, await this.tokenizer.ignore(element.len);
            }
        }
        return tree;
      }
      async readVintData(maxLength) {
        let msb = await this.tokenizer.peekNumber(token_types_1.UINT8), mask = 128, oc = 1;
        for (; !(msb & mask); ) {
          if (oc > maxLength)
            throw new Error("VINT value exceeding maximum size");
          ++oc, mask >>= 1;
        }
        let id = Buffer.alloc(oc);
        return await this.tokenizer.readBuffer(id), id;
      }
      async readElement() {
        let id = await this.readVintData(this.ebmlMaxIDLength), lenField = await this.readVintData(this.ebmlMaxSizeLength);
        lenField[0] ^= 128 >> lenField.length - 1;
        let nrLen = Math.min(6, lenField.length);
        return {
          id: id.readUIntBE(0, id.length),
          len: lenField.readUIntBE(lenField.length - nrLen, nrLen)
        };
      }
      isMaxValue(vintData) {
        if (vintData.length === this.ebmlMaxSizeLength) {
          for (let n = 1; n < this.ebmlMaxSizeLength; ++n)
            if (vintData[n] !== 255)
              return !1;
          return !0;
        }
        return !1;
      }
      async readFloat(e) {
        switch (e.len) {
          case 0:
            return 0;
          case 4:
            return this.tokenizer.readNumber(token_types_1.Float32_BE);
          case 8:
            return this.tokenizer.readNumber(token_types_1.Float64_BE);
          case 10:
            return this.tokenizer.readNumber(token_types_1.Float64_BE);
          default:
            throw new Error(`Invalid IEEE-754 float length: ${e.len}`);
        }
      }
      async readFlag(e) {
        return await this.readUint(e) === 1;
      }
      async readUint(e) {
        let buf = await this.readBuffer(e), nrLen = Math.min(6, e.len);
        return buf.readUIntBE(e.len - nrLen, nrLen);
      }
      async readString(e) {
        return (await this.tokenizer.readToken(new token_types_1.StringType(e.len, "utf-8"))).replace(/\00.*$/g, "");
      }
      async readBuffer(e) {
        let buf = Buffer.alloc(e.len);
        return await this.tokenizer.readBuffer(buf), buf;
      }
      addTag(tagId, value) {
        this.metadata.addTag("matroska", tagId, value);
      }
    };
    exports2.MatroskaParser = MatroskaParser;
  }
});

// node_modules/music-metadata/lib/ParserFactory.js
var require_ParserFactory = __commonJS({
  "node_modules/music-metadata/lib/ParserFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ParserFactory = exports2.parseHttpContentType = void 0;
    var FileType = require_core2(), ContentType = require_content_type(), MimeType = require_media_typer(), debug_1 = require_browser(), MetadataCollector_1 = require_MetadataCollector(), AiffParser_1 = require_AiffParser(), APEv2Parser_1 = require_APEv2Parser(), AsfParser_1 = require_AsfParser(), FlacParser_1 = require_FlacParser(), MP4Parser_1 = require_MP4Parser(), MpegParser_1 = require_MpegParser(), musepack_1 = require_musepack(), OggParser_1 = require_OggParser(), WaveParser_1 = require_WaveParser(), WavPackParser_1 = require_WavPackParser(), DsfParser_1 = require_DsfParser(), DsdiffParser_1 = require_DsdiffParser(), MatroskaParser_1 = require_MatroskaParser(), debug = (0, debug_1.default)("music-metadata:parser:factory");
    function parseHttpContentType(contentType) {
      let type = ContentType.parse(contentType), mime = MimeType.parse(type.type);
      return {
        type: mime.type,
        subtype: mime.subtype,
        suffix: mime.suffix,
        parameters: type.parameters
      };
    }
    exports2.parseHttpContentType = parseHttpContentType;
    async function parse(tokenizer, parserId, opts = {}) {
      let parser = await ParserFactory.loadParser(parserId), metadata = new MetadataCollector_1.MetadataCollector(opts);
      return await parser.init(metadata, tokenizer, opts).parse(), metadata.toCommonMetadata();
    }
    var ParserFactory = class _ParserFactory {
      /**
       * Parse metadata from tokenizer
       * @param tokenizer - Tokenizer
       * @param opts - Options
       * @returns Native metadata
       */
      static async parseOnContentType(tokenizer, opts) {
        let { mimeType, path: path3, url } = await tokenizer.fileInfo, parserId = _ParserFactory.getParserIdForMimeType(mimeType) || _ParserFactory.getParserIdForExtension(path3) || _ParserFactory.getParserIdForExtension(url);
        return parserId || debug("No parser found for MIME-type / extension: " + mimeType), this.parse(tokenizer, parserId, opts);
      }
      static async parse(tokenizer, parserId, opts) {
        if (!parserId) {
          debug("Guess parser on content...");
          let buf = Buffer.alloc(4100);
          if (await tokenizer.peekBuffer(buf, { mayBeLess: !0 }), tokenizer.fileInfo.path && (parserId = this.getParserIdForExtension(tokenizer.fileInfo.path)), !parserId) {
            let guessedType = await FileType.fromBuffer(buf);
            if (!guessedType)
              throw new Error("Failed to determine audio format");
            if (debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`), parserId = _ParserFactory.getParserIdForMimeType(guessedType.mime), !parserId)
              throw new Error("Guessed MIME-type not supported: " + guessedType.mime);
          }
        }
        return parse(tokenizer, parserId, opts);
      }
      /**
       * @param filePath - Path, filename or extension to audio file
       * @return Parser sub-module name
       */
      static getParserIdForExtension(filePath) {
        if (!filePath)
          return;
        switch (this.getExtension(filePath).toLocaleLowerCase() || filePath) {
          case ".mp2":
          case ".mp3":
          case ".m2a":
          case ".aac":
            return "mpeg";
          case ".ape":
            return "apev2";
          case ".mp4":
          case ".m4a":
          case ".m4b":
          case ".m4pa":
          case ".m4v":
          case ".m4r":
          case ".3gp":
            return "mp4";
          case ".wma":
          case ".wmv":
          case ".asf":
            return "asf";
          case ".flac":
            return "flac";
          case ".ogg":
          case ".ogv":
          case ".oga":
          case ".ogm":
          case ".ogx":
          case ".opus":
          case ".spx":
            return "ogg";
          case ".aif":
          case ".aiff":
          case ".aifc":
            return "aiff";
          case ".wav":
          case ".bwf":
            return "riff";
          case ".wv":
          case ".wvp":
            return "wavpack";
          case ".mpc":
            return "musepack";
          case ".dsf":
            return "dsf";
          case ".dff":
            return "dsdiff";
          case ".mka":
          case ".mkv":
          case ".mk3d":
          case ".mks":
          case ".webm":
            return "matroska";
        }
      }
      static async loadParser(moduleName) {
        switch (moduleName) {
          case "aiff":
            return new AiffParser_1.AIFFParser();
          case "adts":
          case "mpeg":
            return new MpegParser_1.MpegParser();
          case "apev2":
            return new APEv2Parser_1.APEv2Parser();
          case "asf":
            return new AsfParser_1.AsfParser();
          case "dsf":
            return new DsfParser_1.DsfParser();
          case "dsdiff":
            return new DsdiffParser_1.DsdiffParser();
          case "flac":
            return new FlacParser_1.FlacParser();
          case "mp4":
            return new MP4Parser_1.MP4Parser();
          case "musepack":
            return new musepack_1.default();
          case "ogg":
            return new OggParser_1.OggParser();
          case "riff":
            return new WaveParser_1.WaveParser();
          case "wavpack":
            return new WavPackParser_1.WavPackParser();
          case "matroska":
            return new MatroskaParser_1.MatroskaParser();
          default:
            throw new Error(`Unknown parser type: ${moduleName}`);
        }
      }
      static getExtension(fname) {
        let i = fname.lastIndexOf(".");
        return i === -1 ? "" : fname.slice(i);
      }
      /**
       * @param httpContentType - HTTP Content-Type, extension, path or filename
       * @returns Parser sub-module name
       */
      static getParserIdForMimeType(httpContentType) {
        let mime;
        try {
          mime = parseHttpContentType(httpContentType);
        } catch (err) {
          debug(`Invalid HTTP Content-Type header value: ${httpContentType}`);
          return;
        }
        let subType = mime.subtype.indexOf("x-") === 0 ? mime.subtype.substring(2) : mime.subtype;
        switch (mime.type) {
          case "audio":
            switch (subType) {
              case "mp3":
              case "mpeg":
                return "mpeg";
              case "aac":
              case "aacp":
                return "adts";
              case "flac":
                return "flac";
              case "ape":
              case "monkeys-audio":
                return "apev2";
              case "mp4":
              case "m4a":
                return "mp4";
              case "ogg":
              case "opus":
              case "speex":
                return "ogg";
              case "ms-wma":
              case "ms-wmv":
              case "ms-asf":
                return "asf";
              case "aiff":
              case "aif":
              case "aifc":
                return "aiff";
              case "vnd.wave":
              case "wav":
              case "wave":
                return "riff";
              case "wavpack":
                return "wavpack";
              case "musepack":
                return "musepack";
              case "matroska":
              case "webm":
                return "matroska";
              case "dsf":
                return "dsf";
            }
            break;
          case "video":
            switch (subType) {
              case "ms-asf":
              case "ms-wmv":
                return "asf";
              case "m4v":
              case "mp4":
                return "mp4";
              case "ogg":
                return "ogg";
              case "matroska":
              case "webm":
                return "matroska";
            }
            break;
          case "application":
            switch (subType) {
              case "vnd.ms-asf":
                return "asf";
              case "ogg":
                return "ogg";
            }
            break;
        }
      }
    };
    exports2.ParserFactory = ParserFactory;
  }
});

// node_modules/music-metadata/lib/common/RandomUint8ArrayReader.js
var require_RandomUint8ArrayReader = __commonJS({
  "node_modules/music-metadata/lib/common/RandomUint8ArrayReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.RandomUint8ArrayReader = void 0;
    var RandomUint8ArrayReader = class {
      constructor(uint8Array) {
        this.uint8Array = uint8Array, this.fileSize = uint8Array.length;
      }
      /**
       * Read from a given position of an abstracted file or buffer.
       * @param uint8Array - Uint8Array that the data will be written to.
       * @param offset - Offset in the buffer to start writing at.
       * @param length - Integer specifying the number of bytes to read.
       * @param position - Specifies where to begin reading from in the file.
       * @return Promise providing bytes read
       */
      async randomRead(uint8Array, offset, length, position) {
        return uint8Array.set(this.uint8Array.subarray(position, position + length), offset), length;
      }
    };
    exports2.RandomUint8ArrayReader = RandomUint8ArrayReader;
  }
});

// node_modules/music-metadata/lib/lyrics3/Lyrics3.js
var require_Lyrics3 = __commonJS({
  "node_modules/music-metadata/lib/lyrics3/Lyrics3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getLyricsHeaderLength = exports2.endTag2 = void 0;
    exports2.endTag2 = "LYRICS200";
    async function getLyricsHeaderLength(reader) {
      if (reader.fileSize >= 143) {
        let buf = Buffer.alloc(15);
        await reader.randomRead(buf, 0, buf.length, reader.fileSize - 143);
        let txt = buf.toString("binary");
        if (txt.substr(6) === exports2.endTag2)
          return parseInt(txt.substr(0, 6), 10) + 15;
      }
      return 0;
    }
    exports2.getLyricsHeaderLength = getLyricsHeaderLength;
  }
});

// node_modules/music-metadata/lib/core.js
var require_core3 = __commonJS({
  "node_modules/music-metadata/lib/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.scanAppendingHeaders = exports2.selectCover = exports2.ratingToStars = exports2.orderTags = exports2.parseFromTokenizer = exports2.parseBuffer = exports2.parseStream = void 0;
    var strtok32 = require_core(), ParserFactory_1 = require_ParserFactory(), RandomUint8ArrayReader_1 = require_RandomUint8ArrayReader(), APEv2Parser_1 = require_APEv2Parser(), ID3v1Parser_1 = require_ID3v1Parser(), Lyrics3_1 = require_Lyrics3();
    function parseStream(stream2, fileInfo, options = {}) {
      return parseFromTokenizer(strtok32.fromStream(stream2, typeof fileInfo == "string" ? { mimeType: fileInfo } : fileInfo), options);
    }
    exports2.parseStream = parseStream;
    async function parseBuffer(uint8Array, fileInfo, options = {}) {
      let bufferReader = new RandomUint8ArrayReader_1.RandomUint8ArrayReader(uint8Array);
      await scanAppendingHeaders(bufferReader, options);
      let tokenizer = strtok32.fromBuffer(uint8Array, typeof fileInfo == "string" ? { mimeType: fileInfo } : fileInfo);
      return parseFromTokenizer(tokenizer, options);
    }
    exports2.parseBuffer = parseBuffer;
    function parseFromTokenizer(tokenizer, options) {
      return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);
    }
    exports2.parseFromTokenizer = parseFromTokenizer;
    function orderTags(nativeTags) {
      let tags = {};
      for (let tag of nativeTags)
        (tags[tag.id] = tags[tag.id] || []).push(tag.value);
      return tags;
    }
    exports2.orderTags = orderTags;
    function ratingToStars(rating) {
      return rating === void 0 ? 0 : 1 + Math.round(rating * 4);
    }
    exports2.ratingToStars = ratingToStars;
    function selectCover(pictures) {
      return pictures ? pictures.reduce((acc, cur) => cur.name && cur.name.toLowerCase() in ["front", "cover", "cover (front)"] ? cur : acc) : null;
    }
    exports2.selectCover = selectCover;
    async function scanAppendingHeaders(randomReader, options = {}) {
      let apeOffset = randomReader.fileSize;
      if (await (0, ID3v1Parser_1.hasID3v1Header)(randomReader)) {
        apeOffset -= 128;
        let lyricsLen = await (0, Lyrics3_1.getLyricsHeaderLength)(randomReader);
        apeOffset -= lyricsLen;
      }
      options.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);
    }
    exports2.scanAppendingHeaders = scanAppendingHeaders;
  }
});

// node_modules/music-metadata/lib/common/RandomFileReader.js
var require_RandomFileReader = __commonJS({
  "node_modules/music-metadata/lib/common/RandomFileReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.RandomFileReader = void 0;
    var fs3 = require("fs"), RandomFileReader = class _RandomFileReader {
      constructor(fileHandle, filePath, fileSize) {
        this.fileHandle = fileHandle, this.filePath = filePath, this.fileSize = fileSize;
      }
      /**
       * Read from a given position of an abstracted file or buffer.
       * @param buffer {Buffer} is the buffer that the data will be written to.
       * @param offset {number} is the offset in the buffer to start writing at.
       * @param length {number}is an integer specifying the number of bytes to read.
       * @param position {number} is an argument specifying where to begin reading from in the file.
       * @return {Promise<number>} bytes read
       */
      async randomRead(buffer, offset, length, position) {
        return (await this.fileHandle.read(buffer, offset, length, position)).bytesRead;
      }
      async close() {
        return this.fileHandle.close();
      }
      static async init(filePath, fileSize) {
        let fileHandle = await fs3.promises.open(filePath, "r");
        return new _RandomFileReader(fileHandle, filePath, fileSize);
      }
    };
    exports2.RandomFileReader = RandomFileReader;
  }
});

// node_modules/music-metadata/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/music-metadata/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ratingToStars = exports2.orderTags = exports2.parseFile = exports2.parseStream = exports2.selectCover = exports2.parseBuffer = exports2.parseFromTokenizer = void 0;
    var strtok32 = require_lib2(), Core = require_core3(), ParserFactory_1 = require_ParserFactory(), debug_1 = require_browser(), RandomFileReader_1 = require_RandomFileReader(), debug = (0, debug_1.default)("music-metadata:parser"), core_1 = require_core3();
    Object.defineProperty(exports2, "parseFromTokenizer", { enumerable: !0, get: function() {
      return core_1.parseFromTokenizer;
    } });
    Object.defineProperty(exports2, "parseBuffer", { enumerable: !0, get: function() {
      return core_1.parseBuffer;
    } });
    Object.defineProperty(exports2, "selectCover", { enumerable: !0, get: function() {
      return core_1.selectCover;
    } });
    async function parseStream(stream2, fileInfo, options = {}) {
      let tokenizer = await strtok32.fromStream(stream2, typeof fileInfo == "string" ? { mimeType: fileInfo } : fileInfo);
      return Core.parseFromTokenizer(tokenizer, options);
    }
    exports2.parseStream = parseStream;
    async function parseFile(filePath, options = {}) {
      debug(`parseFile: ${filePath}`);
      let fileTokenizer = await strtok32.fromFile(filePath), fileReader = await RandomFileReader_1.RandomFileReader.init(filePath, fileTokenizer.fileInfo.size);
      try {
        await Core.scanAppendingHeaders(fileReader, options);
      } finally {
        await fileReader.close();
      }
      try {
        let parserName = ParserFactory_1.ParserFactory.getParserIdForExtension(filePath);
        return parserName || debug(" Parser could not be determined by file extension"), await ParserFactory_1.ParserFactory.parse(fileTokenizer, parserName, options);
      } finally {
        await fileTokenizer.close();
      }
    }
    exports2.parseFile = parseFile;
    exports2.orderTags = Core.orderTags;
    exports2.ratingToStars = Core.ratingToStars;
    exports2.default = {
      parseStream,
      parseFile,
      parseFromTokenizer: Core.parseFromTokenizer,
      parseBuffer: Core.parseBuffer,
      selectCover: Core.selectCover
    };
  }
});

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports2) {
    "use strict";
    var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
    function A(a) {
      return a === null || typeof a != "object" ? null : (a = z && a[z] || a["@@iterator"], typeof a == "function" ? a : null);
    }
    var B = { isMounted: function() {
      return !1;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C = Object.assign, D = {};
    function E(a, b, e) {
      this.props = a, this.context = b, this.refs = D, this.updater = e || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if (typeof a != "object" && typeof a != "function" && a != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a, this.context = b, this.refs = D, this.updater = e || B;
    }
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = !0;
    var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: !0, ref: !0, __self: !0, __source: !0 };
    function M(a, b, e) {
      var d, c = {}, k = null, h = null;
      if (b != null)
        for (d in b.ref !== void 0 && (h = b.ref), b.key !== void 0 && (k = "" + b.key), b)
          J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (g === 1)
        c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++)
          f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps)
        for (d in g = a.defaultProps, g)
          c[d] === void 0 && (c[d] = g[d]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return typeof a == "object" && a !== null && a.$$typeof === l;
    }
    function escape(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    function Q(a, b) {
      return typeof a == "object" && a !== null && a.key != null ? escape("" + a.key) : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      (k === "undefined" || k === "boolean") && (a = null);
      var h = !1;
      if (a === null)
        h = !0;
      else
        switch (k) {
          case "string":
          case "number":
            h = !0;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = !0;
            }
        }
      if (h)
        return h = a, c = c(h), a = d === "" ? "." + Q(h, 0) : d, I(c) ? (e = "", a != null && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : c != null && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      if (h = 0, d = d === "" ? "." : d + ":", I(a))
        for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
      else if (f = A(a), typeof f == "function")
        for (a = f.call(a), g = 0; !(k = a.next()).done; )
          k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
      else if (k === "object")
        throw b = String(a), Error("Objects are not valid as a React child (found: " + (b === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S(a, b, e) {
      if (a == null)
        return a;
      var d = [], c = 0;
      return R(a, d, "", "", function(a2) {
        return b.call(e, a2, c++);
      }), d;
    }
    function T(a) {
      if (a._status === -1) {
        var b = a._result;
        b = b(), b.then(function(b2) {
          (a._status === 0 || a._status === -1) && (a._status = 1, a._result = b2);
        }, function(b2) {
          (a._status === 0 || a._status === -1) && (a._status = 2, a._result = b2);
        }), a._status === -1 && (a._status = 0, a._result = b);
      }
      if (a._status === 1)
        return a._result.default;
      throw a._result;
    }
    var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    function X() {
      throw Error("act(...) is not supported in production builds of React.");
    }
    exports2.Children = { map: S, forEach: function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      return S(a, function() {
        b++;
      }), b;
    }, toArray: function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    exports2.Component = E;
    exports2.Fragment = p;
    exports2.Profiler = r;
    exports2.PureComponent = G;
    exports2.StrictMode = q;
    exports2.Suspense = w;
    exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports2.act = X;
    exports2.cloneElement = function(a, b, e) {
      if (a == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (b != null) {
        if (b.ref !== void 0 && (k = b.ref, h = K.current), b.key !== void 0 && (c = "" + b.key), a.type && a.type.defaultProps)
          var g = a.type.defaultProps;
        for (f in b)
          J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = b[f] === void 0 && g !== void 0 ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (f === 1)
        d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++)
          g[m] = arguments[m + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    exports2.createContext = function(a) {
      return a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, a.Provider = { $$typeof: t, _context: a }, a.Consumer = a;
    };
    exports2.createElement = M;
    exports2.createFactory = function(a) {
      var b = M.bind(null, a);
      return b.type = a, b;
    };
    exports2.createRef = function() {
      return { current: null };
    };
    exports2.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    exports2.isValidElement = O;
    exports2.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports2.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: b === void 0 ? null : b };
    };
    exports2.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports2.unstable_act = X;
    exports2.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    exports2.useContext = function(a) {
      return U.current.useContext(a);
    };
    exports2.useDebugValue = function() {
    };
    exports2.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    exports2.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    exports2.useId = function() {
      return U.current.useId();
    };
    exports2.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    exports2.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports2.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports2.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    exports2.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    exports2.useRef = function(a) {
      return U.current.useRef(a);
    };
    exports2.useState = function(a) {
      return U.current.useState(a);
    };
    exports2.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    exports2.useTransition = function() {
      return U.current.useTransition();
    };
    exports2.version = "18.3.1";
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_react_production_min();
  }
});

// node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS({
  "node_modules/scheduler/cjs/scheduler.production.min.js"(exports2) {
    "use strict";
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a:
        for (; 0 < c; ) {
          var d = c - 1 >>> 1, e = a[d];
          if (0 < g(e, b))
            a[d] = b, a[c] = e, c = d;
          else
            break a;
        }
    }
    function h(a) {
      return a.length === 0 ? null : a[0];
    }
    function k(a) {
      if (a.length === 0)
        return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a:
          for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
            var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
            if (0 > g(C, c))
              n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
            else if (n < e && 0 > g(x, c))
              a[d] = x, a[n] = c, d = n;
            else
              break a;
          }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return c !== 0 ? c : a.id - b.id;
    }
    typeof performance == "object" && typeof performance.now == "function" ? (l = performance, exports2.unstable_now = function() {
      return l.now();
    }) : (p = Date, q = p.now(), exports2.unstable_now = function() {
      return p.now() - q;
    });
    var l, p, q, r = [], t = [], u = 1, v = null, y = 3, z = !1, A = !1, B = !1, D = typeof setTimeout == "function" ? setTimeout : null, E = typeof clearTimeout == "function" ? clearTimeout : null, F = typeof setImmediate != "undefined" ? setImmediate : null;
    typeof navigator != "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h(t); b !== null; ) {
        if (b.callback === null)
          k(t);
        else if (b.startTime <= a)
          k(t), b.sortIndex = b.expirationTime, f(r, b);
        else
          break;
        b = h(t);
      }
    }
    function H(a) {
      if (B = !1, G(a), !A)
        if (h(r) !== null)
          A = !0, I(J);
        else {
          var b = h(t);
          b !== null && K(H, b.startTime - a);
        }
    }
    function J(a, b) {
      A = !1, B && (B = !1, E(L), L = -1), z = !0;
      var c = y;
      try {
        for (G(b), v = h(r); v !== null && (!(v.expirationTime > b) || a && !M()); ) {
          var d = v.callback;
          if (typeof d == "function") {
            v.callback = null, y = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports2.unstable_now(), typeof e == "function" ? v.callback = e : v === h(r) && k(r), G(b);
          } else
            k(r);
          v = h(r);
        }
        if (v !== null)
          var w = !0;
        else {
          var m = h(t);
          m !== null && K(H, m.startTime - b), w = !1;
        }
        return w;
      } finally {
        v = null, y = c, z = !1;
      }
    }
    var N = !1, O = null, L = -1, P = 5, Q = -1;
    function M() {
      return !(exports2.unstable_now() - Q < P);
    }
    function R() {
      if (O !== null) {
        var a = exports2.unstable_now();
        Q = a;
        var b = !0;
        try {
          b = O(!0, a);
        } finally {
          b ? S() : (N = !1, O = null);
        }
      } else
        N = !1;
    }
    var S;
    typeof F == "function" ? S = function() {
      F(R);
    } : typeof MessageChannel != "undefined" ? (T = new MessageChannel(), U = T.port2, T.port1.onmessage = R, S = function() {
      U.postMessage(null);
    }) : S = function() {
      D(R, 0);
    };
    var T, U;
    function I(a) {
      O = a, N || (N = !0, S());
    }
    function K(a, b) {
      L = D(function() {
        a(exports2.unstable_now());
      }, b);
    }
    exports2.unstable_IdlePriority = 5;
    exports2.unstable_ImmediatePriority = 1;
    exports2.unstable_LowPriority = 4;
    exports2.unstable_NormalPriority = 3;
    exports2.unstable_Profiling = null;
    exports2.unstable_UserBlockingPriority = 2;
    exports2.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports2.unstable_continueExecution = function() {
      A || z || (A = !0, I(J));
    };
    exports2.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports2.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports2.unstable_getFirstCallbackNode = function() {
      return h(r);
    };
    exports2.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports2.unstable_pauseExecution = function() {
    };
    exports2.unstable_requestPaint = function() {
    };
    exports2.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports2.unstable_scheduleCallback = function(a, b, c) {
      var d = exports2.unstable_now();
      switch (typeof c == "object" && c !== null ? (c = c.delay, c = typeof c == "number" && 0 < c ? d + c : d) : c = d, a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      return e = c + e, a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 }, c > d ? (a.sortIndex = c, f(t, a), h(r) === null && a === h(t) && (B ? (E(L), L = -1) : B = !0, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = !0, I(J))), a;
    };
    exports2.unstable_shouldYield = M;
    exports2.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_scheduler_production_min();
  }
});

// node_modules/react-dom/cjs/react-dom.production.min.js
var require_react_dom_production_min = __commonJS({
  "node_modules/react-dom/cjs/react-dom.production.min.js"(exports2) {
    "use strict";
    var aa = require_react(), ca = require_scheduler();
    function p(a) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
        b += "&args[]=" + encodeURIComponent(arguments[c]);
      return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a, b) {
      ha(a, b), ha(a + "Capture", b);
    }
    function ha(a, b) {
      for (ea[a] = b, a = 0; a < b.length; a++)
        da.add(b[a]);
    }
    var ia = !(typeof window == "undefined" || typeof window.document == "undefined" || typeof window.document.createElement == "undefined"), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a) {
      return ja.call(ma, a) ? !0 : ja.call(la, a) ? !1 : ka.test(a) ? ma[a] = !0 : (la[a] = !0, !1);
    }
    function pa(a, b, c, d) {
      if (c !== null && c.type === 0)
        return !1;
      switch (typeof b) {
        case "function":
        case "symbol":
          return !0;
        case "boolean":
          return d ? !1 : c !== null ? !c.acceptsBooleans : (a = a.toLowerCase().slice(0, 5), a !== "data-" && a !== "aria-");
        default:
          return !1;
      }
    }
    function qa(a, b, c, d) {
      if (b === null || typeof b == "undefined" || pa(a, b, c, d))
        return !0;
      if (d)
        return !1;
      if (c !== null)
        switch (c.type) {
          case 3:
            return !b;
          case 4:
            return b === !1;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
      return !1;
    }
    function v(a, b, c, d, e, f, g) {
      this.acceptsBooleans = b === 2 || b === 3 || b === 4, this.attributeName = d, this.attributeNamespace = e, this.mustUseProperty = c, this.propertyName = a, this.type = b, this.sanitizeURL = f, this.removeEmptyString = g;
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z[a] = new v(a, 0, !1, a, null, !1, !1);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b = a[0];
      z[b] = new v(b, 1, !1, a[1], null, !1, !1);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z[a] = new v(a, 2, !1, a.toLowerCase(), null, !1, !1);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z[a] = new v(a, 2, !1, a, null, !1, !1);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z[a] = new v(a, 3, !1, a.toLowerCase(), null, !1, !1);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z[a] = new v(a, 3, !0, a, null, !1, !1);
    });
    ["capture", "download"].forEach(function(a) {
      z[a] = new v(a, 4, !1, a, null, !1, !1);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z[a] = new v(a, 6, !1, a, null, !1, !1);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z[a] = new v(a, 5, !1, a.toLowerCase(), null, !1, !1);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b = a.replace(
        ra,
        sa
      );
      z[b] = new v(b, 1, !1, a, null, !1, !1);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b = a.replace(ra, sa);
      z[b] = new v(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z[a] = new v(a, 1, !1, a.toLowerCase(), null, !1, !1);
    });
    z.xlinkHref = new v("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z[a] = new v(a, 1, !1, a.toLowerCase(), null, !0, !0);
    });
    function ta(a, b, c, d) {
      var e = z.hasOwnProperty(b) ? z[b] : null;
      (e !== null ? e.type !== 0 : d || !(2 < b.length) || b[0] !== "o" && b[0] !== "O" || b[1] !== "n" && b[1] !== "N") && (qa(b, c, e, d) && (c = null), d || e === null ? oa(b) && (c === null ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = c === null ? e.type === 3 ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, c === null ? a.removeAttribute(b) : (e = e.type, c = e === 3 || e === 4 && c === !0 ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    Symbol.for("react.debug_trace_mode");
    var Ia = Symbol.for("react.offscreen");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.cache");
    Symbol.for("react.tracing_marker");
    var Ja = Symbol.iterator;
    function Ka(a) {
      return a === null || typeof a != "object" ? null : (a = Ja && a[Ja] || a["@@iterator"], typeof a == "function" ? a : null);
    }
    var A = Object.assign, La;
    function Ma(a) {
      if (La === void 0)
        try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
      return `
` + La + a;
    }
    var Na = !1;
    function Oa(a, b) {
      if (!a || Na)
        return "";
      Na = !0;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b)
          if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l) {
            d = l;
          }
          a();
        }
      } catch (l) {
        if (l && d && typeof l.stack == "string") {
          for (var e = l.stack.split(`
`), f = d.stack.split(`
`), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
            h--;
          for (; 1 <= g && 0 <= h; g--, h--)
            if (e[g] !== f[h]) {
              if (g !== 1 || h !== 1)
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = `
` + e[g].replace(" at new ", " at ");
                    return a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName)), k;
                  }
                while (1 <= g && 0 <= h);
              break;
            }
        }
      } finally {
        Na = !1, Error.prepareStackTrace = c;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, !1), a;
        case 11:
          return a = Oa(a.type.render, !1), a;
        case 1:
          return a = Oa(a.type, !0), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (a == null)
        return null;
      if (typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            return a = a.displayName, a || (a = b.displayName || b.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
          case Ga:
            return b = a.displayName || null, b !== null ? b : Qa(a.type) || "Memo";
          case Ha:
            b = a._payload, a = a._init;
            try {
              return Qa(a(b));
            } catch (c) {
            }
        }
      return null;
    }
    function Ra(a) {
      var b = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b.render, a = a.displayName || a.name || "", b.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof b == "function")
            return b.displayName || b.name || null;
          if (typeof b == "string")
            return b;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b = a.type;
      return (a = a.nodeName) && a.toLowerCase() === "input" && (b === "checkbox" || b === "radio");
    }
    function Ua(a) {
      var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
      if (!a.hasOwnProperty(b) && typeof c != "undefined" && typeof c.get == "function" && typeof c.set == "function") {
        var e = c.get, f = c.set;
        return Object.defineProperty(a, b, { configurable: !0, get: function() {
          return e.call(this);
        }, set: function(a2) {
          d = "" + a2, f.call(this, a2);
        } }), Object.defineProperty(a, b, { enumerable: c.enumerable }), { getValue: function() {
          return d;
        }, setValue: function(a2) {
          d = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null, delete a[b];
        } };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a)
        return !1;
      var b = a._valueTracker;
      if (!b)
        return !0;
      var c = b.getValue(), d = "";
      return a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value), a = d, a !== c ? (b.setValue(a), !0) : !1;
    }
    function Xa(a) {
      if (a = a || (typeof document != "undefined" ? document : void 0), typeof a == "undefined")
        return null;
      try {
        return a.activeElement || a.body;
      } catch (b) {
        return a.body;
      }
    }
    function Ya(a, b) {
      var c = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c != null ? c : a._wrapperState.initialChecked });
    }
    function Za(a, b) {
      var c = b.defaultValue == null ? "" : b.defaultValue, d = b.checked != null ? b.checked : b.defaultChecked;
      c = Sa(b.value != null ? b.value : c), a._wrapperState = { initialChecked: d, initialValue: c, controlled: b.type === "checkbox" || b.type === "radio" ? b.checked != null : b.value != null };
    }
    function ab(a, b) {
      b = b.checked, b != null && ta(a, "checked", b, !1);
    }
    function bb(a, b) {
      ab(a, b);
      var c = Sa(b.value), d = b.type;
      if (c != null)
        d === "number" ? (c === 0 && a.value === "" || a.value != c) && (a.value = "" + c) : a.value !== "" + c && (a.value = "" + c);
      else if (d === "submit" || d === "reset") {
        a.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue)), b.checked == null && b.defaultChecked != null && (a.defaultChecked = !!b.defaultChecked);
    }
    function db(a, b, c) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!(d !== "submit" && d !== "reset" || b.value !== void 0 && b.value !== null))
          return;
        b = "" + a._wrapperState.initialValue, c || b === a.value || (a.value = b), a.defaultValue = b;
      }
      c = a.name, c !== "" && (a.name = ""), a.defaultChecked = !!a._wrapperState.initialChecked, c !== "" && (a.name = c);
    }
    function cb(a, b, c) {
      (b !== "number" || Xa(a.ownerDocument) !== a) && (c == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c));
    }
    var eb = Array.isArray;
    function fb(a, b, c, d) {
      if (a = a.options, b) {
        b = {};
        for (var e = 0; e < c.length; e++)
          b["$" + c[e]] = !0;
        for (c = 0; c < a.length; c++)
          e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
      } else {
        for (c = "" + Sa(c), b = null, e = 0; e < a.length; e++) {
          if (a[e].value === c) {
            a[e].selected = !0, d && (a[e].defaultSelected = !0);
            return;
          }
          b !== null || a[e].disabled || (b = a[e]);
        }
        b !== null && (b.selected = !0);
      }
    }
    function gb(a, b) {
      if (b.dangerouslySetInnerHTML != null)
        throw Error(p(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b) {
      var c = b.value;
      if (c == null) {
        if (c = b.children, b = b.defaultValue, c != null) {
          if (b != null)
            throw Error(p(92));
          if (eb(c)) {
            if (1 < c.length)
              throw Error(p(93));
            c = c[0];
          }
          b = c;
        }
        b == null && (b = ""), c = b;
      }
      a._wrapperState = { initialValue: Sa(c) };
    }
    function ib(a, b) {
      var c = Sa(b.value), d = Sa(b.defaultValue);
      c != null && (c = "" + c, c !== a.value && (a.value = c), b.defaultValue == null && a.defaultValue !== c && (a.defaultValue = c)), d != null && (a.defaultValue = "" + d);
    }
    function jb(a) {
      var b = a.textContent;
      b === a._wrapperState.initialValue && b !== "" && b !== null && (a.value = b);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b) {
      return a == null || a === "http://www.w3.org/1999/xhtml" ? kb(b) : a === "http://www.w3.org/2000/svg" && b === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb, nb = function(a) {
      return typeof MSApp != "undefined" && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b, c, d, e);
        });
      } : a;
    }(function(a, b) {
      if (a.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a)
        a.innerHTML = b;
      else {
        for (mb = mb || document.createElement("div"), mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>", b = mb.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b.firstChild; )
          a.appendChild(b.firstChild);
      }
    });
    function ob(a, b) {
      if (b) {
        var c = a.firstChild;
        if (c && c === a.lastChild && c.nodeType === 3) {
          c.nodeValue = b;
          return;
        }
      }
      a.textContent = b;
    }
    var pb = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b) {
        b = b + a.charAt(0).toUpperCase() + a.substring(1), pb[b] = pb[a];
      });
    });
    function rb(a, b, c) {
      return b == null || typeof b == "boolean" || b === "" ? "" : c || typeof b != "number" || b === 0 || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
    }
    function sb(a, b) {
      a = a.style;
      for (var c in b)
        if (b.hasOwnProperty(c)) {
          var d = c.indexOf("--") === 0, e = rb(c, b[c], d);
          c === "float" && (c = "cssFloat"), d ? a.setProperty(c, e) : a[c] = e;
        }
    }
    var tb = A({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
    function ub(a, b) {
      if (b) {
        if (tb[a] && (b.children != null || b.dangerouslySetInnerHTML != null))
          throw Error(p(137, a));
        if (b.dangerouslySetInnerHTML != null) {
          if (b.children != null)
            throw Error(p(60));
          if (typeof b.dangerouslySetInnerHTML != "object" || !("__html" in b.dangerouslySetInnerHTML))
            throw Error(p(61));
        }
        if (b.style != null && typeof b.style != "object")
          throw Error(p(62));
      }
    }
    function vb(a, b) {
      if (a.indexOf("-") === -1)
        return typeof b.is == "string";
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var wb = null;
    function xb(a) {
      return a = a.target || a.srcElement || window, a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === 3 ? a.parentNode : a;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if (typeof yb != "function")
          throw Error(p(280));
        var b = a.stateNode;
        b && (b = Db(b), yb(a.stateNode, a.type, b));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b = Ab;
        if (Ab = zb = null, Bb(a), b)
          for (a = 0; a < b.length; a++)
            Bb(b[a]);
      }
    }
    function Gb(a, b) {
      return a(b);
    }
    function Hb() {
    }
    var Ib = !1;
    function Jb(a, b, c) {
      if (Ib)
        return a(b, c);
      Ib = !0;
      try {
        return Gb(a, b, c);
      } finally {
        Ib = !1, (zb !== null || Ab !== null) && (Hb(), Fb());
      }
    }
    function Kb(a, b) {
      var c = a.stateNode;
      if (c === null)
        return null;
      var d = Db(c);
      if (d === null)
        return null;
      c = d[b];
      a:
        switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !(a === "button" || a === "input" || a === "select" || a === "textarea")), a = !d;
            break a;
          default:
            a = !1;
        }
      if (a)
        return null;
      if (c && typeof c != "function")
        throw Error(p(231, b, typeof c));
      return c;
    }
    var Lb = !1;
    if (ia)
      try {
        Mb = {}, Object.defineProperty(Mb, "passive", { get: function() {
          Lb = !0;
        } }), window.addEventListener("test", Mb, Mb), window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = !1;
      }
    var Mb;
    function Nb(a, b, c, d, e, f, g, h, k) {
      var l = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c, l);
      } catch (m) {
        this.onError(m);
      }
    }
    var Ob = !1, Pb = null, Qb = !1, Rb = null, Sb = { onError: function(a) {
      Ob = !0, Pb = a;
    } };
    function Tb(a, b, c, d, e, f, g, h, k) {
      Ob = !1, Pb = null, Nb.apply(Sb, arguments);
    }
    function Ub(a, b, c, d, e, f, g, h, k) {
      if (Tb.apply(this, arguments), Ob) {
        if (Ob) {
          var l = Pb;
          Ob = !1, Pb = null;
        } else
          throw Error(p(198));
        Qb || (Qb = !0, Rb = l);
      }
    }
    function Vb(a) {
      var b = a, c = a;
      if (a.alternate)
        for (; b.return; )
          b = b.return;
      else {
        a = b;
        do
          b = a, b.flags & 4098 && (c = b.return), a = b.return;
        while (a);
      }
      return b.tag === 3 ? c : null;
    }
    function Wb(a) {
      if (a.tag === 13) {
        var b = a.memoizedState;
        if (b === null && (a = a.alternate, a !== null && (b = a.memoizedState)), b !== null)
          return b.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a)
        throw Error(p(188));
    }
    function Yb(a) {
      var b = a.alternate;
      if (!b) {
        if (b = Vb(a), b === null)
          throw Error(p(188));
        return b !== a ? null : a;
      }
      for (var c = a, d = b; ; ) {
        var e = c.return;
        if (e === null)
          break;
        var f = e.alternate;
        if (f === null) {
          if (d = e.return, d !== null) {
            c = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c)
              return Xb(e), a;
            if (f === d)
              return Xb(e), b;
            f = f.sibling;
          }
          throw Error(p(188));
        }
        if (c.return !== d.return)
          c = e, d = f;
        else {
          for (var g = !1, h = e.child; h; ) {
            if (h === c) {
              g = !0, c = e, d = f;
              break;
            }
            if (h === d) {
              g = !0, d = e, c = f;
              break;
            }
            h = h.sibling;
          }
          if (!g) {
            for (h = f.child; h; ) {
              if (h === c) {
                g = !0, c = f, d = e;
                break;
              }
              if (h === d) {
                g = !0, d = f, c = e;
                break;
              }
              h = h.sibling;
            }
            if (!g)
              throw Error(p(189));
          }
        }
        if (c.alternate !== d)
          throw Error(p(190));
      }
      if (c.tag !== 3)
        throw Error(p(188));
      return c.stateNode.current === c ? a : b;
    }
    function Zb(a) {
      return a = Yb(a), a !== null ? $b(a) : null;
    }
    function $b(a) {
      if (a.tag === 5 || a.tag === 6)
        return a;
      for (a = a.child; a !== null; ) {
        var b = $b(a);
        if (b !== null)
          return b;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a) {
      if (lc && typeof lc.onCommitFiberRoot == "function")
        try {
          lc.onCommitFiberRoot(kc, a, void 0, (a.current.flags & 128) === 128);
        } catch (b) {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a) {
      return a >>>= 0, a === 0 ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b) {
      var c = a.pendingLanes;
      if (c === 0)
        return 0;
      var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
      if (g !== 0) {
        var h = g & ~e;
        h !== 0 ? d = tc(h) : (f &= g, f !== 0 && (d = tc(f)));
      } else
        g = c & ~e, g !== 0 ? d = tc(g) : f !== 0 && (d = tc(f));
      if (d === 0)
        return 0;
      if (b !== 0 && b !== d && !(b & e) && (e = d & -d, f = b & -b, e >= f || e === 16 && (f & 4194240) !== 0))
        return b;
      if (d & 4 && (d |= c & 16), b = a.entangledLanes, b !== 0)
        for (a = a.entanglements, b &= d; 0 < b; )
          c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
      return d;
    }
    function vc(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b) {
      for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
        var g = 31 - oc(f), h = 1 << g, k = e[g];
        k === -1 ? (!(h & c) || h & d) && (e[g] = vc(h, b)) : k <= b && (a.expiredLanes |= h), f &= ~h;
      }
    }
    function xc(a) {
      return a = a.pendingLanes & -1073741825, a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      return rc <<= 1, !(rc & 4194240) && (rc = 64), a;
    }
    function zc(a) {
      for (var b = [], c = 0; 31 > c; c++)
        b.push(a);
      return b;
    }
    function Ac(a, b, c) {
      a.pendingLanes |= b, b !== 536870912 && (a.suspendedLanes = 0, a.pingedLanes = 0), a = a.eventTimes, b = 31 - oc(b), a[b] = c;
    }
    function Bc(a, b) {
      var c = a.pendingLanes & ~b;
      a.pendingLanes = b, a.suspendedLanes = 0, a.pingedLanes = 0, a.expiredLanes &= b, a.mutableReadLanes &= b, a.entangledLanes &= b, b = a.entanglements;
      var d = a.eventTimes;
      for (a = a.expirationTimes; 0 < c; ) {
        var e = 31 - oc(c), f = 1 << e;
        b[e] = 0, d[e] = -1, a[e] = -1, c &= ~f;
      }
    }
    function Cc(a, b) {
      var c = a.entangledLanes |= b;
      for (a = a.entanglements; c; ) {
        var d = 31 - oc(c), e = 1 << d;
        e & b | a[d] & b && (a[d] |= b), c &= ~e;
      }
    }
    var C = 0;
    function Dc(a) {
      return a &= -a, 1 < a ? 4 < a ? a & 268435455 ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    function Tc(a, b, c, d, e, f) {
      return a === null || a.nativeEvent !== f ? (a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, b !== null && (b = Cb(b), b !== null && Fc(b)), a) : (a.eventSystemFlags |= d, b = a.targetContainers, e !== null && b.indexOf(e) === -1 && b.push(e), a);
    }
    function Uc(a, b, c, d, e) {
      switch (b) {
        case "focusin":
          return Lc = Tc(Lc, a, b, c, d, e), !0;
        case "dragenter":
          return Mc = Tc(Mc, a, b, c, d, e), !0;
        case "mouseover":
          return Nc = Tc(Nc, a, b, c, d, e), !0;
        case "pointerover":
          var f = e.pointerId;
          return Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e)), !0;
        case "gotpointercapture":
          return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), !0;
      }
      return !1;
    }
    function Vc(a) {
      var b = Wc(a.target);
      if (b !== null) {
        var c = Vb(b);
        if (c !== null) {
          if (b = c.tag, b === 13) {
            if (b = Wb(c), b !== null) {
              a.blockedOn = b, Ic(a.priority, function() {
                Gc(c);
              });
              return;
            }
          } else if (b === 3 && c.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (a.blockedOn !== null)
        return !1;
      for (var b = a.targetContainers; 0 < b.length; ) {
        var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
        if (c === null) {
          c = a.nativeEvent;
          var d = new c.constructor(c.type, c);
          wb = d, c.target.dispatchEvent(d), wb = null;
        } else
          return b = Cb(c), b !== null && Fc(b), a.blockedOn = c, !1;
        b.shift();
      }
      return !0;
    }
    function Zc(a, b, c) {
      Xc(a) && c.delete(b);
    }
    function $c() {
      Jc = !1, Lc !== null && Xc(Lc) && (Lc = null), Mc !== null && Xc(Mc) && (Mc = null), Nc !== null && Xc(Nc) && (Nc = null), Oc.forEach(Zc), Pc.forEach(Zc);
    }
    function ad(a, b) {
      a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b(b2) {
        return ad(b2, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c = 1; c < Kc.length; c++) {
          var d = Kc[c];
          d.blockedOn === a && (d.blockedOn = null);
        }
      }
      for (Lc !== null && ad(Lc, a), Mc !== null && ad(Mc, a), Nc !== null && ad(Nc, a), Oc.forEach(b), Pc.forEach(b), c = 0; c < Qc.length; c++)
        d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
      for (; 0 < Qc.length && (c = Qc[0], c.blockedOn === null); )
        Vc(c), c.blockedOn === null && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = !0;
    function ed(a, b, c, d) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f;
      }
    }
    function gd(a, b, c, d) {
      var e = C, f = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b, c, d);
      } finally {
        C = e, cd.transition = f;
      }
    }
    function fd(a, b, c, d) {
      if (dd) {
        var e = Yc(a, b, c, d);
        if (e === null)
          hd(a, b, d, id, c), Sc(a, d);
        else if (Uc(e, a, b, c, d))
          d.stopPropagation();
        else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
          for (; e !== null; ) {
            var f = Cb(e);
            if (f !== null && Ec(f), f = Yc(a, b, c, d), f === null && hd(a, b, d, id, c), f === e)
              break;
            e = f;
          }
          e !== null && d.stopPropagation();
        } else
          hd(a, b, d, null, c);
      }
    }
    var id = null;
    function Yc(a, b, c, d) {
      if (id = null, a = xb(d), a = Wc(a), a !== null)
        if (b = Vb(a), b === null)
          a = null;
        else if (c = b.tag, c === 13) {
          if (a = Wb(b), a !== null)
            return a;
          a = null;
        } else if (c === 3) {
          if (b.stateNode.current.memoizedState.isDehydrated)
            return b.tag === 3 ? b.stateNode.containerInfo : null;
          a = null;
        } else
          b !== a && (a = null);
      return id = a, null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
      for (a = 0; a < c && b[a] === e[a]; a++)
        ;
      var g = c - a;
      for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
        ;
      return md = e.slice(a, 1 < d ? 1 - d : void 0);
    }
    function od(a) {
      var b = a.keyCode;
      return "charCode" in a ? (a = a.charCode, a === 0 && b === 13 && (a = 13)) : a = b, a === 10 && (a = 13), 32 <= a || a === 13 ? a : 0;
    }
    function pd() {
      return !0;
    }
    function qd() {
      return !1;
    }
    function rd(a) {
      function b(b2, d, e, f, g) {
        this._reactName = b2, this._targetInst = e, this.type = d, this.nativeEvent = f, this.target = g, this.currentTarget = null;
        for (var c in a)
          a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
        return this.isDefaultPrevented = (f.defaultPrevented != null ? f.defaultPrevented : f.returnValue === !1) ? pd : qd, this.isPropagationStopped = qd, this;
      }
      return A(b.prototype, { preventDefault: function() {
        this.defaultPrevented = !0;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : typeof a2.returnValue != "unknown" && (a2.returnValue = !1), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : typeof a2.cancelBubble != "unknown" && (a2.cancelBubble = !0), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd }), b;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      return "movementX" in a ? a.movementX : (a !== yd && (yd && a.type === "mousemove" ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a), wd);
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
    }
    function zd() {
      return Pd;
    }
    var Qd = A({}, ud, { key: function(a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if (b !== "Unidentified")
          return b;
      }
      return a.type === "keypress" ? (a = od(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return a.type === "keypress" ? od(a) : 0;
    }, keyCode: function(a) {
      return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    }, which: function(a) {
      return a.type === "keypress" ? od(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = " ", fe = !1;
    function ge(a, b) {
      switch (a) {
        case "keyup":
          return $d.indexOf(b.keyCode) !== -1;
        case "keydown":
          return b.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function he(a) {
      return a = a.detail, typeof a == "object" && "data" in a ? a.data : null;
    }
    var ie = !1;
    function je(a, b) {
      switch (a) {
        case "compositionend":
          return he(b);
        case "keypress":
          return b.which !== 32 ? null : (fe = !0, ee);
        case "textInput":
          return a = b.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b) {
      if (ie)
        return a === "compositionend" || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = !1, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length)
              return b.char;
            if (b.which)
              return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && b.locale !== "ko" ? null : b.data;
        default:
          return null;
      }
    }
    var le = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
    function me(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b === "input" ? !!le[a.type] : b === "textarea";
    }
    function ne(a, b, c, d) {
      Eb(d), b = oe(b, "onChange"), 0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
    }
    var pe = null, qe = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b = ue(a);
      if (Wa(b))
        return a;
    }
    function ve(a, b) {
      if (a === "change")
        return b;
    }
    var we = !1;
    ia && (ia ? (ye = "oninput" in document, ye || (ze = document.createElement("div"), ze.setAttribute("oninput", "return;"), ye = typeof ze.oninput == "function"), xe = ye) : xe = !1, we = xe && (!document.documentMode || 9 < document.documentMode));
    var xe, ye, ze;
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a) {
      if (a.propertyName === "value" && te(qe)) {
        var b = [];
        ne(b, qe, a, xb(a)), Jb(re, b);
      }
    }
    function Ce(a, b, c) {
      a === "focusin" ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : a === "focusout" && Ae();
    }
    function De(a) {
      if (a === "selectionchange" || a === "keyup" || a === "keydown")
        return te(qe);
    }
    function Ee(a, b) {
      if (a === "click")
        return te(b);
    }
    function Fe(a, b) {
      if (a === "input" || a === "change")
        return te(b);
    }
    function Ge(a, b) {
      return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
    }
    var He = typeof Object.is == "function" ? Object.is : Ge;
    function Ie(a, b) {
      if (He(a, b))
        return !0;
      if (typeof a != "object" || a === null || typeof b != "object" || b === null)
        return !1;
      var c = Object.keys(a), d = Object.keys(b);
      if (c.length !== d.length)
        return !1;
      for (d = 0; d < c.length; d++) {
        var e = c[d];
        if (!ja.call(b, e) || !He(a[e], b[e]))
          return !1;
      }
      return !0;
    }
    function Je(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Ke(a, b) {
      var c = Je(a);
      a = 0;
      for (var d; c; ) {
        if (c.nodeType === 3) {
          if (d = a + c.textContent.length, a <= b && d >= b)
            return { node: c, offset: b - a };
          a = d;
        }
        a: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break a;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Je(c);
      }
    }
    function Le(a, b) {
      return a && b ? a === b ? !0 : a && a.nodeType === 3 ? !1 : b && b.nodeType === 3 ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
    }
    function Me() {
      for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
        try {
          var c = typeof b.contentWindow.location.href == "string";
        } catch (d) {
          c = !1;
        }
        if (c)
          a = b.contentWindow;
        else
          break;
        b = Xa(a.document);
      }
      return b;
    }
    function Ne(a) {
      var b = a && a.nodeName && a.nodeName.toLowerCase();
      return b && (b === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || b === "textarea" || a.contentEditable === "true");
    }
    function Oe(a) {
      var b = Me(), c = a.focusedElem, d = a.selectionRange;
      if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
        if (d !== null && Ne(c)) {
          if (b = d.start, a = d.end, a === void 0 && (a = b), "selectionStart" in c)
            c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
          else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e = c.textContent.length, f = Math.min(d.start, e);
            d = d.end === void 0 ? f : Math.min(d.end, e), !a.extend && f > d && (e = d, d = f, f = e), e = Ke(c, f);
            var g = Ke(
              c,
              d
            );
            e && g && (a.rangeCount !== 1 || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
          }
        }
        for (b = [], a = c; a = a.parentNode; )
          a.nodeType === 1 && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        for (typeof c.focus == "function" && c.focus(), c = 0; c < b.length; c++)
          a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = !1;
    function Ue(a, b, c) {
      var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
      Te || Qe == null || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
    }
    function Ve(a, b) {
      var c = {};
      return c[a.toLowerCase()] = b.toLowerCase(), c["Webkit" + a] = "webkit" + b, c["Moz" + a] = "moz" + b, c;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a])
        return Xe[a];
      if (!We[a])
        return a;
      var b = We[a], c;
      for (c in b)
        if (b.hasOwnProperty(c) && c in Ye)
          return Xe[a] = b[c];
      return a;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b) {
      df.set(a, b), fa(b, [a]);
    }
    for (gf = 0; gf < ef.length; gf++)
      hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1), ff(jf, "on" + kf);
    var hf, jf, kf, gf;
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b, c) {
      var d = a.type || "unknown-event";
      a.currentTarget = c, Ub(d, b, void 0, a), a.currentTarget = null;
    }
    function se(a, b) {
      b = (b & 4) !== 0;
      for (var c = 0; c < a.length; c++) {
        var d = a[c], e = d.event;
        d = d.listeners;
        a: {
          var f = void 0;
          if (b)
            for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              if (h = h.listener, k !== f && e.isPropagationStopped())
                break a;
              nf(e, h, l), f = k;
            }
          else
            for (g = 0; g < d.length; g++) {
              if (h = d[g], k = h.instance, l = h.currentTarget, h = h.listener, k !== f && e.isPropagationStopped())
                break a;
              nf(e, h, l), f = k;
            }
        }
      }
      if (Qb)
        throw a = Rb, Qb = !1, Rb = null, a;
    }
    function D(a, b) {
      var c = b[of];
      c === void 0 && (c = b[of] = /* @__PURE__ */ new Set());
      var d = a + "__bubble";
      c.has(d) || (pf(b, a, 2, !1), c.add(d));
    }
    function qf(a, b, c) {
      var d = 0;
      b && (d |= 4), pf(c, a, d, b);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = !0, da.forEach(function(b2) {
          b2 !== "selectionchange" && (mf.has(b2) || qf(b2, !1, a), qf(b2, !0, a));
        });
        var b = a.nodeType === 9 ? a : a.ownerDocument;
        b === null || b[rf] || (b[rf] = !0, qf("selectionchange", !1, b));
      }
    }
    function pf(a, b, c, d) {
      switch (jd(b)) {
        case 1:
          var e = ed;
          break;
        case 4:
          e = gd;
          break;
        default:
          e = fd;
      }
      c = e.bind(null, b, c, a), e = void 0, !Lb || b !== "touchstart" && b !== "touchmove" && b !== "wheel" || (e = !0), d ? e !== void 0 ? a.addEventListener(b, c, { capture: !0, passive: e }) : a.addEventListener(b, c, !0) : e !== void 0 ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, !1);
    }
    function hd(a, b, c, d, e) {
      var f = d;
      if (!(b & 1) && !(b & 2) && d !== null)
        a:
          for (; ; ) {
            if (d === null)
              return;
            var g = d.tag;
            if (g === 3 || g === 4) {
              var h = d.stateNode.containerInfo;
              if (h === e || h.nodeType === 8 && h.parentNode === e)
                break;
              if (g === 4)
                for (g = d.return; g !== null; ) {
                  var k = g.tag;
                  if ((k === 3 || k === 4) && (k = g.stateNode.containerInfo, k === e || k.nodeType === 8 && k.parentNode === e))
                    return;
                  g = g.return;
                }
              for (; h !== null; ) {
                if (g = Wc(h), g === null)
                  return;
                if (k = g.tag, k === 5 || k === 6) {
                  d = f = g;
                  continue a;
                }
                h = h.parentNode;
              }
            }
            d = d.return;
          }
      Jb(function() {
        var d2 = f, e2 = xb(c), g2 = [];
        a: {
          var h2 = df.get(a);
          if (h2 !== void 0) {
            var k2 = td, n = a;
            switch (a) {
              case "keypress":
                if (od(c) === 0)
                  break a;
              case "keydown":
              case "keyup":
                k2 = Rd;
                break;
              case "focusin":
                n = "focus", k2 = Fd;
                break;
              case "focusout":
                n = "blur", k2 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k2 = Fd;
                break;
              case "click":
                if (c.button === 2)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k2 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k2 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k2 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k2 = Hd;
                break;
              case cf:
                k2 = Xd;
                break;
              case "scroll":
                k2 = vd;
                break;
              case "wheel":
                k2 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k2 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k2 = Td;
            }
            var t = (b & 4) !== 0, J = !t && a === "scroll", x = t ? h2 !== null ? h2 + "Capture" : null : h2;
            t = [];
            for (var w = d2, u; w !== null; ) {
              u = w;
              var F = u.stateNode;
              if (u.tag === 5 && F !== null && (u = F, x !== null && (F = Kb(w, x), F != null && t.push(tf(w, F, u)))), J)
                break;
              w = w.return;
            }
            0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
          }
        }
        if (!(b & 7)) {
          a: {
            if (h2 = a === "mouseover" || a === "pointerover", k2 = a === "mouseout" || a === "pointerout", h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf]))
              break a;
            if ((k2 || h2) && (h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window, k2 ? (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, n !== null && (J = Vb(n), n !== J || n.tag !== 5 && n.tag !== 6) && (n = null)) : (k2 = null, n = d2), k2 !== n)) {
              if (t = Bd, F = "onMouseLeave", x = "onMouseEnter", w = "mouse", (a === "pointerout" || a === "pointerover") && (t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer"), J = k2 == null ? h2 : ue(k2), u = n == null ? h2 : ue(n), h2 = new t(F, w + "leave", k2, c, e2), h2.target = J, h2.relatedTarget = u, F = null, Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t), J = F, k2 && n)
                b: {
                  for (t = k2, x = n, w = 0, u = t; u; u = vf(u))
                    w++;
                  for (u = 0, F = x; F; F = vf(F))
                    u++;
                  for (; 0 < w - u; )
                    t = vf(t), w--;
                  for (; 0 < u - w; )
                    x = vf(x), u--;
                  for (; w--; ) {
                    if (t === x || x !== null && t === x.alternate)
                      break b;
                    t = vf(t), x = vf(x);
                  }
                  t = null;
                }
              else
                t = null;
              k2 !== null && wf(g2, h2, k2, t, !1), n !== null && J !== null && wf(g2, J, n, t, !0);
            }
          }
          a: {
            if (h2 = d2 ? ue(d2) : window, k2 = h2.nodeName && h2.nodeName.toLowerCase(), k2 === "select" || k2 === "input" && h2.type === "file")
              var na = ve;
            else if (me(h2))
              if (we)
                na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
            else
              (k2 = h2.nodeName) && k2.toLowerCase() === "input" && (h2.type === "checkbox" || h2.type === "radio") && (na = Ee);
            if (na && (na = na(a, d2))) {
              ne(g2, na, c, e2);
              break a;
            }
            xa && xa(a, h2, d2), a === "focusout" && (xa = h2._wrapperState) && xa.controlled && h2.type === "number" && cb(h2, "number", h2.value);
          }
          switch (xa = d2 ? ue(d2) : window, a) {
            case "focusin":
              (me(xa) || xa.contentEditable === "true") && (Qe = xa, Re = d2, Se = null);
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = !1, Ue(g2, c, e2);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g2, c, e2);
          }
          var $a;
          if (ae)
            b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie ? ge(a, c) && (ba = "onCompositionEnd") : a === "keydown" && c.keyCode === 229 && (ba = "onCompositionStart");
          ba && (de && c.locale !== "ko" && (ie || ba !== "onCompositionStart" ? ba === "onCompositionEnd" && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), $a !== null && (ba.data = $a)))), ($a = ce ? je(a, c) : ke(a, c)) && (d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a));
        }
        se(g2, b);
      });
    }
    function tf(a, b, c) {
      return { instance: a, listener: b, currentTarget: c };
    }
    function oe(a, b) {
      for (var c = b + "Capture", d = []; a !== null; ) {
        var e = a, f = e.stateNode;
        e.tag === 5 && f !== null && (e = f, f = Kb(a, c), f != null && d.unshift(tf(a, f, e)), f = Kb(a, b), f != null && d.push(tf(a, f, e))), a = a.return;
      }
      return d;
    }
    function vf(a) {
      if (a === null)
        return null;
      do
        a = a.return;
      while (a && a.tag !== 5);
      return a || null;
    }
    function wf(a, b, c, d, e) {
      for (var f = b._reactName, g = []; c !== null && c !== d; ) {
        var h = c, k = h.alternate, l = h.stateNode;
        if (k !== null && k === d)
          break;
        h.tag === 5 && l !== null && (h = l, e ? (k = Kb(c, f), k != null && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), k != null && g.push(tf(c, k, h)))), c = c.return;
      }
      g.length !== 0 && a.push({ event: b, listeners: g });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return (typeof a == "string" ? a : "" + a).replace(xf, `
`).replace(yf, "");
    }
    function Af(a, b, c) {
      if (b = zf(b), zf(a) !== b && c)
        throw Error(p(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a, b) {
      return a === "textarea" || a === "noscript" || typeof b.children == "string" || typeof b.children == "number" || typeof b.dangerouslySetInnerHTML == "object" && b.dangerouslySetInnerHTML !== null && b.dangerouslySetInnerHTML.__html != null;
    }
    var Ff = typeof setTimeout == "function" ? setTimeout : void 0, Gf = typeof clearTimeout == "function" ? clearTimeout : void 0, Hf = typeof Promise == "function" ? Promise : void 0, Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf != "undefined" ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b) {
      var c = b, d = 0;
      do {
        var e = c.nextSibling;
        if (a.removeChild(c), e && e.nodeType === 8)
          if (c = e.data, c === "/$") {
            if (d === 0) {
              a.removeChild(e), bd(b);
              return;
            }
            d--;
          } else
            c !== "$" && c !== "$?" && c !== "$!" || d++;
        c = e;
      } while (c);
      bd(b);
    }
    function Lf(a) {
      for (; a != null; a = a.nextSibling) {
        var b = a.nodeType;
        if (b === 1 || b === 3)
          break;
        if (b === 8) {
          if (b = a.data, b === "$" || b === "$!" || b === "$?")
            break;
          if (b === "/$")
            return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b = 0; a; ) {
        if (a.nodeType === 8) {
          var c = a.data;
          if (c === "$" || c === "$!" || c === "$?") {
            if (b === 0)
              return a;
            b--;
          } else
            c === "/$" && b++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b = a[Of];
      if (b)
        return b;
      for (var c = a.parentNode; c; ) {
        if (b = c[uf] || c[Of]) {
          if (c = b.alternate, b.child !== null || c !== null && c.child !== null)
            for (a = Mf(a); a !== null; ) {
              if (c = a[Of])
                return c;
              a = Mf(a);
            }
          return b;
        }
        a = c, c = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      return a = a[Of] || a[uf], !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
    }
    function ue(a) {
      if (a.tag === 5 || a.tag === 6)
        return a.stateNode;
      throw Error(p(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a, b) {
      Tf++, Sf[Tf] = a.current, a.current = b;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(!1), Xf = Vf;
    function Yf(a, b) {
      var c = a.type.contextTypes;
      if (!c)
        return Vf;
      var d = a.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
        return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c)
        e[f] = b[f];
      return d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e), e;
    }
    function Zf(a) {
      return a = a.childContextTypes, a != null;
    }
    function $f() {
      E(Wf), E(H);
    }
    function ag(a, b, c) {
      if (H.current !== Vf)
        throw Error(p(168));
      G(H, b), G(Wf, c);
    }
    function bg(a, b, c) {
      var d = a.stateNode;
      if (b = b.childContextTypes, typeof d.getChildContext != "function")
        return c;
      d = d.getChildContext();
      for (var e in d)
        if (!(e in b))
          throw Error(p(108, Ra(a) || "Unknown", e));
      return A({}, c, d);
    }
    function cg(a) {
      return a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf, Xf = H.current, G(H, a), G(Wf, Wf.current), !0;
    }
    function dg(a, b, c) {
      var d = a.stateNode;
      if (!d)
        throw Error(p(169));
      c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf), G(Wf, c);
    }
    var eg = null, fg = !1, gg = !1;
    function hg(a) {
      eg === null ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = !0, hg(a);
    }
    function jg() {
      if (!gg && eg !== null) {
        gg = !0;
        var a = 0, b = C;
        try {
          var c = eg;
          for (C = 1; a < c.length; a++) {
            var d = c[a];
            do
              d = d(!0);
            while (d !== null);
          }
          eg = null, fg = !1;
        } catch (e) {
          throw eg !== null && (eg = eg.slice(a + 1)), ac(fc, jg), e;
        } finally {
          C = b, gg = !1;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a, b) {
      kg[lg++] = ng, kg[lg++] = mg, mg = a, ng = b;
    }
    function ug(a, b, c) {
      og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, qg = a;
      var d = rg;
      a = sg;
      var e = 32 - oc(d) - 1;
      d &= ~(1 << e), c += 1;
      var f = 32 - oc(b) + e;
      if (30 < f) {
        var g = e - e % 5;
        f = (d & (1 << g) - 1).toString(32), d >>= g, e -= g, rg = 1 << 32 - oc(b) + e | c << e | d, sg = f + a;
      } else
        rg = 1 << f | c << e | d, sg = a;
    }
    function vg(a) {
      a.return !== null && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = !1, zg = null;
    function Ag(a, b) {
      var c = Bg(5, null, null, 0);
      c.elementType = "DELETED", c.stateNode = b, c.return = a, b = a.deletions, b === null ? (a.deletions = [c], a.flags |= 16) : b.push(c);
    }
    function Cg(a, b) {
      switch (a.tag) {
        case 5:
          var c = a.type;
          return b = b.nodeType !== 1 || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b, b !== null ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), !0) : !1;
        case 6:
          return b = a.pendingProps === "" || b.nodeType !== 3 ? null : b, b !== null ? (a.stateNode = b, xg = a, yg = null, !0) : !1;
        case 13:
          return b = b.nodeType !== 8 ? null : b, b !== null ? (c = qg !== null ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, !0) : !1;
        default:
          return !1;
      }
    }
    function Dg(a) {
      return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
    }
    function Eg(a) {
      if (I) {
        var b = yg;
        if (b) {
          var c = b;
          if (!Cg(a, b)) {
            if (Dg(a))
              throw Error(p(418));
            b = Lf(c.nextSibling);
            var d = xg;
            b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = !1, xg = a);
          }
        } else {
          if (Dg(a))
            throw Error(p(418));
          a.flags = a.flags & -4097 | 2, I = !1, xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
        a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg)
        return !1;
      if (!I)
        return Fg(a), I = !0, !1;
      var b;
      if ((b = a.tag !== 3) && !(b = a.tag !== 5) && (b = a.type, b = b !== "head" && b !== "body" && !Ef(a.type, a.memoizedProps)), b && (b = yg)) {
        if (Dg(a))
          throw Hg(), Error(p(418));
        for (; b; )
          Ag(a, b), b = Lf(b.nextSibling);
      }
      if (Fg(a), a.tag === 13) {
        if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a)
          throw Error(p(317));
        a: {
          for (a = a.nextSibling, b = 0; a; ) {
            if (a.nodeType === 8) {
              var c = a.data;
              if (c === "/$") {
                if (b === 0) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b--;
              } else
                c !== "$" && c !== "$!" && c !== "$?" || b++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return !0;
    }
    function Hg() {
      for (var a = yg; a; )
        a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null, I = !1;
    }
    function Jg(a) {
      zg === null ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b, c) {
      if (a = c.ref, a !== null && typeof a != "function" && typeof a != "object") {
        if (c._owner) {
          if (c = c._owner, c) {
            if (c.tag !== 1)
              throw Error(p(309));
            var d = c.stateNode;
          }
          if (!d)
            throw Error(p(147, a));
          var e = d, f = "" + a;
          return b !== null && b.ref !== null && typeof b.ref == "function" && b.ref._stringRef === f ? b.ref : (b = function(a2) {
            var b2 = e.refs;
            a2 === null ? delete b2[f] : b2[f] = a2;
          }, b._stringRef = f, b);
        }
        if (typeof a != "string")
          throw Error(p(284));
        if (!c._owner)
          throw Error(p(290, a));
      }
      return a;
    }
    function Mg(a, b) {
      throw a = Object.prototype.toString.call(b), Error(p(31, a === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
    }
    function Ng(a) {
      var b = a._init;
      return b(a._payload);
    }
    function Og(a) {
      function b(b2, c2) {
        if (a) {
          var d2 = b2.deletions;
          d2 === null ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
        }
      }
      function c(c2, d2) {
        if (!a)
          return null;
        for (; d2 !== null; )
          b(c2, d2), d2 = d2.sibling;
        return null;
      }
      function d(a2, b2) {
        for (a2 = /* @__PURE__ */ new Map(); b2 !== null; )
          b2.key !== null ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
        return a2;
      }
      function e(a2, b2) {
        return a2 = Pg(a2, b2), a2.index = 0, a2.sibling = null, a2;
      }
      function f(b2, c2, d2) {
        return b2.index = d2, a ? (d2 = b2.alternate, d2 !== null ? (d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2) : (b2.flags |= 2, c2)) : (b2.flags |= 1048576, c2);
      }
      function g(b2) {
        return a && b2.alternate === null && (b2.flags |= 2), b2;
      }
      function h(a2, b2, c2, d2) {
        return b2 === null || b2.tag !== 6 ? (b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2) : (b2 = e(b2, c2), b2.return = a2, b2);
      }
      function k(a2, b2, c2, d2) {
        var f2 = c2.type;
        return f2 === ya ? m(a2, b2, c2.props.children, d2, c2.key) : b2 !== null && (b2.elementType === f2 || typeof f2 == "object" && f2 !== null && f2.$$typeof === Ha && Ng(f2) === b2.type) ? (d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2) : (d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2);
      }
      function l(a2, b2, c2, d2) {
        return b2 === null || b2.tag !== 4 || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation ? (b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2) : (b2 = e(b2, c2.children || []), b2.return = a2, b2);
      }
      function m(a2, b2, c2, d2, f2) {
        return b2 === null || b2.tag !== 7 ? (b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2) : (b2 = e(b2, c2), b2.return = a2, b2);
      }
      function q(a2, b2, c2) {
        if (typeof b2 == "string" && b2 !== "" || typeof b2 == "number")
          return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
        if (typeof b2 == "object" && b2 !== null) {
          switch (b2.$$typeof) {
            case va:
              return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
            case wa:
              return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
            case Ha:
              var d2 = b2._init;
              return q(a2, d2(b2._payload), c2);
          }
          if (eb(b2) || Ka(b2))
            return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
          Mg(a2, b2);
        }
        return null;
      }
      function r(a2, b2, c2, d2) {
        var e2 = b2 !== null ? b2.key : null;
        if (typeof c2 == "string" && c2 !== "" || typeof c2 == "number")
          return e2 !== null ? null : h(a2, b2, "" + c2, d2);
        if (typeof c2 == "object" && c2 !== null) {
          switch (c2.$$typeof) {
            case va:
              return c2.key === e2 ? k(a2, b2, c2, d2) : null;
            case wa:
              return c2.key === e2 ? l(a2, b2, c2, d2) : null;
            case Ha:
              return e2 = c2._init, r(
                a2,
                b2,
                e2(c2._payload),
                d2
              );
          }
          if (eb(c2) || Ka(c2))
            return e2 !== null ? null : m(a2, b2, c2, d2, null);
          Mg(a2, c2);
        }
        return null;
      }
      function y(a2, b2, c2, d2, e2) {
        if (typeof d2 == "string" && d2 !== "" || typeof d2 == "number")
          return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
        if (typeof d2 == "object" && d2 !== null) {
          switch (d2.$$typeof) {
            case va:
              return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, k(b2, a2, d2, e2);
            case wa:
              return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, l(b2, a2, d2, e2);
            case Ha:
              var f2 = d2._init;
              return y(a2, b2, c2, f2(d2._payload), e2);
          }
          if (eb(d2) || Ka(d2))
            return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
          Mg(b2, d2);
        }
        return null;
      }
      function n(e2, g2, h2, k2) {
        for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; u !== null && w < h2.length; w++) {
          u.index > w ? (x = u, u = null) : x = u.sibling;
          var n2 = r(e2, u, h2[w], k2);
          if (n2 === null) {
            u === null && (u = x);
            break;
          }
          a && u && n2.alternate === null && b(e2, u), g2 = f(n2, g2, w), m2 === null ? l2 = n2 : m2.sibling = n2, m2 = n2, u = x;
        }
        if (w === h2.length)
          return c(e2, u), I && tg(e2, w), l2;
        if (u === null) {
          for (; w < h2.length; w++)
            u = q(e2, h2[w], k2), u !== null && (g2 = f(u, g2, w), m2 === null ? l2 = u : m2.sibling = u, m2 = u);
          return I && tg(e2, w), l2;
        }
        for (u = d(e2, u); w < h2.length; w++)
          x = y(u, e2, w, h2[w], k2), x !== null && (a && x.alternate !== null && u.delete(x.key === null ? w : x.key), g2 = f(x, g2, w), m2 === null ? l2 = x : m2.sibling = x, m2 = x);
        return a && u.forEach(function(a2) {
          return b(e2, a2);
        }), I && tg(e2, w), l2;
      }
      function t(e2, g2, h2, k2) {
        var l2 = Ka(h2);
        if (typeof l2 != "function")
          throw Error(p(150));
        if (h2 = l2.call(h2), h2 == null)
          throw Error(p(151));
        for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); m2 !== null && !n2.done; w++, n2 = h2.next()) {
          m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
          var t2 = r(e2, m2, n2.value, k2);
          if (t2 === null) {
            m2 === null && (m2 = x);
            break;
          }
          a && m2 && t2.alternate === null && b(e2, m2), g2 = f(t2, g2, w), u === null ? l2 = t2 : u.sibling = t2, u = t2, m2 = x;
        }
        if (n2.done)
          return c(
            e2,
            m2
          ), I && tg(e2, w), l2;
        if (m2 === null) {
          for (; !n2.done; w++, n2 = h2.next())
            n2 = q(e2, n2.value, k2), n2 !== null && (g2 = f(n2, g2, w), u === null ? l2 = n2 : u.sibling = n2, u = n2);
          return I && tg(e2, w), l2;
        }
        for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next())
          n2 = y(m2, e2, w, n2.value, k2), n2 !== null && (a && n2.alternate !== null && m2.delete(n2.key === null ? w : n2.key), g2 = f(n2, g2, w), u === null ? l2 = n2 : u.sibling = n2, u = n2);
        return a && m2.forEach(function(a2) {
          return b(e2, a2);
        }), I && tg(e2, w), l2;
      }
      function J(a2, d2, f2, h2) {
        if (typeof f2 == "object" && f2 !== null && f2.type === ya && f2.key === null && (f2 = f2.props.children), typeof f2 == "object" && f2 !== null) {
          switch (f2.$$typeof) {
            case va:
              a: {
                for (var k2 = f2.key, l2 = d2; l2 !== null; ) {
                  if (l2.key === k2) {
                    if (k2 = f2.type, k2 === ya) {
                      if (l2.tag === 7) {
                        c(a2, l2.sibling), d2 = e(l2, f2.props.children), d2.return = a2, a2 = d2;
                        break a;
                      }
                    } else if (l2.elementType === k2 || typeof k2 == "object" && k2 !== null && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                      c(a2, l2.sibling), d2 = e(l2, f2.props), d2.ref = Lg(a2, l2, f2), d2.return = a2, a2 = d2;
                      break a;
                    }
                    c(a2, l2);
                    break;
                  } else
                    b(a2, l2);
                  l2 = l2.sibling;
                }
                f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
              }
              return g(a2);
            case wa:
              a: {
                for (l2 = f2.key; d2 !== null; ) {
                  if (d2.key === l2)
                    if (d2.tag === 4 && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling), d2 = e(d2, f2.children || []), d2.return = a2, a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                  else
                    b(a2, d2);
                  d2 = d2.sibling;
                }
                d2 = Sg(f2, a2.mode, h2), d2.return = a2, a2 = d2;
              }
              return g(a2);
            case Ha:
              return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
          }
          if (eb(f2))
            return n(a2, d2, f2, h2);
          if (Ka(f2))
            return t(a2, d2, f2, h2);
          Mg(a2, f2);
        }
        return typeof f2 == "string" && f2 !== "" || typeof f2 == "number" ? (f2 = "" + f2, d2 !== null && d2.tag === 6 ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
      }
      return J;
    }
    var Ug = Og(!0), Vg = Og(!1), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
    function $g() {
      Zg = Yg = Xg = null;
    }
    function ah(a) {
      var b = Wg.current;
      E(Wg), a._currentValue = b;
    }
    function bh(a, b, c) {
      for (; a !== null; ) {
        var d = a.alternate;
        if ((a.childLanes & b) !== b ? (a.childLanes |= b, d !== null && (d.childLanes |= b)) : d !== null && (d.childLanes & b) !== b && (d.childLanes |= b), a === c)
          break;
        a = a.return;
      }
    }
    function ch(a, b) {
      Xg = a, Zg = Yg = null, a = a.dependencies, a !== null && a.firstContext !== null && (a.lanes & b && (dh = !0), a.firstContext = null);
    }
    function eh(a) {
      var b = a._currentValue;
      if (Zg !== a)
        if (a = { context: a, memoizedValue: b, next: null }, Yg === null) {
          if (Xg === null)
            throw Error(p(308));
          Yg = a, Xg.dependencies = { lanes: 0, firstContext: a };
        } else
          Yg = Yg.next = a;
      return b;
    }
    var fh = null;
    function gh(a) {
      fh === null ? fh = [a] : fh.push(a);
    }
    function hh(a, b, c, d) {
      var e = b.interleaved;
      return e === null ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c), b.interleaved = c, ih(a, d);
    }
    function ih(a, b) {
      a.lanes |= b;
      var c = a.alternate;
      for (c !== null && (c.lanes |= b), c = a, a = a.return; a !== null; )
        a.childLanes |= b, c = a.alternate, c !== null && (c.childLanes |= b), c = a, a = a.return;
      return c.tag === 3 ? c.stateNode : null;
    }
    var jh = !1;
    function kh(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function lh(a, b) {
      a = a.updateQueue, b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function mh(a, b) {
      return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    function nh(a, b, c) {
      var d = a.updateQueue;
      if (d === null)
        return null;
      if (d = d.shared, K & 2) {
        var e = d.pending;
        return e === null ? b.next = b : (b.next = e.next, e.next = b), d.pending = b, ih(a, c);
      }
      return e = d.interleaved, e === null ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b), d.interleaved = b, ih(a, c);
    }
    function oh(a, b, c) {
      if (b = b.updateQueue, b !== null && (b = b.shared, (c & 4194240) !== 0)) {
        var d = b.lanes;
        d &= a.pendingLanes, c |= d, b.lanes = c, Cc(a, c);
      }
    }
    function ph(a, b) {
      var c = a.updateQueue, d = a.alternate;
      if (d !== null && (d = d.updateQueue, c === d)) {
        var e = null, f = null;
        if (c = c.firstBaseUpdate, c !== null) {
          do {
            var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
            f === null ? e = f = g : f = f.next = g, c = c.next;
          } while (c !== null);
          f === null ? e = f = b : f = f.next = b;
        } else
          e = f = b;
        c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects }, a.updateQueue = c;
        return;
      }
      a = c.lastBaseUpdate, a === null ? c.firstBaseUpdate = b : a.next = b, c.lastBaseUpdate = b;
    }
    function qh(a, b, c, d) {
      var e = a.updateQueue;
      jh = !1;
      var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
      if (h !== null) {
        e.shared.pending = null;
        var k = h, l = k.next;
        k.next = null, g === null ? f = l : g.next = l, g = k;
        var m = a.alternate;
        m !== null && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (h === null ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
      }
      if (f !== null) {
        var q = e.baseState;
        g = 0, m = l = k = null, h = f;
        do {
          var r = h.lane, y = h.eventTime;
          if ((d & r) === r) {
            m !== null && (m = m.next = {
              eventTime: y,
              lane: 0,
              tag: h.tag,
              payload: h.payload,
              callback: h.callback,
              next: null
            });
            a: {
              var n = a, t = h;
              switch (r = b, y = c, t.tag) {
                case 1:
                  if (n = t.payload, typeof n == "function") {
                    q = n.call(y, q, r);
                    break a;
                  }
                  q = n;
                  break a;
                case 3:
                  n.flags = n.flags & -65537 | 128;
                case 0:
                  if (n = t.payload, r = typeof n == "function" ? n.call(y, q, r) : n, r == null)
                    break a;
                  q = A({}, q, r);
                  break a;
                case 2:
                  jh = !0;
              }
            }
            h.callback !== null && h.lane !== 0 && (a.flags |= 64, r = e.effects, r === null ? e.effects = [h] : r.push(h));
          } else
            y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, m === null ? (l = m = y, k = q) : m = m.next = y, g |= r;
          if (h = h.next, h === null) {
            if (h = e.shared.pending, h === null)
              break;
            r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
          }
        } while (!0);
        if (m === null && (k = q), e.baseState = k, e.firstBaseUpdate = l, e.lastBaseUpdate = m, b = e.shared.interleaved, b !== null) {
          e = b;
          do
            g |= e.lane, e = e.next;
          while (e !== b);
        } else
          f === null && (e.shared.lanes = 0);
        rh |= g, a.lanes = g, a.memoizedState = q;
      }
    }
    function sh(a, b, c) {
      if (a = b.effects, b.effects = null, a !== null)
        for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (e !== null) {
            if (d.callback = null, d = c, typeof e != "function")
              throw Error(p(191, e));
            e.call(d);
          }
        }
    }
    var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
    function xh(a) {
      if (a === th)
        throw Error(p(174));
      return a;
    }
    function yh(a, b) {
      switch (G(wh, b), G(vh, a), G(uh, th), a = b.nodeType, a) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          a = a === 8 ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
      }
      E(uh), G(uh, b);
    }
    function zh() {
      E(uh), E(vh), E(wh);
    }
    function Ah(a) {
      xh(wh.current);
      var b = xh(uh.current), c = lb(b, a.type);
      b !== c && (G(vh, a), G(uh, c));
    }
    function Bh(a) {
      vh.current === a && (E(uh), E(vh));
    }
    var L = Uf(0);
    function Ch(a) {
      for (var b = a; b !== null; ) {
        if (b.tag === 13) {
          var c = b.memoizedState;
          if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!"))
            return b;
        } else if (b.tag === 19 && b.memoizedProps.revealOrder !== void 0) {
          if (b.flags & 128)
            return b;
        } else if (b.child !== null) {
          b.child.return = b, b = b.child;
          continue;
        }
        if (b === a)
          break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === a)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
      return null;
    }
    var Dh = [];
    function Eh() {
      for (var a = 0; a < Dh.length; a++)
        Dh[a]._workInProgressVersionPrimary = null;
      Dh.length = 0;
    }
    var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = !1, Jh = !1, Kh = 0, Lh = 0;
    function P() {
      throw Error(p(321));
    }
    function Mh(a, b) {
      if (b === null)
        return !1;
      for (var c = 0; c < b.length && c < a.length; c++)
        if (!He(a[c], b[c]))
          return !1;
      return !0;
    }
    function Nh(a, b, c, d, e, f) {
      if (Hh = f, M = b, b.memoizedState = null, b.updateQueue = null, b.lanes = 0, Fh.current = a === null || a.memoizedState === null ? Oh : Ph, a = c(d, e), Jh) {
        f = 0;
        do {
          if (Jh = !1, Kh = 0, 25 <= f)
            throw Error(p(301));
          f += 1, O = N = null, b.updateQueue = null, Fh.current = Qh, a = c(d, e);
        } while (Jh);
      }
      if (Fh.current = Rh, b = N !== null && N.next !== null, Hh = 0, O = N = M = null, Ih = !1, b)
        throw Error(p(300));
      return a;
    }
    function Sh() {
      var a = Kh !== 0;
      return Kh = 0, a;
    }
    function Th() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return O === null ? M.memoizedState = O = a : O = O.next = a, O;
    }
    function Uh() {
      if (N === null) {
        var a = M.alternate;
        a = a !== null ? a.memoizedState : null;
      } else
        a = N.next;
      var b = O === null ? M.memoizedState : O.next;
      if (b !== null)
        O = b, N = a;
      else {
        if (a === null)
          throw Error(p(310));
        N = a, a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null }, O === null ? M.memoizedState = O = a : O = O.next = a;
      }
      return O;
    }
    function Vh(a, b) {
      return typeof b == "function" ? b(a) : b;
    }
    function Wh(a) {
      var b = Uh(), c = b.queue;
      if (c === null)
        throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = N, e = d.baseQueue, f = c.pending;
      if (f !== null) {
        if (e !== null) {
          var g = e.next;
          e.next = f.next, f.next = g;
        }
        d.baseQueue = e = f, c.pending = null;
      }
      if (e !== null) {
        f = e.next, d = d.baseState;
        var h = g = null, k = null, l = f;
        do {
          var m = l.lane;
          if ((Hh & m) === m)
            k !== null && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
          else {
            var q = {
              lane: m,
              action: l.action,
              hasEagerState: l.hasEagerState,
              eagerState: l.eagerState,
              next: null
            };
            k === null ? (h = k = q, g = d) : k = k.next = q, M.lanes |= m, rh |= m;
          }
          l = l.next;
        } while (l !== null && l !== f);
        k === null ? g = d : k.next = h, He(d, b.memoizedState) || (dh = !0), b.memoizedState = d, b.baseState = g, b.baseQueue = k, c.lastRenderedState = d;
      }
      if (a = c.interleaved, a !== null) {
        e = a;
        do
          f = e.lane, M.lanes |= f, rh |= f, e = e.next;
        while (e !== a);
      } else
        e === null && (c.lanes = 0);
      return [b.memoizedState, c.dispatch];
    }
    function Xh(a) {
      var b = Uh(), c = b.queue;
      if (c === null)
        throw Error(p(311));
      c.lastRenderedReducer = a;
      var d = c.dispatch, e = c.pending, f = b.memoizedState;
      if (e !== null) {
        c.pending = null;
        var g = e = e.next;
        do
          f = a(f, g.action), g = g.next;
        while (g !== e);
        He(f, b.memoizedState) || (dh = !0), b.memoizedState = f, b.baseQueue === null && (b.baseState = f), c.lastRenderedState = f;
      }
      return [f, d];
    }
    function Yh() {
    }
    function Zh(a, b) {
      var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
      if (f && (d.memoizedState = e, dh = !0), d = d.queue, $h(ai.bind(null, c, d, a), [a]), d.getSnapshot !== b || f || O !== null && O.memoizedState.tag & 1) {
        if (c.flags |= 2048, bi(9, ci.bind(null, c, d, e, b), void 0, null), Q === null)
          throw Error(p(349));
        Hh & 30 || di(c, b, e);
      }
      return e;
    }
    function di(a, b, c) {
      a.flags |= 16384, a = { getSnapshot: b, value: c }, b = M.updateQueue, b === null ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, c === null ? b.stores = [a] : c.push(a));
    }
    function ci(a, b, c, d) {
      b.value = c, b.getSnapshot = d, ei(b) && fi(a);
    }
    function ai(a, b, c) {
      return c(function() {
        ei(b) && fi(a);
      });
    }
    function ei(a) {
      var b = a.getSnapshot;
      a = a.value;
      try {
        var c = b();
        return !He(a, c);
      } catch (d) {
        return !0;
      }
    }
    function fi(a) {
      var b = ih(a, 1);
      b !== null && gi(b, a, 1, -1);
    }
    function hi(a) {
      var b = Th();
      return typeof a == "function" && (a = a()), b.memoizedState = b.baseState = a, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a }, b.queue = a, a = a.dispatch = ii.bind(null, M, a), [b.memoizedState, a];
    }
    function bi(a, b, c, d) {
      return a = { tag: a, create: b, destroy: c, deps: d, next: null }, b = M.updateQueue, b === null ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, c === null ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a)), a;
    }
    function ji() {
      return Uh().memoizedState;
    }
    function ki(a, b, c, d) {
      var e = Th();
      M.flags |= a, e.memoizedState = bi(1 | b, c, void 0, d === void 0 ? null : d);
    }
    function li(a, b, c, d) {
      var e = Uh();
      d = d === void 0 ? null : d;
      var f = void 0;
      if (N !== null) {
        var g = N.memoizedState;
        if (f = g.destroy, d !== null && Mh(d, g.deps)) {
          e.memoizedState = bi(b, c, f, d);
          return;
        }
      }
      M.flags |= a, e.memoizedState = bi(1 | b, c, f, d);
    }
    function mi(a, b) {
      return ki(8390656, 8, a, b);
    }
    function $h(a, b) {
      return li(2048, 8, a, b);
    }
    function ni(a, b) {
      return li(4, 2, a, b);
    }
    function oi(a, b) {
      return li(4, 4, a, b);
    }
    function pi(a, b) {
      if (typeof b == "function")
        return a = a(), b(a), function() {
          b(null);
        };
      if (b != null)
        return a = a(), b.current = a, function() {
          b.current = null;
        };
    }
    function qi(a, b, c) {
      return c = c != null ? c.concat([a]) : null, li(4, 4, pi.bind(null, b, a), c);
    }
    function ri() {
    }
    function si(a, b) {
      var c = Uh();
      b = b === void 0 ? null : b;
      var d = c.memoizedState;
      return d !== null && b !== null && Mh(b, d[1]) ? d[0] : (c.memoizedState = [a, b], a);
    }
    function ti(a, b) {
      var c = Uh();
      b = b === void 0 ? null : b;
      var d = c.memoizedState;
      return d !== null && b !== null && Mh(b, d[1]) ? d[0] : (a = a(), c.memoizedState = [a, b], a);
    }
    function ui(a, b, c) {
      return Hh & 21 ? (He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = !0), b) : (a.baseState && (a.baseState = !1, dh = !0), a.memoizedState = c);
    }
    function vi(a, b) {
      var c = C;
      C = c !== 0 && 4 > c ? c : 4, a(!0);
      var d = Gh.transition;
      Gh.transition = {};
      try {
        a(!1), b();
      } finally {
        C = c, Gh.transition = d;
      }
    }
    function wi() {
      return Uh().memoizedState;
    }
    function xi(a, b, c) {
      var d = yi(a);
      if (c = { lane: d, action: c, hasEagerState: !1, eagerState: null, next: null }, zi(a))
        Ai(b, c);
      else if (c = hh(a, b, c, d), c !== null) {
        var e = R();
        gi(c, a, d, e), Bi(c, b, d);
      }
    }
    function ii(a, b, c) {
      var d = yi(a), e = { lane: d, action: c, hasEagerState: !1, eagerState: null, next: null };
      if (zi(a))
        Ai(b, e);
      else {
        var f = a.alternate;
        if (a.lanes === 0 && (f === null || f.lanes === 0) && (f = b.lastRenderedReducer, f !== null))
          try {
            var g = b.lastRenderedState, h = f(g, c);
            if (e.hasEagerState = !0, e.eagerState = h, He(h, g)) {
              var k = b.interleaved;
              k === null ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e), b.interleaved = e;
              return;
            }
          } catch (l) {
          } finally {
          }
        c = hh(a, b, e, d), c !== null && (e = R(), gi(c, a, d, e), Bi(c, b, d));
      }
    }
    function zi(a) {
      var b = a.alternate;
      return a === M || b !== null && b === M;
    }
    function Ai(a, b) {
      Jh = Ih = !0;
      var c = a.pending;
      c === null ? b.next = b : (b.next = c.next, c.next = b), a.pending = b;
    }
    function Bi(a, b, c) {
      if (c & 4194240) {
        var d = b.lanes;
        d &= a.pendingLanes, c |= d, b.lanes = c, Cc(a, c);
      }
    }
    var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: !1 }, Oh = { readContext: eh, useCallback: function(a, b) {
      return Th().memoizedState = [a, b === void 0 ? null : b], a;
    }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
      return c = c != null ? c.concat([a]) : null, ki(
        4194308,
        4,
        pi.bind(null, b, a),
        c
      );
    }, useLayoutEffect: function(a, b) {
      return ki(4194308, 4, a, b);
    }, useInsertionEffect: function(a, b) {
      return ki(4, 2, a, b);
    }, useMemo: function(a, b) {
      var c = Th();
      return b = b === void 0 ? null : b, a = a(), c.memoizedState = [a, b], a;
    }, useReducer: function(a, b, c) {
      var d = Th();
      return b = c !== void 0 ? c(b) : b, d.memoizedState = d.baseState = b, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b }, d.queue = a, a = a.dispatch = xi.bind(null, M, a), [d.memoizedState, a];
    }, useRef: function(a) {
      var b = Th();
      return a = { current: a }, b.memoizedState = a;
    }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
      return Th().memoizedState = a;
    }, useTransition: function() {
      var a = hi(!1), b = a[0];
      return a = vi.bind(null, a[1]), Th().memoizedState = a, [b, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b, c) {
      var d = M, e = Th();
      if (I) {
        if (c === void 0)
          throw Error(p(407));
        c = c();
      } else {
        if (c = b(), Q === null)
          throw Error(p(349));
        Hh & 30 || di(d, b, c);
      }
      e.memoizedState = c;
      var f = { value: c, getSnapshot: b };
      return e.queue = f, mi(ai.bind(
        null,
        d,
        f,
        a
      ), [a]), d.flags |= 2048, bi(9, ci.bind(null, d, f, c, b), void 0, null), c;
    }, useId: function() {
      var a = Th(), b = Q.identifierPrefix;
      if (I) {
        var c = sg, d = rg;
        c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c, b = ":" + b + "R" + c, c = Kh++, 0 < c && (b += "H" + c.toString(32)), b += ":";
      } else
        c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
      return a.memoizedState = b;
    }, unstable_isNewReconciler: !1 }, Ph = {
      readContext: eh,
      useCallback: si,
      useContext: eh,
      useEffect: $h,
      useImperativeHandle: qi,
      useInsertionEffect: ni,
      useLayoutEffect: oi,
      useMemo: ti,
      useReducer: Wh,
      useRef: ji,
      useState: function() {
        return Wh(Vh);
      },
      useDebugValue: ri,
      useDeferredValue: function(a) {
        var b = Uh();
        return ui(b, N.memoizedState, a);
      },
      useTransition: function() {
        var a = Wh(Vh)[0], b = Uh().memoizedState;
        return [a, b];
      },
      useMutableSource: Yh,
      useSyncExternalStore: Zh,
      useId: wi,
      unstable_isNewReconciler: !1
    }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
      return Xh(Vh);
    }, useDebugValue: ri, useDeferredValue: function(a) {
      var b = Uh();
      return N === null ? b.memoizedState = a : ui(b, N.memoizedState, a);
    }, useTransition: function() {
      var a = Xh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: !1 };
    function Ci(a, b) {
      if (a && a.defaultProps) {
        b = A({}, b), a = a.defaultProps;
        for (var c in a)
          b[c] === void 0 && (b[c] = a[c]);
        return b;
      }
      return b;
    }
    function Di(a, b, c, d) {
      b = a.memoizedState, c = c(d, b), c = c == null ? b : A({}, b, c), a.memoizedState = c, a.lanes === 0 && (a.updateQueue.baseState = c);
    }
    var Ei = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : !1;
    }, enqueueSetState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi(a), f = mh(d, e);
      f.payload = b, c != null && (f.callback = c), b = nh(a, f, e), b !== null && (gi(b, a, e, d), oh(b, a, e));
    }, enqueueReplaceState: function(a, b, c) {
      a = a._reactInternals;
      var d = R(), e = yi(a), f = mh(d, e);
      f.tag = 1, f.payload = b, c != null && (f.callback = c), b = nh(a, f, e), b !== null && (gi(b, a, e, d), oh(b, a, e));
    }, enqueueForceUpdate: function(a, b) {
      a = a._reactInternals;
      var c = R(), d = yi(a), e = mh(c, d);
      e.tag = 2, b != null && (e.callback = b), b = nh(a, e, d), b !== null && (gi(b, a, d, c), oh(b, a, d));
    } };
    function Fi(a, b, c, d, e, f, g) {
      return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : !0;
    }
    function Gi(a, b, c) {
      var d = !1, e = Vf, f = b.contextType;
      return typeof f == "object" && f !== null ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = d != null) ? Yf(a, e) : Vf), b = new b(c, f), a.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null, b.updater = Ei, a.stateNode = b, b._reactInternals = a, d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f), b;
    }
    function Hi(a, b, c, d) {
      a = b.state, typeof b.componentWillReceiveProps == "function" && b.componentWillReceiveProps(c, d), typeof b.UNSAFE_componentWillReceiveProps == "function" && b.UNSAFE_componentWillReceiveProps(c, d), b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
    }
    function Ii(a, b, c, d) {
      var e = a.stateNode;
      e.props = c, e.state = a.memoizedState, e.refs = {}, kh(a);
      var f = b.contextType;
      typeof f == "object" && f !== null ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f)), e.state = a.memoizedState, f = b.getDerivedStateFromProps, typeof f == "function" && (Di(a, b, f, c), e.state = a.memoizedState), typeof b.getDerivedStateFromProps == "function" || typeof e.getSnapshotBeforeUpdate == "function" || typeof e.UNSAFE_componentWillMount != "function" && typeof e.componentWillMount != "function" || (b = e.state, typeof e.componentWillMount == "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount == "function" && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState), typeof e.componentDidMount == "function" && (a.flags |= 4194308);
    }
    function Ji(a, b) {
      try {
        var c = "", d = b;
        do
          c += Pa(d), d = d.return;
        while (d);
        var e = c;
      } catch (f) {
        e = `
Error generating stack: ` + f.message + `
` + f.stack;
      }
      return { value: a, source: b, stack: e, digest: null };
    }
    function Ki(a, b, c) {
      return { value: a, source: null, stack: c != null ? c : null, digest: b != null ? b : null };
    }
    function Li(a, b) {
      try {
        console.error(b.value);
      } catch (c) {
        setTimeout(function() {
          throw c;
        });
      }
    }
    var Mi = typeof WeakMap == "function" ? WeakMap : Map;
    function Ni(a, b, c) {
      c = mh(-1, c), c.tag = 3, c.payload = { element: null };
      var d = b.value;
      return c.callback = function() {
        Oi || (Oi = !0, Pi = d), Li(a, b);
      }, c;
    }
    function Qi(a, b, c) {
      c = mh(-1, c), c.tag = 3;
      var d = a.type.getDerivedStateFromError;
      if (typeof d == "function") {
        var e = b.value;
        c.payload = function() {
          return d(e);
        }, c.callback = function() {
          Li(a, b);
        };
      }
      var f = a.stateNode;
      return f !== null && typeof f.componentDidCatch == "function" && (c.callback = function() {
        Li(a, b), typeof d != "function" && (Ri === null ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
        var c2 = b.stack;
        this.componentDidCatch(b.value, { componentStack: c2 !== null ? c2 : "" });
      }), c;
    }
    function Si(a, b, c) {
      var d = a.pingCache;
      if (d === null) {
        d = a.pingCache = new Mi();
        var e = /* @__PURE__ */ new Set();
        d.set(b, e);
      } else
        e = d.get(b), e === void 0 && (e = /* @__PURE__ */ new Set(), d.set(b, e));
      e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
    }
    function Ui(a) {
      do {
        var b;
        if ((b = a.tag === 13) && (b = a.memoizedState, b = b !== null ? b.dehydrated !== null : !0), b)
          return a;
        a = a.return;
      } while (a !== null);
      return null;
    }
    function Vi(a, b, c, d, e) {
      return a.mode & 1 ? (a.flags |= 65536, a.lanes = e, a) : (a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, c.tag === 1 && (c.alternate === null ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a);
    }
    var Wi = ua.ReactCurrentOwner, dh = !1;
    function Xi(a, b, c, d) {
      b.child = a === null ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
    }
    function Yi(a, b, c, d, e) {
      c = c.render;
      var f = b.ref;
      return ch(b, e), d = Nh(a, b, c, d, f, e), c = Sh(), a !== null && !dh ? (b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e)) : (I && c && vg(b), b.flags |= 1, Xi(a, b, d, e), b.child);
    }
    function $i(a, b, c, d, e) {
      if (a === null) {
        var f = c.type;
        return typeof f == "function" && !aj(f) && f.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0 ? (b.tag = 15, b.type = f, bj(a, b, f, d, e)) : (a = Rg(c.type, null, d, b, b.mode, e), a.ref = b.ref, a.return = b, b.child = a);
      }
      if (f = a.child, !(a.lanes & e)) {
        var g = f.memoizedProps;
        if (c = c.compare, c = c !== null ? c : Ie, c(g, d) && a.ref === b.ref)
          return Zi(a, b, e);
      }
      return b.flags |= 1, a = Pg(f, d), a.ref = b.ref, a.return = b, b.child = a;
    }
    function bj(a, b, c, d, e) {
      if (a !== null) {
        var f = a.memoizedProps;
        if (Ie(f, d) && a.ref === b.ref)
          if (dh = !1, b.pendingProps = d = f, (a.lanes & e) !== 0)
            a.flags & 131072 && (dh = !0);
          else
            return b.lanes = a.lanes, Zi(a, b, e);
      }
      return cj(a, b, c, d, e);
    }
    function dj(a, b, c) {
      var d = b.pendingProps, e = d.children, f = a !== null ? a.memoizedState : null;
      if (d.mode === "hidden")
        if (!(b.mode & 1))
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
        else {
          if (!(c & 1073741824))
            return a = f !== null ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, d = f !== null ? f.baseLanes : c, G(ej, fj), fj |= d;
        }
      else
        f !== null ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
      return Xi(a, b, e, c), b.child;
    }
    function gj(a, b) {
      var c = b.ref;
      (a === null && c !== null || a !== null && a.ref !== c) && (b.flags |= 512, b.flags |= 2097152);
    }
    function cj(a, b, c, d, e) {
      var f = Zf(c) ? Xf : H.current;
      return f = Yf(b, f), ch(b, e), c = Nh(a, b, c, d, f, e), d = Sh(), a !== null && !dh ? (b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e)) : (I && d && vg(b), b.flags |= 1, Xi(a, b, c, e), b.child);
    }
    function hj(a, b, c, d, e) {
      if (Zf(c)) {
        var f = !0;
        cg(b);
      } else
        f = !1;
      if (ch(b, e), b.stateNode === null)
        ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = !0;
      else if (a === null) {
        var g = b.stateNode, h = b.memoizedProps;
        g.props = h;
        var k = g.context, l = c.contextType;
        typeof l == "object" && l !== null ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
        var m = c.getDerivedStateFromProps, q = typeof m == "function" || typeof g.getSnapshotBeforeUpdate == "function";
        q || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (h !== d || k !== l) && Hi(b, g, d, l), jh = !1;
        var r = b.memoizedState;
        g.state = r, qh(b, d, g, e), k = b.memoizedState, h !== d || r !== k || Wf.current || jh ? (typeof m == "function" && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount == "function" && (b.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : (typeof g.componentDidMount == "function" && (b.flags |= 4194308), d = !1);
      } else {
        g = b.stateNode, lh(a, b), h = b.memoizedProps, l = b.type === b.elementType ? h : Ci(b.type, h), g.props = l, q = b.pendingProps, r = g.context, k = c.contextType, typeof k == "object" && k !== null ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
        var y = c.getDerivedStateFromProps;
        (m = typeof y == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (h !== q || r !== k) && Hi(b, g, d, k), jh = !1, r = b.memoizedState, g.state = r, qh(b, d, g, e);
        var n = b.memoizedState;
        h !== q || r !== n || Wf.current || jh ? (typeof y == "function" && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || !1) ? (m || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(d, n, k), typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(d, n, k)), typeof g.componentDidUpdate == "function" && (b.flags |= 4), typeof g.getSnapshotBeforeUpdate == "function" && (b.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : (typeof g.componentDidUpdate != "function" || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = !1);
      }
      return jj(a, b, c, d, f, e);
    }
    function jj(a, b, c, d, e, f) {
      gj(a, b);
      var g = (b.flags & 128) !== 0;
      if (!d && !g)
        return e && dg(b, c, !1), Zi(a, b, f);
      d = b.stateNode, Wi.current = b;
      var h = g && typeof c.getDerivedStateFromError != "function" ? null : d.render();
      return b.flags |= 1, a !== null && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f), b.memoizedState = d.state, e && dg(b, c, !0), b.child;
    }
    function kj(a) {
      var b = a.stateNode;
      b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, !1), yh(a, b.containerInfo);
    }
    function lj(a, b, c, d, e) {
      return Ig(), Jg(e), b.flags |= 256, Xi(a, b, c, d), b.child;
    }
    var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function nj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function oj(a, b, c) {
      var d = b.pendingProps, e = L.current, f = !1, g = (b.flags & 128) !== 0, h;
      if ((h = g) || (h = a !== null && a.memoizedState === null ? !1 : (e & 2) !== 0), h ? (f = !0, b.flags &= -129) : (a === null || a.memoizedState !== null) && (e |= 1), G(L, e & 1), a === null)
        return Eg(b), a = b.memoizedState, a !== null && (a = a.dehydrated, a !== null) ? (b.mode & 1 ? a.data === "$!" ? b.lanes = 8 : b.lanes = 1073741824 : b.lanes = 1, null) : (g = d.children, a = d.fallback, f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, !(d & 1) && f !== null ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g));
      if (e = a.memoizedState, e !== null && (h = e.dehydrated, h !== null))
        return rj(a, b, g, d, h, e, c);
      if (f) {
        f = d.fallback, g = b.mode, e = a.child, h = e.sibling;
        var k = { mode: "hidden", children: d.children };
        return !(g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064), h !== null ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2), f.return = b, d.return = b, d.sibling = f, b.child = d, d = f, f = b.child, g = a.child.memoizedState, g = g === null ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions }, f.memoizedState = g, f.childLanes = a.childLanes & ~c, b.memoizedState = mj, d;
      }
      return f = a.child, a = f.sibling, d = Pg(f, { mode: "visible", children: d.children }), !(b.mode & 1) && (d.lanes = c), d.return = b, d.sibling = null, a !== null && (c = b.deletions, c === null ? (b.deletions = [a], b.flags |= 16) : c.push(a)), b.child = d, b.memoizedState = null, d;
    }
    function qj(a, b) {
      return b = pj({ mode: "visible", children: b }, a.mode, 0, null), b.return = a, a.child = b;
    }
    function sj(a, b, c, d) {
      return d !== null && Jg(d), Ug(b, a.child, null, c), a = qj(b, b.pendingProps.children), a.flags |= 2, b.memoizedState = null, a;
    }
    function rj(a, b, c, d, e, f, g) {
      if (c)
        return b.flags & 256 ? (b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d)) : b.memoizedState !== null ? (b.child = a.child, b.flags |= 128, null) : (f = d.fallback, e = b.mode, d = pj({ mode: "visible", children: d.children }, e, 0, null), f = Tg(f, e, g, null), f.flags |= 2, d.return = b, f.return = b, d.sibling = f, b.child = d, b.mode & 1 && Ug(b, a.child, null, g), b.child.memoizedState = nj(g), b.memoizedState = mj, f);
      if (!(b.mode & 1))
        return sj(a, b, g, null);
      if (e.data === "$!") {
        if (d = e.nextSibling && e.nextSibling.dataset, d)
          var h = d.dgst;
        return d = h, f = Error(p(419)), d = Ki(f, d, void 0), sj(a, b, g, d);
      }
      if (h = (g & a.childLanes) !== 0, dh || h) {
        if (d = Q, d !== null) {
          switch (g & -g) {
            case 4:
              e = 2;
              break;
            case 16:
              e = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e = 32;
              break;
            case 536870912:
              e = 268435456;
              break;
            default:
              e = 0;
          }
          e = e & (d.suspendedLanes | g) ? 0 : e, e !== 0 && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
        }
        return tj(), d = Ki(Error(p(421))), sj(a, b, g, d);
      }
      return e.data === "$?" ? (b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null) : (a = f.treeContext, yg = Lf(e.nextSibling), xg = b, I = !0, zg = null, a !== null && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b), b = qj(b, d.children), b.flags |= 4096, b);
    }
    function vj(a, b, c) {
      a.lanes |= b;
      var d = a.alternate;
      d !== null && (d.lanes |= b), bh(a.return, b, c);
    }
    function wj(a, b, c, d, e) {
      var f = a.memoizedState;
      f === null ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
    }
    function xj(a, b, c) {
      var d = b.pendingProps, e = d.revealOrder, f = d.tail;
      if (Xi(a, b, d.children, c), d = L.current, d & 2)
        d = d & 1 | 2, b.flags |= 128;
      else {
        if (a !== null && a.flags & 128)
          a:
            for (a = b.child; a !== null; ) {
              if (a.tag === 13)
                a.memoizedState !== null && vj(a, c, b);
              else if (a.tag === 19)
                vj(a, c, b);
              else if (a.child !== null) {
                a.child.return = a, a = a.child;
                continue;
              }
              if (a === b)
                break a;
              for (; a.sibling === null; ) {
                if (a.return === null || a.return === b)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return, a = a.sibling;
            }
        d &= 1;
      }
      if (G(L, d), !(b.mode & 1))
        b.memoizedState = null;
      else
        switch (e) {
          case "forwards":
            for (c = b.child, e = null; c !== null; )
              a = c.alternate, a !== null && Ch(a) === null && (e = c), c = c.sibling;
            c = e, c === null ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null), wj(b, !1, e, c, f);
            break;
          case "backwards":
            for (c = null, e = b.child, b.child = null; e !== null; ) {
              if (a = e.alternate, a !== null && Ch(a) === null) {
                b.child = e;
                break;
              }
              a = e.sibling, e.sibling = c, c = e, e = a;
            }
            wj(b, !0, c, null, f);
            break;
          case "together":
            wj(b, !1, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function ij(a, b) {
      !(b.mode & 1) && a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
    }
    function Zi(a, b, c) {
      if (a !== null && (b.dependencies = a.dependencies), rh |= b.lanes, !(c & b.childLanes))
        return null;
      if (a !== null && b.child !== a.child)
        throw Error(p(153));
      if (b.child !== null) {
        for (a = b.child, c = Pg(a, a.pendingProps), b.child = c, c.return = b; a.sibling !== null; )
          a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
        c.sibling = null;
      }
      return b.child;
    }
    function yj(a, b, c) {
      switch (b.tag) {
        case 3:
          kj(b), Ig();
          break;
        case 5:
          Ah(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          yh(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d = b.type._context, e = b.memoizedProps.value;
          G(Wg, d._currentValue), d._currentValue = e;
          break;
        case 13:
          if (d = b.memoizedState, d !== null)
            return d.dehydrated !== null ? (G(L, L.current & 1), b.flags |= 128, null) : c & b.child.childLanes ? oj(a, b, c) : (G(L, L.current & 1), a = Zi(a, b, c), a !== null ? a.sibling : null);
          G(L, L.current & 1);
          break;
        case 19:
          if (d = (c & b.childLanes) !== 0, a.flags & 128) {
            if (d)
              return xj(a, b, c);
            b.flags |= 128;
          }
          if (e = b.memoizedState, e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null), G(L, L.current), d)
            break;
          return null;
        case 22:
        case 23:
          return b.lanes = 0, dj(a, b, c);
      }
      return Zi(a, b, c);
    }
    var zj, Aj, Bj, Cj;
    zj = function(a, b) {
      for (var c = b.child; c !== null; ) {
        if (c.tag === 5 || c.tag === 6)
          a.appendChild(c.stateNode);
        else if (c.tag !== 4 && c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === b)
          break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === b)
            return;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
    };
    Aj = function() {
    };
    Bj = function(a, b, c, d) {
      var e = a.memoizedProps;
      if (e !== d) {
        a = b.stateNode, xh(uh.current);
        var f = null;
        switch (c) {
          case "input":
            e = Ya(a, e), d = Ya(a, d), f = [];
            break;
          case "select":
            e = A({}, e, { value: void 0 }), d = A({}, d, { value: void 0 }), f = [];
            break;
          case "textarea":
            e = gb(a, e), d = gb(a, d), f = [];
            break;
          default:
            typeof e.onClick != "function" && typeof d.onClick == "function" && (a.onclick = Bf);
        }
        ub(c, d);
        var g;
        c = null;
        for (l in e)
          if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && e[l] != null)
            if (l === "style") {
              var h = e[l];
              for (g in h)
                h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
            } else
              l !== "dangerouslySetInnerHTML" && l !== "children" && l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
        for (l in d) {
          var k = d[l];
          if (h = e != null ? e[l] : void 0, d.hasOwnProperty(l) && k !== h && (k != null || h != null))
            if (l === "style")
              if (h) {
                for (g in h)
                  !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                for (g in k)
                  k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
              } else
                c || (f || (f = []), f.push(
                  l,
                  c
                )), c = k;
            else
              l === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, k != null && h !== k && (f = f || []).push(l, k)) : l === "children" ? typeof k != "string" && typeof k != "number" || (f = f || []).push(l, "" + k) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && (ea.hasOwnProperty(l) ? (k != null && l === "onScroll" && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
        }
        c && (f = f || []).push("style", c);
        var l = f;
        (b.updateQueue = l) && (b.flags |= 4);
      }
    };
    Cj = function(a, b, c, d) {
      c !== d && (b.flags |= 4);
    };
    function Dj(a, b) {
      if (!I)
        switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; b !== null; )
              b.alternate !== null && (c = b), b = b.sibling;
            c === null ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; c !== null; )
              c.alternate !== null && (d = c), c = c.sibling;
            d === null ? b || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
    }
    function S(a) {
      var b = a.alternate !== null && a.alternate.child === a.child, c = 0, d = 0;
      if (b)
        for (var e = a.child; e !== null; )
          c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
      else
        for (e = a.child; e !== null; )
          c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
      return a.subtreeFlags |= d, a.childLanes = c, b;
    }
    function Ej(a, b, c) {
      var d = b.pendingProps;
      switch (wg(b), b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          return d = b.stateNode, zh(), E(Wf), E(H), Eh(), d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null), (a === null || a.child === null) && (Gg(b) ? b.flags |= 4 : a === null || a.memoizedState.isDehydrated && !(b.flags & 256) || (b.flags |= 1024, zg !== null && (Fj(zg), zg = null))), Aj(a, b), S(b), null;
        case 5:
          Bh(b);
          var e = xh(wh.current);
          if (c = b.type, a !== null && b.stateNode != null)
            Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d) {
              if (b.stateNode === null)
                throw Error(p(166));
              return S(b), null;
            }
            if (a = xh(uh.current), Gg(b)) {
              d = b.stateNode, c = b.type;
              var f = b.memoizedProps;
              switch (d[Of] = b, d[Pf] = f, a = (b.mode & 1) !== 0, c) {
                case "dialog":
                  D("cancel", d), D("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d);
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++)
                    D(lf[e], d);
                  break;
                case "source":
                  D("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d
                  ), D("load", d);
                  break;
                case "details":
                  D("toggle", d);
                  break;
                case "input":
                  Za(d, f), D("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f.multiple }, D("invalid", d);
                  break;
                case "textarea":
                  hb(d, f), D("invalid", d);
              }
              ub(c, f), e = null;
              for (var g in f)
                if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  g === "children" ? typeof h == "string" ? d.textContent !== h && (f.suppressHydrationWarning !== !0 && Af(d.textContent, h, a), e = ["children", h]) : typeof h == "number" && d.textContent !== "" + h && (f.suppressHydrationWarning !== !0 && Af(
                    d.textContent,
                    h,
                    a
                  ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && h != null && g === "onScroll" && D("scroll", d);
                }
              switch (c) {
                case "input":
                  Va(d), db(d, f, !0);
                  break;
                case "textarea":
                  Va(d), jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  typeof f.onClick == "function" && (d.onclick = Bf);
              }
              d = e, b.updateQueue = d, d !== null && (b.flags |= 4);
            } else {
              g = e.nodeType === 9 ? e : e.ownerDocument, a === "http://www.w3.org/1999/xhtml" && (a = kb(c)), a === "http://www.w3.org/1999/xhtml" ? c === "script" ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : typeof d.is == "string" ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), c === "select" && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c), a[Of] = b, a[Pf] = d, zj(a, b, !1, !1), b.stateNode = a;
              a: {
                switch (g = vb(c, d), c) {
                  case "dialog":
                    D("cancel", a), D("close", a), e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a), e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++)
                      D(lf[e], a);
                    e = d;
                    break;
                  case "source":
                    D("error", a), e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    ), D("load", a), e = d;
                    break;
                  case "details":
                    D("toggle", a), e = d;
                    break;
                  case "input":
                    Za(a, d), e = Ya(a, d), D("invalid", a);
                    break;
                  case "option":
                    e = d;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d.multiple }, e = A({}, d, { value: void 0 }), D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d), e = gb(a, d), D("invalid", a);
                    break;
                  default:
                    e = d;
                }
                ub(c, e), h = e;
                for (f in h)
                  if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    f === "style" ? sb(a, k) : f === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, k != null && nb(a, k)) : f === "children" ? typeof k == "string" ? (c !== "textarea" || k !== "") && ob(a, k) : typeof k == "number" && ob(a, "" + k) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (ea.hasOwnProperty(f) ? k != null && f === "onScroll" && D("scroll", a) : k != null && ta(a, f, k, g));
                  }
                switch (c) {
                  case "input":
                    Va(a), db(a, d, !1);
                    break;
                  case "textarea":
                    Va(a), jb(a);
                    break;
                  case "option":
                    d.value != null && a.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a.multiple = !!d.multiple, f = d.value, f != null ? fb(a, !!d.multiple, f, !1) : d.defaultValue != null && fb(
                      a,
                      !!d.multiple,
                      d.defaultValue,
                      !0
                    );
                    break;
                  default:
                    typeof e.onClick == "function" && (a.onclick = Bf);
                }
                switch (c) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d = !!d.autoFocus;
                    break a;
                  case "img":
                    d = !0;
                    break a;
                  default:
                    d = !1;
                }
              }
              d && (b.flags |= 4);
            }
            b.ref !== null && (b.flags |= 512, b.flags |= 2097152);
          }
          return S(b), null;
        case 6:
          if (a && b.stateNode != null)
            Cj(a, b, a.memoizedProps, d);
          else {
            if (typeof d != "string" && b.stateNode === null)
              throw Error(p(166));
            if (c = xh(wh.current), xh(uh.current), Gg(b)) {
              if (d = b.stateNode, c = b.memoizedProps, d[Of] = b, (f = d.nodeValue !== c) && (a = xg, a !== null))
                switch (a.tag) {
                  case 3:
                    Af(d.nodeValue, c, (a.mode & 1) !== 0);
                    break;
                  case 5:
                    a.memoizedProps.suppressHydrationWarning !== !0 && Af(d.nodeValue, c, (a.mode & 1) !== 0);
                }
              f && (b.flags |= 4);
            } else
              d = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
          }
          return S(b), null;
        case 13:
          if (E(L), d = b.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
            if (I && yg !== null && b.mode & 1 && !(b.flags & 128))
              Hg(), Ig(), b.flags |= 98560, f = !1;
            else if (f = Gg(b), d !== null && d.dehydrated !== null) {
              if (a === null) {
                if (!f)
                  throw Error(p(318));
                if (f = b.memoizedState, f = f !== null ? f.dehydrated : null, !f)
                  throw Error(p(317));
                f[Of] = b;
              } else
                Ig(), !(b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b), f = !1;
            } else
              zg !== null && (Fj(zg), zg = null), f = !0;
            if (!f)
              return b.flags & 65536 ? b : null;
          }
          return b.flags & 128 ? (b.lanes = c, b) : (d = d !== null, d !== (a !== null && a.memoizedState !== null) && d && (b.child.flags |= 8192, b.mode & 1 && (a === null || L.current & 1 ? T === 0 && (T = 3) : tj())), b.updateQueue !== null && (b.flags |= 4), S(b), null);
        case 4:
          return zh(), Aj(a, b), a === null && sf(b.stateNode.containerInfo), S(b), null;
        case 10:
          return ah(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          if (E(L), f = b.memoizedState, f === null)
            return S(b), null;
          if (d = (b.flags & 128) !== 0, g = f.rendering, g === null)
            if (d)
              Dj(f, !1);
            else {
              if (T !== 0 || a !== null && a.flags & 128)
                for (a = b.child; a !== null; ) {
                  if (g = Ch(a), g !== null) {
                    for (b.flags |= 128, Dj(f, !1), d = g.updateQueue, d !== null && (b.updateQueue = d, b.flags |= 4), b.subtreeFlags = 0, d = c, c = b.child; c !== null; )
                      f = c, a = d, f.flags &= 14680066, g = f.alternate, g === null ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                    return G(L, L.current & 1 | 2), b.child;
                  }
                  a = a.sibling;
                }
              f.tail !== null && B() > Gj && (b.flags |= 128, d = !0, Dj(f, !1), b.lanes = 4194304);
            }
          else {
            if (!d)
              if (a = Ch(g), a !== null) {
                if (b.flags |= 128, d = !0, c = a.updateQueue, c !== null && (b.updateQueue = c, b.flags |= 4), Dj(f, !0), f.tail === null && f.tailMode === "hidden" && !g.alternate && !I)
                  return S(b), null;
              } else
                2 * B() - f.renderingStartTime > Gj && c !== 1073741824 && (b.flags |= 128, d = !0, Dj(f, !1), b.lanes = 4194304);
            f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, c !== null ? c.sibling = g : b.child = g, f.last = g);
          }
          return f.tail !== null ? (b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b) : (S(b), null);
        case 22:
        case 23:
          return Hj(), d = b.memoizedState !== null, a !== null && a.memoizedState !== null !== d && (b.flags |= 8192), d && b.mode & 1 ? fj & 1073741824 && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p(156, b.tag));
    }
    function Ij(a, b) {
      switch (wg(b), b.tag) {
        case 1:
          return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 3:
          return zh(), E(Wf), E(H), Eh(), a = b.flags, a & 65536 && !(a & 128) ? (b.flags = a & -65537 | 128, b) : null;
        case 5:
          return Bh(b), null;
        case 13:
          if (E(L), a = b.memoizedState, a !== null && a.dehydrated !== null) {
            if (b.alternate === null)
              throw Error(p(340));
            Ig();
          }
          return a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
        case 19:
          return E(L), null;
        case 4:
          return zh(), null;
        case 10:
          return ah(b.type._context), null;
        case 22:
        case 23:
          return Hj(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Jj = !1, U = !1, Kj = typeof WeakSet == "function" ? WeakSet : Set, V = null;
    function Lj(a, b) {
      var c = a.ref;
      if (c !== null)
        if (typeof c == "function")
          try {
            c(null);
          } catch (d) {
            W(a, b, d);
          }
        else
          c.current = null;
    }
    function Mj(a, b, c) {
      try {
        c();
      } catch (d) {
        W(a, b, d);
      }
    }
    var Nj = !1;
    function Oj(a, b) {
      if (Cf = dd, a = Me(), Ne(a)) {
        if ("selectionStart" in a)
          var c = { start: a.selectionStart, end: a.selectionEnd };
        else
          a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && d.rangeCount !== 0) {
              c = d.anchorNode;
              var e = d.anchorOffset, f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch (F) {
                c = null;
                break a;
              }
              var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
              b:
                for (; ; ) {
                  for (var y; q !== c || e !== 0 && q.nodeType !== 3 || (h = g + e), q !== f || d !== 0 && q.nodeType !== 3 || (k = g + d), q.nodeType === 3 && (g += q.nodeValue.length), (y = q.firstChild) !== null; )
                    r = q, q = y;
                  for (; ; ) {
                    if (q === a)
                      break b;
                    if (r === c && ++l === e && (h = g), r === f && ++m === d && (k = g), (y = q.nextSibling) !== null)
                      break;
                    q = r, r = q.parentNode;
                  }
                  q = y;
                }
              c = h === -1 || k === -1 ? null : { start: h, end: k };
            } else
              c = null;
          }
        c = c || { start: 0, end: 0 };
      } else
        c = null;
      for (Df = { focusedElem: a, selectionRange: c }, dd = !1, V = b; V !== null; )
        if (b = V, a = b.child, (b.subtreeFlags & 1028) !== 0 && a !== null)
          a.return = b, V = a;
        else
          for (; V !== null; ) {
            b = V;
            try {
              var n = b.alternate;
              if (b.flags & 1024)
                switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (n !== null) {
                      var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                      x.__reactInternalSnapshotBeforeUpdate = w;
                    }
                    break;
                  case 3:
                    var u = b.stateNode.containerInfo;
                    u.nodeType === 1 ? u.textContent = "" : u.nodeType === 9 && u.documentElement && u.removeChild(u.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p(163));
                }
            } catch (F) {
              W(b, b.return, F);
            }
            if (a = b.sibling, a !== null) {
              a.return = b.return, V = a;
              break;
            }
            V = b.return;
          }
      return n = Nj, Nj = !1, n;
    }
    function Pj(a, b, c) {
      var d = b.updateQueue;
      if (d = d !== null ? d.lastEffect : null, d !== null) {
        var e = d = d.next;
        do {
          if ((e.tag & a) === a) {
            var f = e.destroy;
            e.destroy = void 0, f !== void 0 && Mj(b, c, f);
          }
          e = e.next;
        } while (e !== d);
      }
    }
    function Qj(a, b) {
      if (b = b.updateQueue, b = b !== null ? b.lastEffect : null, b !== null) {
        var c = b = b.next;
        do {
          if ((c.tag & a) === a) {
            var d = c.create;
            c.destroy = d();
          }
          c = c.next;
        } while (c !== b);
      }
    }
    function Rj(a) {
      var b = a.ref;
      if (b !== null) {
        var c = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c;
            break;
          default:
            a = c;
        }
        typeof b == "function" ? b(a) : b.current = a;
      }
    }
    function Sj(a) {
      var b = a.alternate;
      b !== null && (a.alternate = null, Sj(b)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (b = a.stateNode, b !== null && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf])), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
    }
    function Tj(a) {
      return a.tag === 5 || a.tag === 3 || a.tag === 4;
    }
    function Uj(a) {
      a:
        for (; ; ) {
          for (; a.sibling === null; ) {
            if (a.return === null || Tj(a.return))
              return null;
            a = a.return;
          }
          for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
            if (a.flags & 2 || a.child === null || a.tag === 4)
              continue a;
            a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2))
            return a.stateNode;
        }
    }
    function Vj(a, b, c) {
      var d = a.tag;
      if (d === 5 || d === 6)
        a = a.stateNode, b ? c.nodeType === 8 ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (c.nodeType === 8 ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, c != null || b.onclick !== null || (b.onclick = Bf));
      else if (d !== 4 && (a = a.child, a !== null))
        for (Vj(a, b, c), a = a.sibling; a !== null; )
          Vj(a, b, c), a = a.sibling;
    }
    function Wj(a, b, c) {
      var d = a.tag;
      if (d === 5 || d === 6)
        a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
      else if (d !== 4 && (a = a.child, a !== null))
        for (Wj(a, b, c), a = a.sibling; a !== null; )
          Wj(a, b, c), a = a.sibling;
    }
    var X = null, Xj = !1;
    function Yj(a, b, c) {
      for (c = c.child; c !== null; )
        Zj(a, b, c), c = c.sibling;
    }
    function Zj(a, b, c) {
      if (lc && typeof lc.onCommitFiberUnmount == "function")
        try {
          lc.onCommitFiberUnmount(kc, c);
        } catch (h) {
        }
      switch (c.tag) {
        case 5:
          U || Lj(c, b);
        case 6:
          var d = X, e = Xj;
          X = null, Yj(a, b, c), X = d, Xj = e, X !== null && (Xj ? (a = X, c = c.stateNode, a.nodeType === 8 ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
          break;
        case 18:
          X !== null && (Xj ? (a = X, c = c.stateNode, a.nodeType === 8 ? Kf(a.parentNode, c) : a.nodeType === 1 && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
          break;
        case 4:
          d = X, e = Xj, X = c.stateNode.containerInfo, Xj = !0, Yj(a, b, c), X = d, Xj = e;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d = c.updateQueue, d !== null && (d = d.lastEffect, d !== null))) {
            e = d = d.next;
            do {
              var f = e, g = f.destroy;
              f = f.tag, g !== void 0 && (f & 2 || f & 4) && Mj(c, b, g), e = e.next;
            } while (e !== d);
          }
          Yj(a, b, c);
          break;
        case 1:
          if (!U && (Lj(c, b), d = c.stateNode, typeof d.componentWillUnmount == "function"))
            try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
          Yj(a, b, c);
          break;
        case 21:
          Yj(a, b, c);
          break;
        case 22:
          c.mode & 1 ? (U = (d = U) || c.memoizedState !== null, Yj(a, b, c), U = d) : Yj(a, b, c);
          break;
        default:
          Yj(a, b, c);
      }
    }
    function ak(a) {
      var b = a.updateQueue;
      if (b !== null) {
        a.updateQueue = null;
        var c = a.stateNode;
        c === null && (c = a.stateNode = new Kj()), b.forEach(function(b2) {
          var d = bk.bind(null, a, b2);
          c.has(b2) || (c.add(b2), b2.then(d, d));
        });
      }
    }
    function ck(a, b) {
      var c = b.deletions;
      if (c !== null)
        for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b, h = g;
            a:
              for (; h !== null; ) {
                switch (h.tag) {
                  case 5:
                    X = h.stateNode, Xj = !1;
                    break a;
                  case 3:
                    X = h.stateNode.containerInfo, Xj = !0;
                    break a;
                  case 4:
                    X = h.stateNode.containerInfo, Xj = !0;
                    break a;
                }
                h = h.return;
              }
            if (X === null)
              throw Error(p(160));
            Zj(f, g, e), X = null, Xj = !1;
            var k = e.alternate;
            k !== null && (k.return = null), e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
      if (b.subtreeFlags & 12854)
        for (b = b.child; b !== null; )
          dk(b, a), b = b.sibling;
    }
    function dk(a, b) {
      var c = a.alternate, d = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (ck(b, a), ek(a), d & 4) {
            try {
              Pj(3, a, a.return), Qj(3, a);
            } catch (t) {
              W(a, a.return, t);
            }
            try {
              Pj(5, a, a.return);
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 1:
          ck(b, a), ek(a), d & 512 && c !== null && Lj(c, c.return);
          break;
        case 5:
          if (ck(b, a), ek(a), d & 512 && c !== null && Lj(c, c.return), a.flags & 32) {
            var e = a.stateNode;
            try {
              ob(e, "");
            } catch (t) {
              W(a, a.return, t);
            }
          }
          if (d & 4 && (e = a.stateNode, e != null)) {
            var f = a.memoizedProps, g = c !== null ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
            if (a.updateQueue = null, k !== null)
              try {
                h === "input" && f.type === "radio" && f.name != null && ab(e, f), vb(h, g);
                var l = vb(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g], q = k[g + 1];
                  m === "style" ? sb(e, q) : m === "dangerouslySetInnerHTML" ? nb(e, q) : m === "children" ? ob(e, q) : ta(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb(e, f);
                    break;
                  case "textarea":
                    ib(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    y != null ? fb(e, !!f.multiple, y, !1) : r !== !!f.multiple && (f.defaultValue != null ? fb(
                      e,
                      !!f.multiple,
                      f.defaultValue,
                      !0
                    ) : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
                }
                e[Pf] = f;
              } catch (t) {
                W(a, a.return, t);
              }
          }
          break;
        case 6:
          if (ck(b, a), ek(a), d & 4) {
            if (a.stateNode === null)
              throw Error(p(162));
            e = a.stateNode, f = a.memoizedProps;
            try {
              e.nodeValue = f;
            } catch (t) {
              W(a, a.return, t);
            }
          }
          break;
        case 3:
          if (ck(b, a), ek(a), d & 4 && c !== null && c.memoizedState.isDehydrated)
            try {
              bd(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
          break;
        case 4:
          ck(b, a), ek(a);
          break;
        case 13:
          ck(b, a), ek(a), e = a.child, e.flags & 8192 && (f = e.memoizedState !== null, e.stateNode.isHidden = f, !f || e.alternate !== null && e.alternate.memoizedState !== null || (fk = B())), d & 4 && ak(a);
          break;
        case 22:
          if (m = c !== null && c.memoizedState !== null, a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a), ek(a), d & 8192) {
            if (l = a.memoizedState !== null, (a.stateNode.isHidden = l) && !m && a.mode & 1)
              for (V = a, m = a.child; m !== null; ) {
                for (q = V = m; V !== null; ) {
                  switch (r = V, y = r.child, r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r, r.return);
                      break;
                    case 1:
                      Lj(r, r.return);
                      var n = r.stateNode;
                      if (typeof n.componentWillUnmount == "function") {
                        d = r, c = r.return;
                        try {
                          b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Lj(r, r.return);
                      break;
                    case 22:
                      if (r.memoizedState !== null) {
                        gk(q);
                        continue;
                      }
                  }
                  y !== null ? (y.return = r, V = y) : gk(q);
                }
                m = m.sibling;
              }
            a:
              for (m = null, q = a; ; ) {
                if (q.tag === 5) {
                  if (m === null) {
                    m = q;
                    try {
                      e = q.stateNode, l ? (f = e.style, typeof f.setProperty == "function" ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = k != null && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (q.tag === 6) {
                  if (m === null)
                    try {
                      q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                    } catch (t) {
                      W(a, a.return, t);
                    }
                } else if ((q.tag !== 22 && q.tag !== 23 || q.memoizedState === null || q === a) && q.child !== null) {
                  q.child.return = q, q = q.child;
                  continue;
                }
                if (q === a)
                  break a;
                for (; q.sibling === null; ) {
                  if (q.return === null || q.return === a)
                    break a;
                  m === q && (m = null), q = q.return;
                }
                m === q && (m = null), q.sibling.return = q.return, q = q.sibling;
              }
          }
          break;
        case 19:
          ck(b, a), ek(a), d & 4 && ak(a);
          break;
        case 21:
          break;
        default:
          ck(
            b,
            a
          ), ek(a);
      }
    }
    function ek(a) {
      var b = a.flags;
      if (b & 2) {
        try {
          a: {
            for (var c = a.return; c !== null; ) {
              if (Tj(c)) {
                var d = c;
                break a;
              }
              c = c.return;
            }
            throw Error(p(160));
          }
          switch (d.tag) {
            case 5:
              var e = d.stateNode;
              d.flags & 32 && (ob(e, ""), d.flags &= -33);
              var f = Uj(a);
              Wj(a, f, e);
              break;
            case 3:
            case 4:
              var g = d.stateNode.containerInfo, h = Uj(a);
              Vj(a, h, g);
              break;
            default:
              throw Error(p(161));
          }
        } catch (k) {
          W(a, a.return, k);
        }
        a.flags &= -3;
      }
      b & 4096 && (a.flags &= -4097);
    }
    function hk(a, b, c) {
      V = a, ik(a, b, c);
    }
    function ik(a, b, c) {
      for (var d = (a.mode & 1) !== 0; V !== null; ) {
        var e = V, f = e.child;
        if (e.tag === 22 && d) {
          var g = e.memoizedState !== null || Jj;
          if (!g) {
            var h = e.alternate, k = h !== null && h.memoizedState !== null || U;
            h = Jj;
            var l = U;
            if (Jj = g, (U = k) && !l)
              for (V = e; V !== null; )
                g = V, k = g.child, g.tag === 22 && g.memoizedState !== null ? jk(e) : k !== null ? (k.return = g, V = k) : jk(e);
            for (; f !== null; )
              V = f, ik(f, b, c), f = f.sibling;
            V = e, Jj = h, U = l;
          }
          kk(a, b, c);
        } else
          e.subtreeFlags & 8772 && f !== null ? (f.return = e, V = f) : kk(a, b, c);
      }
    }
    function kk(a) {
      for (; V !== null; ) {
        var b = V;
        if (b.flags & 8772) {
          var c = b.alternate;
          try {
            if (b.flags & 8772)
              switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U)
                    if (c === null)
                      d.componentDidMount();
                    else {
                      var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                      d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f = b.updateQueue;
                  f !== null && sh(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (g !== null) {
                    if (c = null, b.child !== null)
                      switch (b.child.tag) {
                        case 5:
                          c = b.child.stateNode;
                          break;
                        case 1:
                          c = b.child.stateNode;
                      }
                    sh(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (c === null && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (b.memoizedState === null) {
                    var l = b.alternate;
                    if (l !== null) {
                      var m = l.memoizedState;
                      if (m !== null) {
                        var q = m.dehydrated;
                        q !== null && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
            U || b.flags & 512 && Rj(b);
          } catch (r) {
            W(b, b.return, r);
          }
        }
        if (b === a) {
          V = null;
          break;
        }
        if (c = b.sibling, c !== null) {
          c.return = b.return, V = c;
          break;
        }
        V = b.return;
      }
    }
    function gk(a) {
      for (; V !== null; ) {
        var b = V;
        if (b === a) {
          V = null;
          break;
        }
        var c = b.sibling;
        if (c !== null) {
          c.return = b.return, V = c;
          break;
        }
        V = b.return;
      }
    }
    function jk(a) {
      for (; V !== null; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c = b.return;
              try {
                Qj(4, b);
              } catch (k) {
                W(b, c, k);
              }
              break;
            case 1:
              var d = b.stateNode;
              if (typeof d.componentDidMount == "function") {
                var e = b.return;
                try {
                  d.componentDidMount();
                } catch (k) {
                  W(b, e, k);
                }
              }
              var f = b.return;
              try {
                Rj(b);
              } catch (k) {
                W(b, f, k);
              }
              break;
            case 5:
              var g = b.return;
              try {
                Rj(b);
              } catch (k) {
                W(b, g, k);
              }
          }
        } catch (k) {
          W(b, b.return, k);
        }
        if (b === a) {
          V = null;
          break;
        }
        var h = b.sibling;
        if (h !== null) {
          h.return = b.return, V = h;
          break;
        }
        V = b.return;
      }
    }
    var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = 1 / 0, uk = null, Oi = !1, Pi = null, Ri = null, vk = !1, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
    function R() {
      return K & 6 ? B() : Ak !== -1 ? Ak : Ak = B();
    }
    function yi(a) {
      return a.mode & 1 ? K & 2 && Z !== 0 ? Z & -Z : Kg.transition !== null ? (Bk === 0 && (Bk = yc()), Bk) : (a = C, a !== 0 || (a = window.event, a = a === void 0 ? 16 : jd(a.type)), a) : 1;
    }
    function gi(a, b, c, d) {
      if (50 < yk)
        throw yk = 0, zk = null, Error(p(185));
      Ac(a, c, d), (!(K & 2) || a !== Q) && (a === Q && (!(K & 2) && (qk |= c), T === 4 && Ck(a, Z)), Dk(a, d), c === 1 && K === 0 && !(b.mode & 1) && (Gj = B() + 500, fg && jg()));
    }
    function Dk(a, b) {
      var c = a.callbackNode;
      wc(a, b);
      var d = uc(a, a === Q ? Z : 0);
      if (d === 0)
        c !== null && bc(c), a.callbackNode = null, a.callbackPriority = 0;
      else if (b = d & -d, a.callbackPriority !== b) {
        if (c != null && bc(c), b === 1)
          a.tag === 0 ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
            !(K & 6) && jg();
          }), c = null;
        else {
          switch (Dc(d)) {
            case 1:
              c = fc;
              break;
            case 4:
              c = gc;
              break;
            case 16:
              c = hc;
              break;
            case 536870912:
              c = jc;
              break;
            default:
              c = hc;
          }
          c = Fk(c, Gk.bind(null, a));
        }
        a.callbackPriority = b, a.callbackNode = c;
      }
    }
    function Gk(a, b) {
      if (Ak = -1, Bk = 0, K & 6)
        throw Error(p(327));
      var c = a.callbackNode;
      if (Hk() && a.callbackNode !== c)
        return null;
      var d = uc(a, a === Q ? Z : 0);
      if (d === 0)
        return null;
      if (d & 30 || d & a.expiredLanes || b)
        b = Ik(a, d);
      else {
        b = d;
        var e = K;
        K |= 2;
        var f = Jk();
        (Q !== a || Z !== b) && (uk = null, Gj = B() + 500, Kk(a, b));
        do
          try {
            Lk();
            break;
          } catch (h) {
            Mk(a, h);
          }
        while (!0);
        $g(), mk.current = f, K = e, Y !== null ? b = 0 : (Q = null, Z = 0, b = T);
      }
      if (b !== 0) {
        if (b === 2 && (e = xc(a), e !== 0 && (d = e, b = Nk(a, e))), b === 1)
          throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        if (b === 6)
          Ck(a, d);
        else {
          if (e = a.current.alternate, !(d & 30) && !Ok(e) && (b = Ik(a, d), b === 2 && (f = xc(a), f !== 0 && (d = f, b = Nk(a, f))), b === 1))
            throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          switch (a.finishedWork = e, a.finishedLanes = d, b) {
            case 0:
            case 1:
              throw Error(p(345));
            case 2:
              Pk(a, tk, uk);
              break;
            case 3:
              if (Ck(a, d), (d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                if (uc(a, 0) !== 0)
                  break;
                if (e = a.suspendedLanes, (e & d) !== d) {
                  R(), a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                break;
              }
              Pk(a, tk, uk);
              break;
            case 4:
              if (Ck(a, d), (d & 4194240) === d)
                break;
              for (b = a.eventTimes, e = -1; 0 < d; ) {
                var g = 31 - oc(d);
                f = 1 << g, g = b[g], g > e && (e = g), d &= ~f;
              }
              if (d = e, d = B() - d, d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d, 10 < d) {
                a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                break;
              }
              Pk(a, tk, uk);
              break;
            case 5:
              Pk(a, tk, uk);
              break;
            default:
              throw Error(p(329));
          }
        }
      }
      return Dk(a, B()), a.callbackNode === c ? Gk.bind(null, a) : null;
    }
    function Nk(a, b) {
      var c = sk;
      return a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256), a = Ik(a, b), a !== 2 && (b = tk, tk = c, b !== null && Fj(b)), a;
    }
    function Fj(a) {
      tk === null ? tk = a : tk.push.apply(tk, a);
    }
    function Ok(a) {
      for (var b = a; ; ) {
        if (b.flags & 16384) {
          var c = b.updateQueue;
          if (c !== null && (c = c.stores, c !== null))
            for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f(), e))
                  return !1;
              } catch (g) {
                return !1;
              }
            }
        }
        if (c = b.child, b.subtreeFlags & 16384 && c !== null)
          c.return = b, b = c;
        else {
          if (b === a)
            break;
          for (; b.sibling === null; ) {
            if (b.return === null || b.return === a)
              return !0;
            b = b.return;
          }
          b.sibling.return = b.return, b = b.sibling;
        }
      }
      return !0;
    }
    function Ck(a, b) {
      for (b &= ~rk, b &= ~qk, a.suspendedLanes |= b, a.pingedLanes &= ~b, a = a.expirationTimes; 0 < b; ) {
        var c = 31 - oc(b), d = 1 << c;
        a[c] = -1, b &= ~d;
      }
    }
    function Ek(a) {
      if (K & 6)
        throw Error(p(327));
      Hk();
      var b = uc(a, 0);
      if (!(b & 1))
        return Dk(a, B()), null;
      var c = Ik(a, b);
      if (a.tag !== 0 && c === 2) {
        var d = xc(a);
        d !== 0 && (b = d, c = Nk(a, d));
      }
      if (c === 1)
        throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
      if (c === 6)
        throw Error(p(345));
      return a.finishedWork = a.current.alternate, a.finishedLanes = b, Pk(a, tk, uk), Dk(a, B()), null;
    }
    function Qk(a, b) {
      var c = K;
      K |= 1;
      try {
        return a(b);
      } finally {
        K = c, K === 0 && (Gj = B() + 500, fg && jg());
      }
    }
    function Rk(a) {
      wk !== null && wk.tag === 0 && !(K & 6) && Hk();
      var b = K;
      K |= 1;
      var c = ok.transition, d = C;
      try {
        if (ok.transition = null, C = 1, a)
          return a();
      } finally {
        C = d, ok.transition = c, K = b, !(K & 6) && jg();
      }
    }
    function Hj() {
      fj = ej.current, E(ej);
    }
    function Kk(a, b) {
      a.finishedWork = null, a.finishedLanes = 0;
      var c = a.timeoutHandle;
      if (c !== -1 && (a.timeoutHandle = -1, Gf(c)), Y !== null)
        for (c = Y.return; c !== null; ) {
          var d = c;
          switch (wg(d), d.tag) {
            case 1:
              d = d.type.childContextTypes, d != null && $f();
              break;
            case 3:
              zh(), E(Wf), E(H), Eh();
              break;
            case 5:
              Bh(d);
              break;
            case 4:
              zh();
              break;
            case 13:
              E(L);
              break;
            case 19:
              E(L);
              break;
            case 10:
              ah(d.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c = c.return;
        }
      if (Q = a, Y = a = Pg(a.current, null), Z = fj = b, T = 0, pk = null, rk = qk = rh = 0, tk = sk = null, fh !== null) {
        for (b = 0; b < fh.length; b++)
          if (c = fh[b], d = c.interleaved, d !== null) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (f !== null) {
              var g = f.next;
              f.next = e, d.next = g;
            }
            c.pending = d;
          }
        fh = null;
      }
      return a;
    }
    function Mk(a, b) {
      do {
        var c = Y;
        try {
          if ($g(), Fh.current = Rh, Ih) {
            for (var d = M.memoizedState; d !== null; ) {
              var e = d.queue;
              e !== null && (e.pending = null), d = d.next;
            }
            Ih = !1;
          }
          if (Hh = 0, O = N = M = null, Jh = !1, Kh = 0, nk.current = null, c === null || c.return === null) {
            T = 1, pk = b, Y = null;
            break;
          }
          a: {
            var f = a, g = c.return, h = c, k = b;
            if (b = Z, h.flags |= 32768, k !== null && typeof k == "object" && typeof k.then == "function") {
              var l = k, m = h, q = m.tag;
              if (!(m.mode & 1) && (q === 0 || q === 11 || q === 15)) {
                var r = m.alternate;
                r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
              }
              var y = Ui(g);
              if (y !== null) {
                y.flags &= -257, Vi(y, g, h, f, b), y.mode & 1 && Si(f, l, b), b = y, k = l;
                var n = b.updateQueue;
                if (n === null) {
                  var t = /* @__PURE__ */ new Set();
                  t.add(k), b.updateQueue = t;
                } else
                  n.add(k);
                break a;
              } else {
                if (!(b & 1)) {
                  Si(f, l, b), tj();
                  break a;
                }
                k = Error(p(426));
              }
            } else if (I && h.mode & 1) {
              var J = Ui(g);
              if (J !== null) {
                !(J.flags & 65536) && (J.flags |= 256), Vi(J, g, h, f, b), Jg(Ji(k, h));
                break a;
              }
            }
            f = k = Ji(k, h), T !== 4 && (T = 2), sk === null ? sk = [f] : sk.push(f), f = g;
            do {
              switch (f.tag) {
                case 3:
                  f.flags |= 65536, b &= -b, f.lanes |= b;
                  var x = Ni(f, k, b);
                  ph(f, x);
                  break a;
                case 1:
                  h = k;
                  var w = f.type, u = f.stateNode;
                  if (!(f.flags & 128) && (typeof w.getDerivedStateFromError == "function" || u !== null && typeof u.componentDidCatch == "function" && (Ri === null || !Ri.has(u)))) {
                    f.flags |= 65536, b &= -b, f.lanes |= b;
                    var F = Qi(f, h, b);
                    ph(f, F);
                    break a;
                  }
              }
              f = f.return;
            } while (f !== null);
          }
          Sk(c);
        } catch (na) {
          b = na, Y === c && c !== null && (Y = c = c.return);
          continue;
        }
        break;
      } while (!0);
    }
    function Jk() {
      var a = mk.current;
      return mk.current = Rh, a === null ? Rh : a;
    }
    function tj() {
      (T === 0 || T === 3 || T === 2) && (T = 4), Q === null || !(rh & 268435455) && !(qk & 268435455) || Ck(Q, Z);
    }
    function Ik(a, b) {
      var c = K;
      K |= 2;
      var d = Jk();
      (Q !== a || Z !== b) && (uk = null, Kk(a, b));
      do
        try {
          Tk();
          break;
        } catch (e) {
          Mk(a, e);
        }
      while (!0);
      if ($g(), K = c, mk.current = d, Y !== null)
        throw Error(p(261));
      return Q = null, Z = 0, T;
    }
    function Tk() {
      for (; Y !== null; )
        Uk(Y);
    }
    function Lk() {
      for (; Y !== null && !cc(); )
        Uk(Y);
    }
    function Uk(a) {
      var b = Vk(a.alternate, a, fj);
      a.memoizedProps = a.pendingProps, b === null ? Sk(a) : Y = b, nk.current = null;
    }
    function Sk(a) {
      var b = a;
      do {
        var c = b.alternate;
        if (a = b.return, b.flags & 32768) {
          if (c = Ij(c, b), c !== null) {
            c.flags &= 32767, Y = c;
            return;
          }
          if (a !== null)
            a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6, Y = null;
            return;
          }
        } else if (c = Ej(c, b, fj), c !== null) {
          Y = c;
          return;
        }
        if (b = b.sibling, b !== null) {
          Y = b;
          return;
        }
        Y = b = a;
      } while (b !== null);
      T === 0 && (T = 5);
    }
    function Pk(a, b, c) {
      var d = C, e = ok.transition;
      try {
        ok.transition = null, C = 1, Wk(a, b, c, d);
      } finally {
        ok.transition = e, C = d;
      }
      return null;
    }
    function Wk(a, b, c, d) {
      do
        Hk();
      while (wk !== null);
      if (K & 6)
        throw Error(p(327));
      c = a.finishedWork;
      var e = a.finishedLanes;
      if (c === null)
        return null;
      if (a.finishedWork = null, a.finishedLanes = 0, c === a.current)
        throw Error(p(177));
      a.callbackNode = null, a.callbackPriority = 0;
      var f = c.lanes | c.childLanes;
      if (Bc(a, f), a === Q && (Y = Q = null, Z = 0), !(c.subtreeFlags & 2064) && !(c.flags & 2064) || vk || (vk = !0, Fk(hc, function() {
        return Hk(), null;
      })), f = (c.flags & 15990) !== 0, c.subtreeFlags & 15990 || f) {
        f = ok.transition, ok.transition = null;
        var g = C;
        C = 1;
        var h = K;
        K |= 4, nk.current = null, Oj(a, c), dk(c, a), Oe(Df), dd = !!Cf, Df = Cf = null, a.current = c, hk(c, a, e), dc(), K = h, C = g, ok.transition = f;
      } else
        a.current = c;
      if (vk && (vk = !1, wk = a, xk = e), f = a.pendingLanes, f === 0 && (Ri = null), mc(c.stateNode, d), Dk(a, B()), b !== null)
        for (d = a.onRecoverableError, c = 0; c < b.length; c++)
          e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
      if (Oi)
        throw Oi = !1, a = Pi, Pi = null, a;
      return xk & 1 && a.tag !== 0 && Hk(), f = a.pendingLanes, f & 1 ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0, jg(), null;
    }
    function Hk() {
      if (wk !== null) {
        var a = Dc(xk), b = ok.transition, c = C;
        try {
          if (ok.transition = null, C = 16 > a ? 16 : a, wk === null)
            var d = !1;
          else {
            if (a = wk, wk = null, xk = 0, K & 6)
              throw Error(p(331));
            var e = K;
            for (K |= 4, V = a.current; V !== null; ) {
              var f = V, g = f.child;
              if (V.flags & 16) {
                var h = f.deletions;
                if (h !== null) {
                  for (var k = 0; k < h.length; k++) {
                    var l = h[k];
                    for (V = l; V !== null; ) {
                      var m = V;
                      switch (m.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(8, m, f);
                      }
                      var q = m.child;
                      if (q !== null)
                        q.return = m, V = q;
                      else
                        for (; V !== null; ) {
                          m = V;
                          var r = m.sibling, y = m.return;
                          if (Sj(m), m === l) {
                            V = null;
                            break;
                          }
                          if (r !== null) {
                            r.return = y, V = r;
                            break;
                          }
                          V = y;
                        }
                    }
                  }
                  var n = f.alternate;
                  if (n !== null) {
                    var t = n.child;
                    if (t !== null) {
                      n.child = null;
                      do {
                        var J = t.sibling;
                        t.sibling = null, t = J;
                      } while (t !== null);
                    }
                  }
                  V = f;
                }
              }
              if (f.subtreeFlags & 2064 && g !== null)
                g.return = f, V = g;
              else
                b:
                  for (; V !== null; ) {
                    if (f = V, f.flags & 2048)
                      switch (f.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(9, f, f.return);
                      }
                    var x = f.sibling;
                    if (x !== null) {
                      x.return = f.return, V = x;
                      break b;
                    }
                    V = f.return;
                  }
            }
            var w = a.current;
            for (V = w; V !== null; ) {
              g = V;
              var u = g.child;
              if (g.subtreeFlags & 2064 && u !== null)
                u.return = g, V = u;
              else
                b:
                  for (g = w; V !== null; ) {
                    if (h = V, h.flags & 2048)
                      try {
                        switch (h.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Qj(9, h);
                        }
                      } catch (na) {
                        W(h, h.return, na);
                      }
                    if (h === g) {
                      V = null;
                      break b;
                    }
                    var F = h.sibling;
                    if (F !== null) {
                      F.return = h.return, V = F;
                      break b;
                    }
                    V = h.return;
                  }
            }
            if (K = e, jg(), lc && typeof lc.onPostCommitFiberRoot == "function")
              try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
            d = !0;
          }
          return d;
        } finally {
          C = c, ok.transition = b;
        }
      }
      return !1;
    }
    function Xk(a, b, c) {
      b = Ji(c, b), b = Ni(a, b, 1), a = nh(a, b, 1), b = R(), a !== null && (Ac(a, 1, b), Dk(a, b));
    }
    function W(a, b, c) {
      if (a.tag === 3)
        Xk(a, a, c);
      else
        for (; b !== null; ) {
          if (b.tag === 3) {
            Xk(b, a, c);
            break;
          } else if (b.tag === 1) {
            var d = b.stateNode;
            if (typeof b.type.getDerivedStateFromError == "function" || typeof d.componentDidCatch == "function" && (Ri === null || !Ri.has(d))) {
              a = Ji(c, a), a = Qi(b, a, 1), b = nh(b, a, 1), a = R(), b !== null && (Ac(b, 1, a), Dk(b, a));
              break;
            }
          }
          b = b.return;
        }
    }
    function Ti(a, b, c) {
      var d = a.pingCache;
      d !== null && d.delete(b), b = R(), a.pingedLanes |= a.suspendedLanes & c, Q === a && (Z & c) === c && (T === 4 || T === 3 && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c), Dk(a, b);
    }
    function Yk(a, b) {
      b === 0 && (a.mode & 1 ? (b = sc, sc <<= 1, !(sc & 130023424) && (sc = 4194304)) : b = 1);
      var c = R();
      a = ih(a, b), a !== null && (Ac(a, b, c), Dk(a, c));
    }
    function uj(a) {
      var b = a.memoizedState, c = 0;
      b !== null && (c = b.retryLane), Yk(a, c);
    }
    function bk(a, b) {
      var c = 0;
      switch (a.tag) {
        case 13:
          var d = a.stateNode, e = a.memoizedState;
          e !== null && (c = e.retryLane);
          break;
        case 19:
          d = a.stateNode;
          break;
        default:
          throw Error(p(314));
      }
      d !== null && d.delete(b), Yk(a, c);
    }
    var Vk;
    Vk = function(a, b, c) {
      if (a !== null)
        if (a.memoizedProps !== b.pendingProps || Wf.current)
          dh = !0;
        else {
          if (!(a.lanes & c) && !(b.flags & 128))
            return dh = !1, yj(a, b, c);
          dh = !!(a.flags & 131072);
        }
      else
        dh = !1, I && b.flags & 1048576 && ug(b, ng, b.index);
      switch (b.lanes = 0, b.tag) {
        case 2:
          var d = b.type;
          ij(a, b), a = b.pendingProps;
          var e = Yf(b, H.current);
          ch(b, c), e = Nh(null, b, d, a, e, c);
          var f = Sh();
          return b.flags |= 1, typeof e == "object" && e !== null && typeof e.render == "function" && e.$$typeof === void 0 ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = !0, cg(b)) : f = !1, b.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, !0, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child), b;
        case 16:
          d = b.elementType;
          a: {
            switch (ij(a, b), a = b.pendingProps, e = d._init, d = e(d._payload), b.type = d, e = b.tag = Zk(d), a = Ci(d, a), e) {
              case 0:
                b = cj(null, b, d, a, c);
                break a;
              case 1:
                b = hj(null, b, d, a, c);
                break a;
              case 11:
                b = Yi(null, b, d, a, c);
                break a;
              case 14:
                b = $i(null, b, d, Ci(d.type, a), c);
                break a;
            }
            throw Error(p(
              306,
              d,
              ""
            ));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
        case 3:
          a: {
            if (kj(b), a === null)
              throw Error(p(387));
            d = b.pendingProps, f = b.memoizedState, e = f.element, lh(a, b), qh(b, d, null, c);
            var g = b.memoizedState;
            if (d = g.element, f.isDehydrated)
              if (f = { element: d, isDehydrated: !1, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ji(Error(p(423)), b), b = lj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ji(Error(p(424)), b), b = lj(a, b, d, c, e);
                break a;
              } else
                for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = !0, zg = null, c = Vg(b, null, d, c), b.child = c; c; )
                  c.flags = c.flags & -3 | 4096, c = c.sibling;
            else {
              if (Ig(), d === e) {
                b = Zi(a, b, c);
                break a;
              }
              Xi(a, b, d, c);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Ah(b), a === null && Eg(b), d = b.type, e = b.pendingProps, f = a !== null ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : f !== null && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
        case 6:
          return a === null && Eg(b), null;
        case 13:
          return oj(a, b, c);
        case 4:
          return yh(b, b.stateNode.containerInfo), d = b.pendingProps, a === null ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
        case 7:
          return Xi(a, b, b.pendingProps, c), b.child;
        case 8:
          return Xi(a, b, b.pendingProps.children, c), b.child;
        case 12:
          return Xi(a, b, b.pendingProps.children, c), b.child;
        case 10:
          a: {
            if (d = b.type._context, e = b.pendingProps, f = b.memoizedProps, g = e.value, G(Wg, d._currentValue), d._currentValue = g, f !== null)
              if (He(f.value, g)) {
                if (f.children === e.children && !Wf.current) {
                  b = Zi(a, b, c);
                  break a;
                }
              } else
                for (f = b.child, f !== null && (f.return = b); f !== null; ) {
                  var h = f.dependencies;
                  if (h !== null) {
                    g = f.child;
                    for (var k = h.firstContext; k !== null; ) {
                      if (k.context === d) {
                        if (f.tag === 1) {
                          k = mh(-1, c & -c), k.tag = 2;
                          var l = f.updateQueue;
                          if (l !== null) {
                            l = l.shared;
                            var m = l.pending;
                            m === null ? k.next = k : (k.next = m.next, m.next = k), l.pending = k;
                          }
                        }
                        f.lanes |= c, k = f.alternate, k !== null && (k.lanes |= c), bh(
                          f.return,
                          c,
                          b
                        ), h.lanes |= c;
                        break;
                      }
                      k = k.next;
                    }
                  } else if (f.tag === 10)
                    g = f.type === b.type ? null : f.child;
                  else if (f.tag === 18) {
                    if (g = f.return, g === null)
                      throw Error(p(341));
                    g.lanes |= c, h = g.alternate, h !== null && (h.lanes |= c), bh(g, c, b), g = f.sibling;
                  } else
                    g = f.child;
                  if (g !== null)
                    g.return = f;
                  else
                    for (g = f; g !== null; ) {
                      if (g === b) {
                        g = null;
                        break;
                      }
                      if (f = g.sibling, f !== null) {
                        f.return = g.return, g = f;
                        break;
                      }
                      g = g.return;
                    }
                  f = g;
                }
            Xi(a, b, e.children, c), b = b.child;
          }
          return b;
        case 9:
          return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
        case 14:
          return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
        case 15:
          return bj(a, b, b.type, b.pendingProps, c);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = !0, cg(b)) : a = !1, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, !0, a, c);
        case 19:
          return xj(a, b, c);
        case 22:
          return dj(a, b, c);
      }
      throw Error(p(156, b.tag));
    };
    function Fk(a, b) {
      return ac(a, b);
    }
    function $k(a, b, c, d) {
      this.tag = a, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = b, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Bg(a, b, c, d) {
      return new $k(a, b, c, d);
    }
    function aj(a) {
      return a = a.prototype, !(!a || !a.isReactComponent);
    }
    function Zk(a) {
      if (typeof a == "function")
        return aj(a) ? 1 : 0;
      if (a != null) {
        if (a = a.$$typeof, a === Da)
          return 11;
        if (a === Ga)
          return 14;
      }
      return 2;
    }
    function Pg(a, b) {
      var c = a.alternate;
      return c === null ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = a.flags & 14680064, c.childLanes = a.childLanes, c.lanes = a.lanes, c.child = a.child, c.memoizedProps = a.memoizedProps, c.memoizedState = a.memoizedState, c.updateQueue = a.updateQueue, b = a.dependencies, c.dependencies = b === null ? null : { lanes: b.lanes, firstContext: b.firstContext }, c.sibling = a.sibling, c.index = a.index, c.ref = a.ref, c;
    }
    function Rg(a, b, c, d, e, f) {
      var g = 2;
      if (d = a, typeof a == "function")
        aj(a) && (g = 1);
      else if (typeof a == "string")
        g = 5;
      else
        a:
          switch (a) {
            case ya:
              return Tg(c.children, e, f, b);
            case za:
              g = 8, e |= 8;
              break;
            case Aa:
              return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
            case Ea:
              return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
            case Fa:
              return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
            case Ia:
              return pj(c, e, f, b);
            default:
              if (typeof a == "object" && a !== null)
                switch (a.$$typeof) {
                  case Ba:
                    g = 10;
                    break a;
                  case Ca:
                    g = 9;
                    break a;
                  case Da:
                    g = 11;
                    break a;
                  case Ga:
                    g = 14;
                    break a;
                  case Ha:
                    g = 16, d = null;
                    break a;
                }
              throw Error(p(130, a == null ? a : typeof a, ""));
          }
      return b = Bg(g, c, b, e), b.elementType = a, b.type = d, b.lanes = f, b;
    }
    function Tg(a, b, c, d) {
      return a = Bg(7, a, d, b), a.lanes = c, a;
    }
    function pj(a, b, c, d) {
      return a = Bg(22, a, d, b), a.elementType = Ia, a.lanes = c, a.stateNode = { isHidden: !1 }, a;
    }
    function Qg(a, b, c) {
      return a = Bg(6, a, null, b), a.lanes = c, a;
    }
    function Sg(a, b, c) {
      return b = Bg(4, a.children !== null ? a.children : [], a.key, b), b.lanes = c, b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation }, b;
    }
    function al(a, b, c, d, e) {
      this.tag = b, this.containerInfo = a, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc(0), this.expirationTimes = zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc(0), this.identifierPrefix = d, this.onRecoverableError = e, this.mutableSourceEagerHydrationData = null;
    }
    function bl(a, b, c, d, e, f, g, h, k) {
      return a = new al(a, b, c, h, k), b === 1 ? (b = 1, f === !0 && (b |= 8)) : b = 0, f = Bg(3, null, null, b), a.current = f, f.stateNode = a, f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null }, kh(f), a;
    }
    function cl(a, b, c) {
      var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: wa, key: d == null ? null : "" + d, children: a, containerInfo: b, implementation: c };
    }
    function dl(a) {
      if (!a)
        return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || a.tag !== 1)
          throw Error(p(170));
        var b = a;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (b !== null);
        throw Error(p(171));
      }
      if (a.tag === 1) {
        var c = a.type;
        if (Zf(c))
          return bg(a, c, b);
      }
      return b;
    }
    function el(a, b, c, d, e, f, g, h, k) {
      return a = bl(c, d, !0, a, e, f, g, h, k), a.context = dl(null), c = a.current, d = R(), e = yi(c), f = mh(d, e), f.callback = b != null ? b : null, nh(c, f, e), a.current.lanes = e, Ac(a, e, d), Dk(a, d), a;
    }
    function fl(a, b, c, d) {
      var e = b.current, f = R(), g = yi(e);
      return c = dl(c), b.context === null ? b.context = c : b.pendingContext = c, b = mh(f, g), b.payload = { element: a }, d = d === void 0 ? null : d, d !== null && (b.callback = d), a = nh(e, b, g), a !== null && (gi(a, e, g, f), oh(a, e, g)), g;
    }
    function gl(a) {
      if (a = a.current, !a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function hl(a, b) {
      if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
        var c = a.retryLane;
        a.retryLane = c !== 0 && c < b ? c : b;
      }
    }
    function il(a, b) {
      hl(a, b), (a = a.alternate) && hl(a, b);
    }
    function jl() {
      return null;
    }
    var kl = typeof reportError == "function" ? reportError : function(a) {
      console.error(a);
    };
    function ll(a) {
      this._internalRoot = a;
    }
    ml.prototype.render = ll.prototype.render = function(a) {
      var b = this._internalRoot;
      if (b === null)
        throw Error(p(409));
      fl(a, b, null, null);
    };
    ml.prototype.unmount = ll.prototype.unmount = function() {
      var a = this._internalRoot;
      if (a !== null) {
        this._internalRoot = null;
        var b = a.containerInfo;
        Rk(function() {
          fl(null, a, null, null);
        }), b[uf] = null;
      }
    };
    function ml(a) {
      this._internalRoot = a;
    }
    ml.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b = Hc();
        a = { blockedOn: null, target: a, priority: b };
        for (var c = 0; c < Qc.length && b !== 0 && b < Qc[c].priority; c++)
          ;
        Qc.splice(c, 0, a), c === 0 && Vc(a);
      }
    };
    function nl(a) {
      return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
    }
    function ol(a) {
      return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
    }
    function pl() {
    }
    function ql(a, b, c, d, e) {
      if (e) {
        if (typeof d == "function") {
          var f = d;
          d = function() {
            var a2 = gl(g);
            f.call(a2);
          };
        }
        var g = el(b, d, a, 0, null, !1, !1, "", pl);
        return a._reactRootContainer = g, a[uf] = g.current, sf(a.nodeType === 8 ? a.parentNode : a), Rk(), g;
      }
      for (; e = a.lastChild; )
        a.removeChild(e);
      if (typeof d == "function") {
        var h = d;
        d = function() {
          var a2 = gl(k);
          h.call(a2);
        };
      }
      var k = bl(a, 0, !1, null, null, !1, !1, "", pl);
      return a._reactRootContainer = k, a[uf] = k.current, sf(a.nodeType === 8 ? a.parentNode : a), Rk(function() {
        fl(b, k, c, d);
      }), k;
    }
    function rl(a, b, c, d, e) {
      var f = c._reactRootContainer;
      if (f) {
        var g = f;
        if (typeof e == "function") {
          var h = e;
          e = function() {
            var a2 = gl(g);
            h.call(a2);
          };
        }
        fl(b, g, a, e);
      } else
        g = ql(c, b, a, e, d);
      return gl(g);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c = tc(b.pendingLanes);
            c !== 0 && (Cc(b, c | 1), Dk(b, B()), !(K & 6) && (Gj = B() + 500, jg()));
          }
          break;
        case 13:
          Rk(function() {
            var b2 = ih(a, 1);
            if (b2 !== null) {
              var c2 = R();
              gi(b2, a, 1, c2);
            }
          }), il(a, 1);
      }
    };
    Fc = function(a) {
      if (a.tag === 13) {
        var b = ih(a, 134217728);
        if (b !== null) {
          var c = R();
          gi(b, a, 134217728, c);
        }
        il(a, 134217728);
      }
    };
    Gc = function(a) {
      if (a.tag === 13) {
        var b = yi(a), c = ih(a, b);
        if (c !== null) {
          var d = R();
          gi(c, a, b, d);
        }
        il(a, b);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a, b) {
      var c = C;
      try {
        return C = a, b();
      } finally {
        C = c;
      }
    };
    yb = function(a, b, c) {
      switch (b) {
        case "input":
          if (bb(a, c), b = c.name, c.type === "radio" && b != null) {
            for (c = a; c.parentNode; )
              c = c.parentNode;
            for (c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]'), b = 0; b < c.length; b++) {
              var d = c[b];
              if (d !== a && d.form === a.form) {
                var e = Db(d);
                if (!e)
                  throw Error(p(90));
                Wa(d), bb(d, e);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c);
          break;
        case "select":
          b = c.value, b != null && fb(a, !!c.multiple, b, !1);
      }
    };
    Gb = Qk;
    Hb = Rk;
    var sl = { usingClientEntryPoint: !1, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      return a = Zb(a), a === null ? null : a.stateNode;
    }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined" && (vl = __REACT_DEVTOOLS_GLOBAL_HOOK__, !vl.isDisabled && vl.supportsFiber))
      try {
        kc = vl.inject(ul), lc = vl;
      } catch (a) {
      }
    var vl;
    exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
    exports2.createPortal = function(a, b) {
      var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!nl(b))
        throw Error(p(200));
      return cl(a, b, null, c);
    };
    exports2.createRoot = function(a, b) {
      if (!nl(a))
        throw Error(p(299));
      var c = !1, d = "", e = kl;
      return b != null && (b.unstable_strictMode === !0 && (c = !0), b.identifierPrefix !== void 0 && (d = b.identifierPrefix), b.onRecoverableError !== void 0 && (e = b.onRecoverableError)), b = bl(a, 1, !1, null, null, c, !1, d, e), a[uf] = b.current, sf(a.nodeType === 8 ? a.parentNode : a), new ll(b);
    };
    exports2.findDOMNode = function(a) {
      if (a == null)
        return null;
      if (a.nodeType === 1)
        return a;
      var b = a._reactInternals;
      if (b === void 0)
        throw typeof a.render == "function" ? Error(p(188)) : (a = Object.keys(a).join(","), Error(p(268, a)));
      return a = Zb(b), a = a === null ? null : a.stateNode, a;
    };
    exports2.flushSync = function(a) {
      return Rk(a);
    };
    exports2.hydrate = function(a, b, c) {
      if (!ol(b))
        throw Error(p(200));
      return rl(null, a, b, !0, c);
    };
    exports2.hydrateRoot = function(a, b, c) {
      if (!nl(a))
        throw Error(p(405));
      var d = c != null && c.hydratedSources || null, e = !1, f = "", g = kl;
      if (c != null && (c.unstable_strictMode === !0 && (e = !0), c.identifierPrefix !== void 0 && (f = c.identifierPrefix), c.onRecoverableError !== void 0 && (g = c.onRecoverableError)), b = el(b, null, a, 1, c != null ? c : null, e, !1, f, g), a[uf] = b.current, sf(a), d)
        for (a = 0; a < d.length; a++)
          c = d[a], e = c._getVersion, e = e(c._source), b.mutableSourceEagerHydrationData == null ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
            c,
            e
          );
      return new ml(b);
    };
    exports2.render = function(a, b, c) {
      if (!ol(b))
        throw Error(p(200));
      return rl(null, a, b, !1, c);
    };
    exports2.unmountComponentAtNode = function(a) {
      if (!ol(a))
        throw Error(p(40));
      return a._reactRootContainer ? (Rk(function() {
        rl(null, null, a, !1, function() {
          a._reactRootContainer = null, a[uf] = null;
        });
      }), !0) : !1;
    };
    exports2.unstable_batchedUpdates = Qk;
    exports2.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
      if (!ol(c))
        throw Error(p(200));
      if (a == null || a._reactInternals === void 0)
        throw Error(p(38));
      return rl(a, b, c, !1, d);
    };
    exports2.version = "18.3.1-next-f1338f8080-20240426";
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports2, module2) {
    "use strict";
    function checkDCE() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
    }
    checkDCE(), module2.exports = require_react_dom_production_min();
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports2) {
    "use strict";
    var m = require_react_dom();
    exports2.createRoot = m.createRoot, exports2.hydrateRoot = m.hydrateRoot;
    var i;
  }
});

// node_modules/react/cjs/react-jsx-runtime.production.min.js
var require_react_jsx_runtime_production_min = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports2) {
    "use strict";
    var f = require_react(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: !0, ref: !0, __self: !0, __source: !0 };
    function q(c, a, g) {
      var b, d = {}, e = null, h = null;
      g !== void 0 && (e = "" + g), a.key !== void 0 && (e = "" + a.key), a.ref !== void 0 && (h = a.ref);
      for (b in a)
        m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
      if (c && c.defaultProps)
        for (b in a = c.defaultProps, a)
          d[b] === void 0 && (d[b] = a[b]);
      return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
    }
    exports2.Fragment = l;
    exports2.jsx = q;
    exports2.jsxs = q;
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports2, module2) {
    "use strict";
    module2.exports = require_react_jsx_runtime_production_min();
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SoundscapesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian"), import_fs2 = __toESM(require("fs")), import_path2 = __toESM(require("path")), import_music_metadata = __toESM(require_lib4());

// src/Utils/Observable.ts
var Observable = class {
  constructor(value) {
    this.subscribers = [];
    this.value = value;
  }
  /**
   * Set the value
   * @param value
   */
  setValue(value) {
    this.value = value, this.subscribers.forEach((callback) => callback({ ...this.value }));
  }
  /**
   * Get the current value
   */
  getValue() {
    return this.value;
  }
  /**
   * Subscribe to changes in the value. Function returns a "unsubscribe" function to clean up as nessessary.
   * @param callback
   */
  onChange(callback) {
    return this.subscribers.push(callback), () => {
      this.subscribers = this.subscribers.filter(
        (value) => value === callback
      );
    };
  }
}, Observable_default = Observable;

// Views/ReactView.tsx
var import_obsidian2 = require("obsidian"), import_client = __toESM(require_client());

// React/Components/App/App.tsx
var import_react4 = __toESM(require_react());

// React/Context/ObsidianPluginContext.ts
var import_react = __toESM(require_react()), obsidianPluginContext = (0, import_react.createContext)({
  app: null,
  plugin: null,
  settingsObservable: null,
  localPlayerStateObservable: null
}), useObsidianPluginContext = () => (0, import_react.useContext)(obsidianPluginContext);

// React/Components/Icon/Icon.tsx
var import_obsidian = require("obsidian"), import_jsx_runtime = __toESM(require_jsx_runtime()), Icon = ({ name }) => {
  let iconText = new XMLSerializer().serializeToString(
    (0, import_obsidian.getIcon)(name) || new Node()
  );
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "span",
    {
      className: "lucide-icon",
      dangerouslySetInnerHTML: {
        __html: iconText
      }
    }
  );
}, Icon_default = Icon;

// React/Components/Header/Header.tsx
var import_react3 = __toESM(require_react());

// React/Components/Search/Search.tsx
var import_react2 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime()), Search = () => {
  let { settingsObservable, plugin } = useObsidianPluginContext(), [settings, setSettings] = (0, import_react2.useState)(
    settingsObservable == null ? void 0 : settingsObservable.getValue()
  ), [query, setQuery] = (0, import_react2.useState)(""), [selectedResultIndex, setSelectedResultIndex] = (0, import_react2.useState)(0), resultsDiv = (0, import_react2.useRef)(null), searchResult = (0, import_react2.useMemo)(
    () => query.trim().length === 0 ? [] : settings.myMusicIndex.filter(
      (song) => song.title && song.title.toLowerCase().indexOf(query.toLowerCase()) > -1 || song.artist && song.artist.toLowerCase().indexOf(query.toLowerCase()) > -1 || song.album && song.album.toLowerCase().indexOf(query.toLowerCase()) > -1 || song.fileName.toLowerCase().indexOf(query.toLowerCase()) > -1
    ).slice(0, 20),
    [settings.myMusicIndex, query]
  );
  return (0, import_react2.useEffect)(() => {
    setSelectedResultIndex(0);
  }, [query, setSelectedResultIndex]), (0, import_react2.useEffect)(() => {
    let unsubscribe = settingsObservable == null ? void 0 : settingsObservable.onChange(
      (newSettings) => {
        setSettings(newSettings);
      }
    );
    return () => {
      unsubscribe == null || unsubscribe();
    };
  }, [setSettings]), /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "soundscapesmymusic-right-search", children: [
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Icon_default, { name: "search" }),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
      "input",
      {
        type: "text",
        className: "soundscapesmymusic-right-search-input",
        placeholder: "Search",
        value: query,
        onChange: (e) => setQuery(e.target.value),
        onFocus: (e) => {
          e.target.addClass(
            "soundscapesmymusic-right-search--active"
          );
        },
        onBlur: (e) => {
          setTimeout(
            () => e.target.removeClass(
              "soundscapesmymusic-right-search--active"
            ),
            100
          );
        },
        onKeyUp: (e) => {
          var _a, _b, _c;
          if (searchResult.length > 0)
            switch (e.key) {
              case "ArrowUp":
                selectedResultIndex > 0 && (setSelectedResultIndex(
                  selectedResultIndex - 1
                ), selectedResultIndex + 1 > 5 ? (_a = resultsDiv == null ? void 0 : resultsDiv.current) == null || _a.scrollTo({
                  top: (selectedResultIndex + 1 - 5) * 60
                }) : (_b = resultsDiv == null ? void 0 : resultsDiv.current) == null || _b.scrollTo({
                  top: 0
                }));
                break;
              case "ArrowDown":
                selectedResultIndex < searchResult.length - 1 && (setSelectedResultIndex(
                  selectedResultIndex + 1
                ), selectedResultIndex + 1 > 5 && ((_c = resultsDiv == null ? void 0 : resultsDiv.current) == null || _c.scrollTo({
                  // We're doing - 5 here because we want to align with the element that would be at the top
                  // if the selected element is at the bottom of the view.
                  top: (selectedResultIndex + 1 - 5) * 60
                })));
                break;
              case "Enter":
                plugin == null || plugin.changeMyMusicTrack(
                  searchResult[selectedResultIndex].fileName
                );
                break;
            }
        }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
      "div",
      {
        className: "soundscapesmymusic-right-search-results",
        ref: resultsDiv,
        children: [
          query.trim() !== "" && searchResult.length === 0 && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "soundscapesmymusic-right-search-results-message", children: "No results found" }),
          query.trim() === "" && /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "soundscapesmymusic-right-search-results-message", children: "Start typing for results..." }),
          searchResult.map((song, index) => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
            "div",
            {
              className: `soundscapesmymusic-right-search-results-result ${selectedResultIndex === index && "soundscapesmymusic-right-search-results-result--selected"}`,
              onClick: () => plugin == null ? void 0 : plugin.changeMyMusicTrack(song.fileName),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "soundscapesmymusic-right-search-results-result-line1", children: song.title }),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "soundscapesmymusic-right-search-results-result-line2", children: song.artist })
              ]
            },
            song.fileName
          ))
        ]
      }
    )
  ] });
}, Search_default = Search;

// React/Utils/secondsToMinutesAndSeconds.ts
var secondsToMinutesAndSeconds = (seconds) => {
  var minutes = Math.floor(seconds / 60), remainingSeconds = Math.floor(seconds % 60), formattedSeconds = remainingSeconds < 10 ? "0" + remainingSeconds : remainingSeconds;
  return minutes + ":" + formattedSeconds;
}, secondsToMinutesAndSeconds_default = secondsToMinutesAndSeconds;

// React/Components/Header/Header.tsx
var import_jsx_runtime3 = __toESM(require_jsx_runtime()), Header = () => {
  var _a, _b;
  let { localPlayerStateObservable, plugin } = useObsidianPluginContext(), [localPlayerState, setLocalPlayerState] = (0, import_react3.useState)(
    localPlayerStateObservable == null ? void 0 : localPlayerStateObservable.getValue()
  ), titleElementRef = (0, import_react3.useRef)(null), shouldScrollTitle = titleElementRef != null && titleElementRef.current ? ((_a = titleElementRef == null ? void 0 : titleElementRef.current) == null ? void 0 : _a.scrollWidth) > ((_b = titleElementRef == null ? void 0 : titleElementRef.current) == null ? void 0 : _b.clientWidth) : !1;
  return (0, import_react3.useEffect)(() => {
    let unsubscribe = localPlayerStateObservable == null ? void 0 : localPlayerStateObservable.onChange(
      (newState) => {
        setLocalPlayerState(newState);
      }
    );
    return () => {
      unsubscribe == null || unsubscribe();
    };
  }, [setLocalPlayerState]), /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "soundscapesmymusic-header", children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "soundscapesmymusic-left", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "soundscapesmymusic-left-controls", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        "button",
        {
          className: "soundscapesmymusic-left-controls-button",
          onClick: () => plugin == null ? void 0 : plugin.previous(),
          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Icon_default, { name: "skip-back" })
        }
      ),
      localPlayerState.playerState === 2 /* PAUSED */ && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        "button",
        {
          className: "soundscapesmymusic-left-controls-button soundscapesmymusic-left-controls-button--large",
          onClick: () => plugin == null ? void 0 : plugin.play(),
          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Icon_default, { name: "play" })
        }
      ),
      localPlayerState.playerState === 1 /* PLAYING */ && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        "button",
        {
          className: "soundscapesmymusic-left-controls-button soundscapesmymusic-left-controls-button--large",
          onClick: () => plugin == null ? void 0 : plugin.pause(),
          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Icon_default, { name: "pause" })
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        "button",
        {
          className: "soundscapesmymusic-left-controls-button",
          onClick: () => plugin == null ? void 0 : plugin.next(),
          children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Icon_default, { name: "skip-forward" })
        }
      )
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "soundscapesmymusic-volume", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "input",
      {
        type: "range",
        min: "0",
        max: "100",
        value: plugin == null ? void 0 : plugin.settings.volume,
        onChange: (e) => plugin == null ? void 0 : plugin.onVolumeChange(e)
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "soundscapesmymusic-middle", children: localPlayerState.currentTrack && /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "soundscapesmymusic-middle-line1", children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "soundscapesmymusic-middle-line1-left", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "button",
          {
            className: `soundscapesmymusic-middle-line1-button ${(plugin == null ? void 0 : plugin.settings.myMusicShuffle) && "soundscapesmymusic-middle-line1-button--active"}`,
            onClick: () => {
              plugin == null || plugin.toggleShuffle();
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Icon_default, { name: "shuffle" })
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
          "div",
          {
            className: `soundscapesmymusic-middle-line1-title ${shouldScrollTitle && "soundscapesmymusic-middle-line1-title--scroll"}`,
            ref: titleElementRef,
            children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { className: "soundscapesmymusic-middle-line1-title-text", children: localPlayerState.currentTrack.title })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "soundscapesmymusic-middle-line1-right" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "soundscapesmymusic-middle-line2", children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "soundscapesmymusic-middle-line2-left", children: secondsToMinutesAndSeconds_default(
          localPlayerState.currentTime || 0
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "soundscapesmymusic-middle-line2-artist", children: localPlayerState.currentTrack.artist }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "soundscapesmymusic-middle-line2-right", children: [
          "-",
          secondsToMinutesAndSeconds_default(
            (localPlayerState.currentTrack.duration || 0) - (localPlayerState.currentTime || 0)
          )
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          step: "0.1",
          value: (localPlayerState.currentTime || 0) / (localPlayerState.currentTrack.duration || 0) * 100,
          onChange: (e) => {
            var _a2;
            return plugin == null ? void 0 : plugin.seek(
              parseInt(e.target.value) / 100 * (((_a2 = localPlayerState.currentTrack) == null ? void 0 : _a2.duration) || 0)
            );
          },
          className: "soundscapesmymusic-middle-seekbar"
        }
      )
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "soundscapesmymusic-right", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Search_default, {}) })
  ] });
}, Header_default = Header;

// React/Components/App/App.tsx
var import_jsx_runtime4 = __toESM(require_jsx_runtime()), App = () => {
  let { settingsObservable, localPlayerStateObservable, plugin } = useObsidianPluginContext(), [settings, setSettings] = (0, import_react4.useState)(
    settingsObservable == null ? void 0 : settingsObservable.getValue()
  ), [localPlayerState, setLocalPlayerState] = (0, import_react4.useState)(
    localPlayerStateObservable == null ? void 0 : localPlayerStateObservable.getValue()
  );
  return (0, import_react4.useEffect)(() => {
    let unsubscribe = settingsObservable == null ? void 0 : settingsObservable.onChange(
      (newSettings) => {
        setSettings(newSettings);
      }
    );
    return () => {
      unsubscribe == null || unsubscribe();
    };
  }, [setSettings]), (0, import_react4.useEffect)(() => {
    let unsubscribe = localPlayerStateObservable == null ? void 0 : localPlayerStateObservable.onChange(
      (newState) => {
        setLocalPlayerState(newState);
      }
    );
    return () => {
      unsubscribe == null || unsubscribe();
    };
  }, [setLocalPlayerState]), /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Header_default, {}),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "soundscapesmymusic-musiclist", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("table", { className: "soundscapesmymusic-musiclist-table", children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("thead", { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("tr", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("th", {}),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("th", { children: "Title" }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("th", { children: "Artist" }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("th", { children: "Album" }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("th", { children: "Time" })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("tbody", { children: settings.myMusicIndex.map((song) => {
        var _a, _b;
        return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
          "tr",
          {
            onDoubleClick: () => plugin == null ? void 0 : plugin.changeMyMusicTrack(song.fileName),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("td", { children: [
                ((_a = localPlayerState.currentTrack) == null ? void 0 : _a.fileName) === song.fileName && localPlayerState.playerState === 1 /* PLAYING */ && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Icon_default, { name: "volume-2" }),
                ((_b = localPlayerState.currentTrack) == null ? void 0 : _b.fileName) === song.fileName && localPlayerState.playerState === 2 /* PAUSED */ && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Icon_default, { name: "volume" })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("td", { children: song.title }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("td", { children: song.artist }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("td", { children: song.album }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("td", { children: secondsToMinutesAndSeconds_default(
                song.duration || 0
              ) })
            ]
          },
          song.fullPath
        );
      }) })
    ] }) })
  ] });
}, App_default = App;

// Views/ReactView.tsx
var import_jsx_runtime5 = __toESM(require_jsx_runtime()), SOUNDSCAPES_REACT_VIEW = "soundscapes-react-view", ReactView = class extends import_obsidian2.ItemView {
  constructor(plugin, settingsObservable, localPlayerStateObservable, leaf) {
    super(leaf);
    this.root = null;
    this.app = plugin.app, this.plugin = plugin, this.settingsObservable = settingsObservable, this.localPlayerStateObservable = localPlayerStateObservable;
  }
  getViewType() {
    return SOUNDSCAPES_REACT_VIEW;
  }
  getDisplayText() {
    return "Soundscapes: My Music";
  }
  getIcon() {
    return "music";
  }
  async onOpen() {
    this.root = (0, import_client.createRoot)(this.containerEl.children[1]), this.root.render(
      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        obsidianPluginContext.Provider,
        {
          value: {
            app: this.app,
            plugin: this.plugin,
            settingsObservable: this.settingsObservable,
            localPlayerStateObservable: this.localPlayerStateObservable
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(App_default, {})
        }
      )
    ), this.containerEl.addClass("soundscapesmymusic");
  }
  async onClose() {
    var _a;
    (_a = this.root) == null || _a.unmount();
  }
};

// src/Utils/getAllMusicFiles.ts
var import_fs = __toESM(require("fs")), import_path = __toESM(require("path")), MUSIC_FILE_EXTENSIONS = ["mp3"], getAllMusicFiles = (dirPath, fileArray = void 0) => {
  let files = import_fs.default.readdirSync(dirPath);
  return fileArray = fileArray || [], files.forEach((file) => {
    let filePath = import_path.default.join(dirPath, file);
    import_fs.default.statSync(filePath).isDirectory() ? fileArray = getAllMusicFiles(filePath, fileArray) : MUSIC_FILE_EXTENSIONS.includes(import_path.default.extname(filePath).slice(1)) && (fileArray == null || fileArray.push(filePath));
  }), fileArray;
}, getAllMusicFiles_default = getAllMusicFiles;

// src/Soundscapes.ts
var SOUNDSCAPES = {
  lofi: {
    id: "lofi",
    name: "Lofi beats",
    nowPlayingText: "Lofi beats",
    isLiveVideo: !0,
    youtubeId: "jfKfPfyJRdk",
    type: "STANDARD" /* STANDARD */
  },
  spa: {
    id: "spa",
    name: "Spa atmosphere",
    nowPlayingText: "Spa atmosphere",
    isLiveVideo: !0,
    youtubeId: "FbxLnvWVSrk",
    type: "STANDARD" /* STANDARD */
  },
  sims: {
    id: "sims",
    name: "The Sims complete soundtrack",
    nowPlayingText: "The Sims complete soundtrack",
    isLiveVideo: !1,
    youtubeId: "wKnkQdsITUE",
    type: "STANDARD" /* STANDARD */
  },
  thunder: {
    id: "thunder",
    name: "Thunderstorm",
    nowPlayingText: "Thunderstorm",
    isLiveVideo: !1,
    youtubeId: "nDq6TstdEi8",
    type: "STANDARD" /* STANDARD */
  },
  fire: {
    id: "fire",
    name: "Cozy fireplace",
    nowPlayingText: "Cozy fireplace",
    isLiveVideo: !1,
    youtubeId: "rCYzRXLWcIg",
    type: "STANDARD" /* STANDARD */
  },
  birds: {
    id: "birds",
    name: "Birds chirping",
    nowPlayingText: "Birds chirping",
    isLiveVideo: !1,
    youtubeId: "mFjU4JuJgnM",
    type: "STANDARD" /* STANDARD */
  },
  ocean: {
    id: "ocean",
    name: "Ocean waves",
    nowPlayingText: "Ocean waves",
    isLiveVideo: !1,
    youtubeId: "bn9F19Hi1Lk",
    type: "STANDARD" /* STANDARD */
  },
  jazz: {
    id: "jazz",
    name: "Relaxing jazz",
    nowPlayingText: "Relaxing jazz",
    isLiveVideo: !1,
    youtubeId: "0u34Pb25BNg",
    type: "STANDARD" /* STANDARD */
  },
  coffeeshop: {
    id: "coffeeshop",
    name: "Coffee shop ambience",
    nowPlayingText: "Coffee shop ambience",
    isLiveVideo: !1,
    youtubeId: "uiMXGIG_DQo",
    type: "STANDARD" /* STANDARD */
  },
  animalcrossing: {
    id: "animalcrossing",
    name: "Animal Crossing New Horizons",
    nowPlayingText: "Animal Crossing New Horizons",
    isLiveVideo: !1,
    youtubeId: "eKEAmOUFYJg",
    type: "STANDARD" /* STANDARD */
  },
  yakuzabar: {
    id: "yakuzabar",
    name: "Yakuza/Like a Dragon bar ambience",
    nowPlayingText: "Yakuza bar ambience",
    isLiveVideo: !1,
    youtubeId: "Q0GtyZbHJDM",
    type: "STANDARD" /* STANDARD */
  },
  nintendo: {
    id: "nintendo",
    name: "Calm Nintendo music",
    nowPlayingText: "Calm Nintendo music",
    isLiveVideo: !1,
    youtubeId: "sA0qrPOMy2Y",
    type: "STANDARD" /* STANDARD */
  },
  skycotl: {
    id: "skycotl",
    name: "Sky: Children of the Light",
    nowPlayingText: "Sky: Children of the Light",
    isLiveVideo: !1,
    youtubeId: "87etrUp83Yc",
    type: "STANDARD" /* STANDARD */
  },
  vtmbloodlines: {
    id: "vtmbloodlines",
    name: "Vampire: The Masquerade \u2013 Bloodlines",
    nowPlayingText: "VTM - Bloodlines ambience",
    isLiveVideo: !1,
    youtubeId: "pCZxb43L_Ag",
    type: "STANDARD" /* STANDARD */
  },
  chillsynth: {
    id: "chillsynth",
    name: "ChillSynth FM",
    nowPlayingText: "ChillSynth FM",
    isLiveVideo: !0,
    youtubeId: "UedTcufyrHc",
    type: "STANDARD" /* STANDARD */
  },
  peacefulpiano: {
    id: "peacefulpiano",
    name: "Peaceful piano radio",
    nowPlayingText: "Peaceful piano radio",
    isLiveVideo: !0,
    youtubeId: "TtkFsfOP9QI",
    type: "STANDARD" /* STANDARD */
  },
  synthwave: {
    id: "synthwave",
    name: "Synthwave radio",
    nowPlayingText: "Synthwave radio",
    isLiveVideo: !0,
    youtubeId: "4xDzrJKXOOY",
    type: "STANDARD" /* STANDARD */
  }
}, Soundscapes_default = SOUNDSCAPES;

// src/Settings/Settings.ts
var import_obsidian5 = require("obsidian");

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i)
  byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto != "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options)
    return native_default.randomUUID();
  options = options || {};
  let rnds = options.random || (options.rng || rng)();
  if (rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i)
      buf[offset + i] = rnds[i];
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/ConfirmModal/ConfirmModal.ts
var import_obsidian3 = require("obsidian"), ConfirmModal = class extends import_obsidian3.Modal {
  constructor(app, onConfirm, title, text, confirmButtonText, cancelButtonText = "Cancel") {
    super(app), this._onConfirm = onConfirm, this._title = title, this._text = text, this._confirmButtonText = confirmButtonText, this._cancelButtonText = cancelButtonText;
  }
  onOpen() {
    let { contentEl } = this;
    contentEl.createEl("h2", { text: this._title }), contentEl.createEl("p", { text: this._text }), new import_obsidian3.Setting(contentEl).addButton((component) => {
      component.setButtonText(this._confirmButtonText), component.setClass("mod-warning"), component.onClick(() => {
        this._onConfirm(), this.close();
      });
    }).addButton((component) => {
      component.setButtonText(this._cancelButtonText), component.onClick(() => {
        this.close();
      });
    });
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
}, ConfirmModal_default = ConfirmModal;

// src/EditCustomSoundscapeModal/EditCustomSoundscapeModal.ts
var import_obsidian4 = require("obsidian");
var EditCustomSoundscapeModal = class extends import_obsidian4.Modal {
  constructor(plugin, customSoundscape, onSave) {
    super(plugin.app), this._customSoundscape = customSoundscape, this._onSave = onSave;
  }
  onOpen() {
    this.display();
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
  display() {
    let { contentEl } = this;
    contentEl.empty(), contentEl.createEl("h2", { text: "Add custom soundscape" }), new import_obsidian4.Setting(contentEl).setName("Soundscape name").setDesc("What would you like to call the soundscape?").addText((component) => {
      component.setValue(this._customSoundscape.name), component.getValue().trim() === "" ? component.inputEl.addClass("soundscapes-validation-error") : component.inputEl.removeClass(
        "soundscapes-validation-error"
      ), component.onChange((value) => {
        this._customSoundscape.name = value;
      }), component.inputEl.addEventListener("blur", () => {
        this.display();
      });
    }), this._customSoundscape.tracks.forEach((track, index) => {
      new import_obsidian4.Setting(contentEl).setName(`Track #${index + 1}`).setHeading().addButton((component) => {
        component.setButtonText("Remove track"), component.setClass("mod-warning"), component.onClick(() => {
          new ConfirmModal_default(
            this.app,
            () => {
              this._customSoundscape.tracks.splice(index, 1), this.display();
            },
            "Remove track",
            `This will remove "${track.name}" from your custom soundscape. Are you sure?`,
            "Remove"
          ).open();
        });
      }), new import_obsidian4.Setting(contentEl).setName("Track name").setDesc("Name of the track").addText((component) => {
        component.setValue(track.name), component.getValue().trim() === "" ? component.inputEl.addClass(
          "soundscapes-validation-error"
        ) : component.inputEl.removeClass(
          "soundscapes-validation-error"
        ), component.onChange((value) => {
          this._customSoundscape.tracks[index].name = value;
        }), component.inputEl.addEventListener("blur", () => {
          this.display();
        });
      }), new import_obsidian4.Setting(contentEl).setName("Youtube id").setDesc("Id of the Youtube video for the track").addText((component) => {
        component.setValue(track.id), component.getValue().trim() === "" ? component.inputEl.addClass(
          "soundscapes-validation-error"
        ) : component.inputEl.removeClass(
          "soundscapes-validation-error"
        ), component.onChange((value) => {
          this._customSoundscape.tracks[index].id = value;
        }), component.inputEl.addEventListener("blur", () => {
          this.display();
        });
      });
    }), new import_obsidian4.Setting(contentEl).addButton((component) => {
      component.setButtonText("Add new track").onClick(() => {
        this._customSoundscape.tracks.push({
          name: "",
          id: ""
        }), this.display();
      });
    }), new import_obsidian4.Setting(contentEl).addButton((component) => {
      component.setButtonText("Save custom soundscape"), this._customSoundscape.name.trim() === "" || this._customSoundscape.tracks.some(
        (track) => track.name.trim() === "" || track.id.trim() === ""
      ) ? (component.setDisabled(!0), component.setClass("soundscapes-button-disabled")) : component.setCta().onClick(() => {
        this._onSave(this._customSoundscape), this.close();
      });
    });
  }
}, EditCustomSoundscapeModal_default = EditCustomSoundscapeModal;

// src/Settings/Settings.ts
var import_electron = __toESM(require("electron")), DEFAULT_SETTINGS = {
  soundscape: "lofi",
  volume: 25,
  autoplay: !1,
  scrollSongTitle: !0,
  customSoundscapes: [],
  myMusicIndex: [],
  myMusicFolderPath: "",
  reindexFrequency: "5",
  myMusicShuffle: !1,
  currentTrackIndex: 0
}, SoundscapesSettingsTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin), this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty(), new import_obsidian5.Setting(containerEl).setName("Soundscape").setDesc("Which soundscape would you like to listen to?").addDropdown((component) => {
      Object.values(Soundscapes_default).forEach((soundscape) => {
        component.addOption(soundscape.id, soundscape.name);
      }), this.plugin.settings.customSoundscapes.forEach(
        (customSoundscape) => {
          customSoundscape.tracks.length > 0 && component.addOption(
            `CUSTOM_${customSoundscape.id}`,
            customSoundscape.name
          );
        }
      ), component.addOption("MY_MUSIC" /* MY_MUSIC */, "My Music"), component.setValue(this.plugin.settings.soundscape), component.onChange((value) => {
        this.plugin.changeSoundscape(value), this.display();
      });
    }), new import_obsidian5.Setting(containerEl).setName("Autoplay soundscape").setDesc("Automatically play chosen soundscape on startup?").addToggle((component) => {
      component.setValue(this.plugin.settings.autoplay), component.onChange((value) => {
        this.plugin.settings.autoplay = value, this.plugin.saveSettings();
      });
    }), new import_obsidian5.Setting(containerEl).setName("Scroll song title").setDesc("Save space on the status bar by scrolling song title?").addToggle((component) => {
      component.setValue(this.plugin.settings.scrollSongTitle), component.onChange((value) => {
        this.plugin.settings.scrollSongTitle = value, this.plugin.toggleNowPlayingScroll(), this.plugin.saveSettings();
      });
    }), containerEl.createEl("h1", { text: "Custom soundscapes" }), containerEl.createEl("p", {
      text: "Custom soundscapes allow you to create your own playlists of youtube videos that can be selected as a soundscape."
    }), this.plugin.settings.customSoundscapes.forEach(
      (customSoundscape, index) => {
        new import_obsidian5.Setting(containerEl).setName(customSoundscape.name).setDesc(`${customSoundscape.tracks.length} tracks`).addButton((component) => {
          component.setButtonText("Edit"), component.onClick(() => {
            new EditCustomSoundscapeModal_default(
              this.plugin,
              // Gross way to deep clone the object
              JSON.parse(JSON.stringify(customSoundscape)),
              (modifiedCustomSoundscape) => {
                this.plugin.settings.customSoundscapes[index] = modifiedCustomSoundscape, this.plugin.saveSettings(), this.display(), this.plugin.populateChangeSoundscapeButton();
              }
            ).open();
          });
        }).addButton((component) => {
          component.setButtonText("Remove"), component.setClass("mod-warning"), component.onClick(() => {
            new ConfirmModal_default(
              this.plugin.app,
              () => {
                this.plugin.settings.customSoundscapes.splice(
                  index,
                  1
                ), this.plugin.settings.soundscape === `CUSTOM_${customSoundscape.id}` && (this.plugin.settings.soundscape = "lofi", this.plugin.onSoundscapeChange()), this.plugin.saveSettings(), this.display(), this.plugin.populateChangeSoundscapeButton();
              },
              "Remove custom soundscape",
              `This will remove your custom soundscape "${customSoundscape.name}". Are you sure?`,
              "Remove"
            ).open();
          });
        });
      }
    ), new import_obsidian5.Setting(containerEl).addButton((component) => {
      component.setButtonText("Add custom soundscape").setCta().onClick(() => {
        new EditCustomSoundscapeModal_default(
          this.plugin,
          { id: v4_default(), name: "", tracks: [] },
          (customSoundscape) => {
            this.plugin.settings.customSoundscapes.push(
              customSoundscape
            ), this.plugin.saveSettings(), this.display(), this.plugin.populateChangeSoundscapeButton();
          }
        ).open();
      });
    }), containerEl.createEl("h1", { text: "My Music" }), containerEl.createEl("p", {
      text: "The My Music Soundscape plays music files from your local computer. It includes a dedicated view for managing your music in addition to the mini-player on the statusbar."
    }), new import_obsidian5.Setting(containerEl).setName("Music path").setDesc(
      "Path to where your music files are located. Plugin will also search through all subfolders of the provided folder."
    ).addText((component) => {
      component.setDisabled(!0), component.setValue(this.plugin.settings.myMusicFolderPath);
    }).addExtraButton((component) => {
      component.setIcon("folder-open"), component.setTooltip("Select folder"), component.onClick(() => {
        import_electron.default.remote.dialog.showOpenDialog({
          properties: ["openDirectory"],
          title: "Select a folder"
        }).then((result) => {
          result.canceled || (this.plugin.settings.myMusicFolderPath = result.filePaths[0], this.plugin.settings.myMusicIndex = [], this.plugin.saveSettings(), this.display(), this.plugin.indexMusicLibrary(), this.plugin.onSoundscapeChange());
        });
      });
    }), new import_obsidian5.Setting(containerEl).setName("Periodic re-index").setDesc(
      "To keep your music library up to date, the plugin needs to occasionally re-index from your music folder. You can disable this if you would prefer to manually trigger re-indexes. Re-indexes will also be triggered on startup of Obsidian or when the Soundscape or music folder path are changed."
    ).addDropdown((component) => {
      component.addOption("never", "Never"), component.addOption("5", "5 Minutes (default)"), component.addOption("15", "15 Minutes"), component.addOption("30", "30 Minutes"), component.addOption("60", "60 Minutes"), component.addOption("1440", "Daily"), component.setValue(this.plugin.settings.reindexFrequency), component.onChange((value) => {
        this.plugin.settings.reindexFrequency = value, this.plugin.saveSettings(), this.display();
      });
    }).addExtraButton((component) => {
      component.setIcon("folder-sync"), component.setTooltip("Re-index now"), component.onClick(() => {
        this.plugin.indexMusicLibrary();
      });
    });
  }
};

// src/Utils/createShuffleQueue.ts
var createShuffleQueue = (songs) => {
  let queue = Array.from(songs.keys());
  for (let i = queue.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [queue[i], queue[j]] = [queue[j], queue[i]];
  }
  return queue;
}, createShuffleQueue_default = createShuffleQueue;

// main.ts
var SoundscapesPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.currentTrackIndex = 0;
    this.reindexTimer = null;
    this.shuffleQueue = [];
    this.shuffleQueueSpot = 0;
  }
  async onload() {
    await this.loadSettings(), this.currentTrackIndex = this.settings.currentTrackIndex, this.settingsObservable = new Observable_default(this.settings), this.localPlayerStateObservable = new Observable_default({}), this.debouncedSaveSettings = (0, import_obsidian6.debounce)(this.saveSettings, 500, !0), this.versionCheck(), this.statusBarItem = this.addStatusBarItem(), this.statusBarItem.addClass("soundscapesroot"), this.createPlayer(), this.registerView(
      SOUNDSCAPES_REACT_VIEW,
      (leaf) => new ReactView(
        this,
        this.settingsObservable,
        this.localPlayerStateObservable,
        leaf
      )
    ), this.ribbonButton = this.addRibbonIcon(
      "music",
      "Soundscapes: My Music",
      () => {
        this.OpenMyMusicView();
      }
    ), this.ribbonButton.hide(), this.addSettingTab(new SoundscapesSettingsTab(this.app, this)), this.settings.soundscape === "MY_MUSIC" /* MY_MUSIC */ && (this.ribbonButton.show(), setTimeout(() => {
      this.indexMusicLibrary();
    }, 1e3)), this.addCommand({
      id: "go-to-next-track",
      name: "Go to next track",
      callback: () => {
        this.next();
      }
    }), this.addCommand({
      id: "go-to-previous-track",
      name: "Go to previous track",
      callback: () => {
        this.previous();
      }
    }), this.addCommand({
      id: "Play/Pause",
      name: "Play/Pause current track",
      callback: () => {
        this.localPlayerStateObservable.getValue().playerState === 1 /* PLAYING */ ? this.pause() : this.play();
      }
    });
  }
  onunload() {
    this.reindexTimer && clearTimeout(this.reindexTimer);
  }
  /**
   * Because we only have the id of the current soundscape, we need a helper function to get the soundscape itself when it's a custom one
   * @returns
   */
  getCurrentCustomSoundscape() {
    return this.settings.customSoundscapes.find(
      (soundscape) => soundscape.id === this.settings.soundscape.split("CUSTOM_")[1]
    );
  }
  /******************************************************************************************************************/
  //#region Startup
  /******************************************************************************************************************/
  /**
   * Check the local plugin version against github. If there is a new version, notify the user.
   */
  async versionCheck() {
    let localVersion = "1.5.0", stableVersion = await (0, import_obsidian6.requestUrl)(
      "https://raw.githubusercontent.com/andrewmcgivery/obsidian-soundscapes/main/package.json"
    ).then(async (res) => {
      if (res.status === 200)
        return (await res.json).version;
    }), betaVersion = await (0, import_obsidian6.requestUrl)(
      "https://raw.githubusercontent.com/andrewmcgivery/obsidian-soundscapes/beta/package.json"
    ).then(async (res) => {
      if (res.status === 200)
        return (await res.json).version;
    });
    (localVersion == null ? void 0 : localVersion.indexOf("beta")) !== -1 ? localVersion !== betaVersion && new import_obsidian6.Notice(
      "There is a beta update available for the Soundscapes plugin. Please update to to the latest version to get the latest features!",
      0
    ) : localVersion !== stableVersion && new import_obsidian6.Notice(
      "There is an update available for the Soundscapes plugin. Please update to to the latest version to get the latest features!",
      0
    );
  }
  /**
   * Given a file path in settings, get all the music files in that folder.
   * Convert those music files to a index of their music metadata.
   * Finally, reschedule the next reindex based on settings.
   */
  async indexMusicLibrary() {
    console.time("MusicIndex");
    let filePath = this.settings.myMusicFolderPath;
    if (this.reindexTimer && clearTimeout(this.reindexTimer), filePath.trim() === "") {
      new import_obsidian6.Notice(
        "Please set music file path in settings to use My Music feature of Soundscapes.",
        0
      );
      return;
    }
    new import_obsidian6.Notice("Soundscapes: Indexing local music files...");
    let musicPromises = getAllMusicFiles_default(filePath).map(async (filePath2) => {
      let metadata = await import_music_metadata.default.parseFile(filePath2, {
        skipCovers: !0
      });
      return {
        fileName: import_path2.default.basename(filePath2),
        fullPath: filePath2,
        title: metadata.common.title || import_path2.default.basename(filePath2).replace(/\.(mp3)$/gi, ""),
        artist: metadata.common.artist,
        album: metadata.common.album,
        duration: metadata.format.duration
      };
    }), songs = await Promise.all(musicPromises);
    console.timeEnd("MusicIndex"), this.settings.myMusicIndex = songs, new import_obsidian6.Notice(
      `Soundscapes: Indexing complete. ${songs.length} songs were indexed.`
    ), songs.length === 0 && new import_obsidian6.Notice(
      "Warning: Soundscapes found no songs at the configured file path."
    ), this.saveSettings(), this.settings.reindexFrequency !== "never" && (this.reindexTimer = setTimeout(
      () => this.indexMusicLibrary(),
      6e4 * parseInt(this.settings.reindexFrequency)
    ));
  }
  /******************************************************************************************************************/
  //#endregion Startup
  /******************************************************************************************************************/
  /******************************************************************************************************************/
  //#region Create UI Elements
  /******************************************************************************************************************/
  /**
   * Opens react view of MyMusic
   */
  async OpenMyMusicView() {
    let { workspace } = this.app, leaf = null, leaves = workspace.getLeavesOfType(SOUNDSCAPES_REACT_VIEW);
    leaves.length > 0 ? leaf = leaves[0] : (leaf = workspace.getLeaf(!0), await leaf.setViewState({
      type: SOUNDSCAPES_REACT_VIEW,
      active: !0
    })), workspace.revealLeaf(leaf);
  }
  /**
   * Create the Youtube player
   */
  createPlayer() {
    this.statusBarItem.createEl("script", {
      attr: {
        src: "https://www.youtube.com/iframe_api"
      }
    }).addEventListener("error", () => {
      new import_obsidian6.Notice(
        "Soundscapes was unable to load the Youtube player. This could be because you are offline or have youtube blocked. You may still use My Music mode."
      ), this.onPlayerReady();
    }), this.statusBarItem.createEl("div", {
      attr: { id: "player" },
      cls: "soundscapesroot-player"
    }), this.localPlayer = new Audio(), this.localPlayer.volume = this.settings.volume / 100, this.localPlayer.addEventListener("play", () => {
      this.onStateChange({ data: 1 /* PLAYING */ });
    }), this.localPlayer.addEventListener("pause", () => {
      this.onStateChange({ data: 2 /* PAUSED */ });
    }), this.localPlayer.addEventListener("ended", () => {
      this.onStateChange({ data: 0 /* ENDED */ });
    }), this.localPlayer.addEventListener("timeupdate", () => {
      this.updateLocalPlayerState({
        currentTime: this.localPlayer.currentTime
      });
    }), window.onYouTubeIframeAPIReady = () => {
      this.player = new YT.Player("player", {
        height: "100",
        width: "200",
        playerVars: {
          playsinline: 1,
          fs: 0,
          disablekb: 1,
          controls: 0
        },
        events: {
          onReady: this.onPlayerReady.bind(this),
          onStateChange: (e) => {
            this.settings.soundscape !== "MY_MUSIC" /* MY_MUSIC */ && this.onStateChange.bind(this)(e);
          }
        }
      });
    };
  }
  /**
   * Create all the UI elements
   */
  createControls() {
    this.previousButton = this.statusBarItem.createEl("button", {
      cls: "soundscapesroot-previousbutton"
    }), (0, import_obsidian6.setIcon)(this.previousButton, "skip-back"), this.previousButton.onclick = () => this.previous(), this.playButton = this.statusBarItem.createEl("button", {}), (0, import_obsidian6.setIcon)(this.playButton, "play"), this.playButton.onclick = () => this.play(), this.pauseButton = this.statusBarItem.createEl("button", {}), (0, import_obsidian6.setIcon)(this.pauseButton, "pause"), this.pauseButton.onclick = () => this.pause(), this.nextButton = this.statusBarItem.createEl("button", {
      cls: "soundscapesroot-nextbutton"
    }), (0, import_obsidian6.setIcon)(this.nextButton, "skip-forward"), this.nextButton.onclick = () => this.next();
    let changeSoundscapeButton = this.statusBarItem.createEl("button", {
      cls: "soundscapesroot-changesoundscapebutton"
    });
    (0, import_obsidian6.setIcon)(changeSoundscapeButton, "list-music"), this.changeSoundscapeSelect = changeSoundscapeButton.createEl(
      "select",
      {
        cls: "soundscapesroot-changesoundscapeselect",
        attr: {
          id: "soundscapesroot-changesoundscapeselect"
        }
      }
    ), this.populateChangeSoundscapeButton(), this.nowPlayingRoot = this.statusBarItem.createEl("div", {
      cls: "soundscapesroot-nowplaying"
    }), this.nowPlaying = this.nowPlayingRoot.createEl("div", {
      cls: "soundscapesroot-nowplaying-text"
    }), this.toggleNowPlayingScroll();
    let volumeIcons = this.statusBarItem.createEl("div", {
      cls: "soundscapesroot-volumeIcons"
    });
    this.volumeMutedIcon = volumeIcons.createEl("div", {
      cls: "soundscapesroot-volumeIcons-iconmuted"
    }), (0, import_obsidian6.setIcon)(this.volumeMutedIcon, "volume-x"), this.volumeLowIcon = volumeIcons.createEl("div", {
      cls: "soundscapesroot-volumeIcons-iconlow"
    }), (0, import_obsidian6.setIcon)(this.volumeLowIcon, "volume-1"), this.volumeHighIcon = volumeIcons.createEl("div", {
      cls: "soundscapesroot-volumeIcons-iconhigh"
    }), (0, import_obsidian6.setIcon)(this.volumeHighIcon, "volume-2"), this.volumeSlider = this.statusBarItem.createEl("input", {
      attr: {
        type: "range",
        min: 0,
        max: 100,
        value: this.settings.volume
      }
    }), this.onVolumeChange({ target: { value: this.settings.volume } }), this.volumeSlider.addEventListener(
      "input",
      this.onVolumeChange.bind(this)
    );
  }
  /**
   * Populates the dropdown on the miniplayer with all available soundscapes
   */
  populateChangeSoundscapeButton() {
    this.changeSoundscapeSelect.replaceChildren(), Object.values(Soundscapes_default).forEach((soundscape) => {
      this.changeSoundscapeSelect.createEl("option", {
        text: soundscape.name,
        value: soundscape.id
      });
    }), this.settings.customSoundscapes.forEach((customSoundscape) => {
      customSoundscape.tracks.length > 0 && this.changeSoundscapeSelect.createEl("option", {
        text: customSoundscape.name,
        value: `CUSTOM_${customSoundscape.id}`
      });
    }), this.changeSoundscapeSelect.createEl("option", {
      text: "My Music",
      value: "MY_MUSIC" /* MY_MUSIC */
    }), this.changeSoundscapeSelect.value = this.settings.soundscape, this.changeSoundscapeSelect.addEventListener(
      "change",
      (event) => {
        this.changeSoundscape(
          (event == null ? void 0 : event.target).value
        );
      }
    );
  }
  /******************************************************************************************************************/
  //#endregion Create UI Elements
  /******************************************************************************************************************/
  /******************************************************************************************************************/
  //#region Control Player
  /******************************************************************************************************************/
  /**
   * Plays the current track. When it's a live video, attempt to jump to the "live" portion.
   */
  play() {
    var _a, _b;
    this.soundscapeType === "STANDARD" /* STANDARD */ && Soundscapes_default[this.settings.soundscape].isLiveVideo && ((_a = this.player) == null || _a.seekTo(this.player.getDuration())), this.soundscapeType === "MY_MUSIC" /* MY_MUSIC */ ? this.localPlayer.src === location.href && this.settings.myMusicIndex.length > 0 ? (this.currentTrackIndex = 0, this.onSoundscapeChange(!0)) : this.localPlayer.play() : (_b = this.player) == null || _b.playVideo();
  }
  /**
   * Pause the current track.
   */
  pause() {
    var _a;
    this.soundscapeType === "MY_MUSIC" /* MY_MUSIC */ ? this.localPlayer.pause() : (_a = this.player) == null || _a.pauseVideo();
  }
  /**
   * Skip to the previous track.
   */
  previous() {
    if (this.soundscapeType === "CUSTOM" /* CUSTOM */) {
      let customSoundscape = this.getCurrentCustomSoundscape();
      this.currentTrackIndex === 0 ? this.currentTrackIndex = ((customSoundscape == null ? void 0 : customSoundscape.tracks.length) || 1) - 1 : this.currentTrackIndex--;
    } else
      this.soundscapeType === "MY_MUSIC" /* MY_MUSIC */ && (this.settings.myMusicShuffle ? (this.shuffleQueue.length === 0 && (this.shuffleQueue = createShuffleQueue_default(
        this.settings.myMusicIndex
      ), this.shuffleQueueSpot = 0), this.shuffleQueueSpot === 0 ? this.currentTrackIndex = this.shuffleQueue[this.shuffleQueue.length - 1] : (this.shuffleQueueSpot--, this.currentTrackIndex = this.shuffleQueue[this.shuffleQueueSpot])) : this.currentTrackIndex === 0 ? this.currentTrackIndex = this.settings.myMusicIndex.length - 1 : this.currentTrackIndex--);
    this.onSoundscapeChange();
  }
  /**
   * Skip to the next track.
   */
  next() {
    if (this.soundscapeType === "CUSTOM" /* CUSTOM */) {
      let customSoundscape = this.getCurrentCustomSoundscape();
      customSoundscape != null && customSoundscape.tracks[this.currentTrackIndex + 1] ? this.currentTrackIndex++ : this.currentTrackIndex = 0;
    } else
      this.soundscapeType === "MY_MUSIC" /* MY_MUSIC */ && (this.settings.myMusicShuffle ? (this.shuffleQueue.length === 0 && (this.shuffleQueue = createShuffleQueue_default(
        this.settings.myMusicIndex
      ), this.shuffleQueueSpot = 0), this.shuffleQueueSpot === this.shuffleQueue.length - 1 ? (this.currentTrackIndex = this.shuffleQueue[0], this.shuffleQueue = [], this.shuffleQueueSpot = 0) : (this.shuffleQueueSpot++, this.currentTrackIndex = this.shuffleQueue[this.shuffleQueueSpot])) : this.settings.myMusicIndex[this.currentTrackIndex + 1] ? this.currentTrackIndex++ : this.currentTrackIndex = 0);
    this.onSoundscapeChange();
  }
  /**
   * Seek to a specific spot in the song
   * @param time
   */
  seek(time) {
    this.soundscapeType === "MY_MUSIC" /* MY_MUSIC */ && (this.localPlayer.currentTime = time);
  }
  /**
   * Changes the currently playing song when in My Music mode
   * @param fileName
   */
  changeMyMusicTrack(fileName) {
    this.currentTrackIndex = this.settings.myMusicIndex.findIndex(
      (song) => song.fileName === fileName
    ), this.onSoundscapeChange();
  }
  /**
   * Turn on shuffle mode. When we toggle it on, reset the shuffle queue.
   */
  toggleShuffle() {
    this.settings.myMusicShuffle = !this.settings.myMusicShuffle, this.saveSettings(), this.settings.myMusicShuffle && (this.shuffleQueue = [], this.shuffleQueueSpot = 0);
  }
  /**
   * Either enables or disables song title scrolling on the mini player depending on the user's settings
   */
  toggleNowPlayingScroll() {
    this.settings.scrollSongTitle ? this.nowPlayingRoot.removeClass(
      "soundscapesroot-nowplaying--noscroll"
    ) : this.nowPlayingRoot.addClass(
      "soundscapesroot-nowplaying--noscroll"
    );
  }
  /**
   * Changes the currently playing soundscape and triggers other downstream side effects
   * @param soundscape
   */
  changeSoundscape(soundscape) {
    this.settings.soundscape = soundscape, this.settings.soundscape.startsWith("CUSTOM_") && (this.currentTrackIndex = 0), this.settings.soundscape === "MY_MUSIC" /* MY_MUSIC */ ? (this.indexMusicLibrary(), this.ribbonButton.show()) : this.ribbonButton.hide(), this.onSoundscapeChange(), this.saveSettings();
  }
  /******************************************************************************************************************/
  //#endregion Control Player
  /******************************************************************************************************************/
  /******************************************************************************************************************/
  //#region Events
  /******************************************************************************************************************/
  /**
   * Once the player is ready, create the controls and play some music! (or not if autoplay is disabled)
   */
  onPlayerReady() {
    this.createControls(), this.onSoundscapeChange(this.settings.autoplay);
  }
  /**
   * Update the UI when the state of the video changes
   */
  onStateChange({ data: state }) {
    let customSoundscape = this.getCurrentCustomSoundscape();
    switch (this.soundscapeType === "STANDARD" /* STANDARD */ ? (this.previousButton.hide(), this.nextButton.hide()) : (this.previousButton.show(), this.nextButton.show()), state) {
      case -1 /* UNSTARTED */:
        this.playButton.show(), this.pauseButton.hide();
        break;
      case 1 /* PLAYING */:
        this.playButton.hide(), this.pauseButton.show(), this.updateLocalPlayerState({
          currentTrack: this.settings.myMusicIndex[this.currentTrackIndex],
          playerState: 1 /* PLAYING */
        });
        break;
      case 2 /* PAUSED */:
        this.playButton.show(), this.pauseButton.hide(), this.updateLocalPlayerState({
          currentTrack: this.settings.myMusicIndex[this.currentTrackIndex],
          playerState: 2 /* PAUSED */
        });
        break;
      case 0 /* ENDED */:
        (this.soundscapeType === "CUSTOM" /* CUSTOM */ || this.soundscapeType === "MY_MUSIC" /* MY_MUSIC */) && this.next(), this.onSoundscapeChange();
    }
  }
  /**
   * When we change the volume (usually via the slider), update the player volume, the UI, and save the current volume to settings
   */
  onVolumeChange(e) {
    var _a;
    let volume = parseInt(e.target.value);
    this.volumeSlider.value = e.target.value, (_a = this.player) == null || _a.setVolume(volume), this.localPlayer.volume = volume / 100, volume === 0 ? (this.volumeMutedIcon.show(), this.volumeLowIcon.hide(), this.volumeHighIcon.hide()) : volume <= 50 ? (this.volumeMutedIcon.hide(), this.volumeLowIcon.show(), this.volumeHighIcon.hide()) : (this.volumeMutedIcon.hide(), this.volumeLowIcon.hide(), this.volumeHighIcon.show()), this.settings.volume = volume, this.settingsObservable.setValue(this.settings), this.debouncedSaveSettings();
  }
  /**
   * Play the selected soundscape!
   *
   * When in My Music mode, the song content is read from the file and base64ed. This is because electron blocks
   * local file paths from being used in the Audio element.
   */
  onSoundscapeChange(autoplay = !0) {
    var _a, _b, _c, _d, _e, _f;
    if (this.settings.soundscape.startsWith("CUSTOM_") ? this.soundscapeType = "CUSTOM" /* CUSTOM */ : this.settings.soundscape === "MY_MUSIC" /* MY_MUSIC */ ? this.soundscapeType = "MY_MUSIC" /* MY_MUSIC */ : this.soundscapeType = "STANDARD" /* STANDARD */, this.soundscapeType === "CUSTOM" /* CUSTOM */) {
      let customSoundscape = this.getCurrentCustomSoundscape();
      (_a = this.player) == null || _a.loadVideoById({
        videoId: customSoundscape == null ? void 0 : customSoundscape.tracks[this.currentTrackIndex].id
      }), this.nowPlaying.setText(
        (customSoundscape == null ? void 0 : customSoundscape.tracks[this.currentTrackIndex].name) || ""
      ), autoplay || (_b = this.player) == null || _b.pauseVideo(), this.statusBarItem.removeClass("soundscapesroot--hideyoutube"), this.localPlayer.pause();
    } else if (this.soundscapeType === "MY_MUSIC" /* MY_MUSIC */) {
      let track = this.settings.myMusicIndex[this.currentTrackIndex];
      if (track) {
        let base64Data = import_fs2.default.readFileSync(track.fullPath).toString("base64");
        this.localPlayer.pause(), this.localPlayer.src = `data:audio/mp3;base64,${base64Data}`, this.nowPlaying.setText(`${track.title} - ${track.artist}`), autoplay ? this.localPlayer.play() : this.onStateChange({ data: 2 /* PAUSED */ });
      } else
        this.localPlayer.src = "", this.nowPlaying.setText(""), this.onStateChange({ data: 2 /* PAUSED */ });
      this.statusBarItem.addClass("soundscapesroot--hideyoutube"), (_c = this.player) == null || _c.pauseVideo();
    } else
      (_d = this.player) == null || _d.loadVideoById({
        videoId: Soundscapes_default[this.settings.soundscape].youtubeId
      }), Soundscapes_default[this.settings.soundscape].isLiveVideo && ((_e = this.player) == null || _e.seekTo(this.player.getDuration())), this.nowPlaying.setText(
        Soundscapes_default[this.settings.soundscape].nowPlayingText
      ), autoplay || (_f = this.player) == null || _f.pauseVideo(), this.statusBarItem.removeClass("soundscapesroot--hideyoutube"), this.localPlayer.pause();
    this.changeSoundscapeSelect.value = this.settings.soundscape, this.saveSettings();
  }
  /******************************************************************************************************************/
  //#endregion Events
  /******************************************************************************************************************/
  /******************************************************************************************************************/
  //#region Settings and State
  /******************************************************************************************************************/
  /**
   * Load data from disk, stored in data.json in plugin folder
   */
  async loadSettings() {
    let data = await this.loadData() || {};
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
  }
  /**
   * Save data to disk, stored in data.json in plugin folder
   */
  async saveSettings() {
    this.settings.currentTrackIndex = this.currentTrackIndex, this.settingsObservable.setValue(this.settings), await this.saveData(this.settings);
  }
  /**
   * Merges the update object with the existing local player state
   * @param updateObject
   */
  updateLocalPlayerState(updateObject) {
    this.localPlayerStateObservable.setValue({
      ...this.localPlayerStateObservable.getValue(),
      ...updateObject
    });
  }
  /******************************************************************************************************************/
  //#endregion Settings and State
  /******************************************************************************************************************/
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

content-type/index.js:
  (*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

media-typer/index.js:
  (*!
   * media-typer
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/

/* nosourcemap */