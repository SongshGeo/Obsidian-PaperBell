/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// linker/readModeLinker.ts
var import_obsidian3 = require("obsidian");

// linker/linkerCache.ts
var import_obsidian2 = require("obsidian");

// linker/linkerInfo.ts
var import_obsidian = require("obsidian");
var LinkerFileMetaInfo = class {
  constructor(fetcher, file) {
    this.fetcher = fetcher;
    var _a;
    this.fetcher = fetcher;
    this.file = file instanceof import_obsidian.TFile ? file : this.fetcher.app.vault.getFileByPath(file.path);
    const settings = this.fetcher.settings;
    this.tags = ((_a = (0, import_obsidian.getAllTags)(this.fetcher.app.metadataCache.getFileCache(this.file))) != null ? _a : []).filter((tag) => tag.trim().length > 0).map((tag) => tag.startsWith("#") ? tag.slice(1) : tag);
    this.includeFile = this.tags.includes(settings.tagToIncludeFile);
    this.excludeFile = this.tags.includes(settings.tagToExcludeFile);
    this.includeAllFiles = fetcher.includeAllFiles;
    this.isInIncludedDir = fetcher.includeDirPattern.test(this.file.path);
    this.isInExcludedDir = fetcher.excludeDirPattern.test(this.file.path);
  }
};
var LinkerMetaInfoFetcher = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.refreshSettings();
  }
  refreshSettings(settings) {
    this.settings = settings != null ? settings : this.settings;
    this.includeAllFiles = this.settings.includeAllFiles;
    this.includeDirPattern = new RegExp(`(^|/)(${this.settings.linkerDirectories.join("|")})/`);
    this.excludeDirPattern = new RegExp(`(^|/)(${this.settings.excludedDirectories.join("|")})/`);
  }
  getMetaInfo(file) {
    return new LinkerFileMetaInfo(this, file);
  }
};

// linker/linkerCache.ts
var ExternalUpdateManager = class {
  constructor() {
    this.registeredCallbacks = /* @__PURE__ */ new Set();
  }
  registerCallback(callback) {
    this.registeredCallbacks.add(callback);
  }
  update() {
    setTimeout(() => {
      for (const callback of this.registeredCallbacks) {
        callback();
      }
    }, 50);
  }
};
var PrefixNode = class {
  constructor() {
    this.children = /* @__PURE__ */ new Map();
    this.files = /* @__PURE__ */ new Set();
    this.charValue = "";
    this.value = "";
  }
};
var MatchNode = class {
  constructor() {
    this.start = 0;
    this.length = 0;
    this.files = /* @__PURE__ */ new Set();
    this.value = "";
  }
  get end() {
    return this.start + this.length;
  }
};
var PrefixTree = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    this.root = new PrefixNode();
    this._currentNodes = [];
    this.setIndexedFilePaths = /* @__PURE__ */ new Set();
    this.mapIndexedFilePathsToUpdateTime = /* @__PURE__ */ new Map();
    this.mapFilePathToLeaveNodes = /* @__PURE__ */ new Map();
    this.fetcher = new LinkerMetaInfoFetcher(this.app, this.settings);
    this.updateTree();
  }
  clear() {
    this.root = new PrefixNode();
    this._currentNodes = [];
    this.setIndexedFilePaths.clear();
    this.mapIndexedFilePathsToUpdateTime.clear();
    this.mapFilePathToLeaveNodes.clear();
  }
  getCurrentMatchNodes(index, excludedNote) {
    const matchNodes = [];
    if (excludedNote === void 0 && this.settings.excludeLinksToOwnNote) {
      excludedNote = this.app.workspace.getActiveFile();
    }
    for (const node of this._currentNodes) {
      if (node.files.size === 0) {
        continue;
      }
      const matchNode = new MatchNode();
      matchNode.length = node.value.length;
      matchNode.start = index - matchNode.length;
      matchNode.files = new Set(Array.from(node.files).filter((file) => !excludedNote || file.path !== excludedNote.path));
      matchNode.value = node.value;
      if (matchNode.files.size > 0) {
        matchNodes.push(matchNode);
      }
    }
    matchNodes.sort((a, b) => b.length - a.length);
    return matchNodes;
  }
  addFileWithName(name, file) {
    var _a;
    let node = this.root;
    for (let char of name) {
      let child = node.children.get(char);
      if (!child) {
        child = new PrefixNode();
        child.parent = node;
        child.charValue = char;
        child.value = node.value + char;
        node.children.set(char, child);
      }
      node = child;
    }
    node.files.add(file);
    const path = file.path;
    this.mapFilePathToLeaveNodes.set(path, [node, ...(_a = this.mapFilePathToLeaveNodes.get(path)) != null ? _a : []]);
  }
  addFileToTree(file) {
    var _a, _b, _c;
    const path = file.path;
    this.removeFileFromTree(file);
    this.setIndexedFilePaths.add(path);
    this.mapIndexedFilePathsToUpdateTime.set(path, file.stat.mtime);
    const metaInfo = this.fetcher.getMetaInfo(file);
    const tags = ((_a = (0, import_obsidian2.getAllTags)(this.app.metadataCache.getFileCache(file))) != null ? _a : []).filter((tag) => tag.trim().length > 0).map((tag) => tag.startsWith("#") ? tag.slice(1) : tag);
    const includeFile = metaInfo.includeFile;
    const excludeFile = metaInfo.excludeFile;
    const isInIncludedDir = metaInfo.isInIncludedDir;
    const isInExcludedDir = metaInfo.isInExcludedDir;
    if (excludeFile || isInExcludedDir && !includeFile) {
      return;
    }
    if (!includeFile && !isInIncludedDir && !metaInfo.includeAllFiles) {
      return;
    }
    const metadata = this.app.metadataCache.getFileCache(file);
    let aliases = (_c = (_b = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _b.aliases) != null ? _c : [];
    if (!Array.isArray(aliases)) {
      aliases = [aliases];
    }
    aliases = aliases.filter((alias) => alias && alias.trim().length > 0);
    let names = [file.basename];
    if (aliases && this.settings.includeAliases) {
      names.push(...aliases);
    }
    names = names.filter((name) => name && name.trim().length > 0);
    if (this.settings.matchCaseSensitive) {
      if (tags.includes(this.settings.tagToIgnoreCase)) {
        const lowerCaseNames = names.map((name) => name.toLowerCase());
        names.push(...lowerCaseNames);
      }
    } else {
      if (!tags.includes(this.settings.tagToMatchCase)) {
        const lowerCaseNames = names.map((name) => name.toLowerCase());
        names.push(...lowerCaseNames);
      }
    }
    for (const name of names) {
      this.addFileWithName(name, file);
    }
  }
  removeFileFromTree(file) {
    var _a;
    const path = typeof file === "string" ? file : file.path;
    const nodes = (_a = this.mapFilePathToLeaveNodes.get(path)) != null ? _a : [];
    for (const node of nodes) {
      node.files = new Set([...node.files].filter((f) => f.path !== path));
    }
    for (let i = nodes.length - 1; i >= 0; i--) {
      const node = nodes[i];
      let currentNode = node;
      while (currentNode.files.size === 0 && currentNode.children.size === 0) {
        const parent = currentNode.parent;
        if (!parent || parent === this.root) {
          break;
        }
        parent.children.delete(currentNode.charValue);
        currentNode = parent;
      }
    }
    this.setIndexedFilePaths.delete(path);
    this.mapFilePathToLeaveNodes.delete(path);
    this.mapIndexedFilePathsToUpdateTime.delete(path);
  }
  fileIsUpToDate(file) {
    const mtime = file.stat.mtime;
    const path = file.path;
    return this.mapIndexedFilePathsToUpdateTime.has(path) && this.mapIndexedFilePathsToUpdateTime.get(path) === mtime;
  }
  updateTree(updateFiles) {
    this.fetcher.refreshSettings();
    const currentVaultFiles = /* @__PURE__ */ new Set();
    let files = new Array();
    const allFiles = this.app.vault.getMarkdownFiles();
    allFiles.forEach((f) => currentVaultFiles.add(f.path));
    if (allFiles.length != this.setIndexedFilePaths.size || !updateFiles || updateFiles.length == 0) {
      files = allFiles;
    } else {
      files = updateFiles.map((f) => f ? this.app.vault.getAbstractFileByPath(f) : null).filter((f) => f !== null && f instanceof import_obsidian2.TFile);
    }
    for (const file of files) {
      const mtime = file.stat.mtime;
      if (this.fileIsUpToDate(file)) {
        continue;
      }
      this.addFileToTree(file);
    }
    const filesToRemove = [...this.setIndexedFilePaths].filter((f) => !currentVaultFiles.has(f));
    filesToRemove.forEach((f) => this.removeFileFromTree(f));
  }
  findFiles(prefix) {
    let node = this.root;
    for (const char of prefix) {
      node = node.children.get(char.toLowerCase());
      if (!node) {
        return /* @__PURE__ */ new Set();
      }
    }
    return node.files;
  }
  resetSearch() {
    this._currentNodes = [this.root];
  }
  pushChar(char) {
    const newNodes = [];
    const chars = [char];
    if (!this.settings.matchCaseSensitive) {
      chars.push(char.toLowerCase());
    }
    chars.forEach((c) => {
      if (!this.settings.matchOnlyWholeWords || PrefixTree.checkWordBoundary(c)) {
        newNodes.push(this.root);
      }
      for (const node of this._currentNodes) {
        const child = node.children.get(c);
        if (child) {
          if (!newNodes.includes(child)) {
            newNodes.push(child);
          }
        }
      }
    });
    this._currentNodes = newNodes;
  }
  static checkWordBoundary(char) {
    const pattern = /[\/\n\t\r\s,.!"`Â´()\[\]'{}|~\p{Emoji_Presentation}\p{Extended_Pictographic}]/u;
    return pattern.test(char);
  }
};
var LinkerCache = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
    const { vault } = app;
    this.vault = vault;
    this.cache = new PrefixTree(app, settings);
    this.updateCache(true);
  }
  static getInstance(app, settings) {
    if (!LinkerCache.instance) {
      LinkerCache.instance = new LinkerCache(app, settings);
    }
    return LinkerCache.instance;
  }
  clearCache() {
    this.cache.clear();
  }
  reset() {
    this.cache.resetSearch();
  }
  updateCache(force = false) {
    var _a, _b, _c;
    if (!((_b = (_a = this.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.getActiveFile())) {
      return;
    }
    const activeFile = (_c = this.app.workspace.getActiveFile()) == null ? void 0 : _c.path;
    if (activeFile === this.activeFilePath && !force) {
      return;
    }
    this.cache.updateTree(force ? void 0 : [activeFile, this.activeFilePath]);
    this.activeFilePath = activeFile;
  }
};

// linker/readModeLinker.ts
var GlossaryLinker = class extends import_obsidian3.MarkdownRenderChild {
  constructor(app, settings, context, containerEl) {
    super(containerEl);
    this.settings = settings;
    this.app = app;
    this.ctx = context;
    this.linkerCache = LinkerCache.getInstance(app, settings);
    this.load();
  }
  getClosestLinkPath(glossaryName) {
    var _a, _b;
    const destName = this.ctx.sourcePath.replace(/(.*).md/, "$1");
    let currentDestName = destName;
    let currentPath = this.app.metadataCache.getFirstLinkpathDest((0, import_obsidian3.getLinkpath)(glossaryName), currentDestName);
    if (currentPath == null)
      return null;
    while (currentDestName.includes("/")) {
      currentDestName = currentDestName.replace(/\/[^\/]*?$/, "");
      const newPath = this.app.metadataCache.getFirstLinkpathDest((0, import_obsidian3.getLinkpath)(glossaryName), currentDestName);
      if ((((_a = newPath == null ? void 0 : newPath.path) == null ? void 0 : _a.length) || 0) > ((_b = currentPath == null ? void 0 : currentPath.path) == null ? void 0 : _b.length)) {
        currentPath = newPath;
        break;
      }
    }
    return currentPath;
  }
  onload() {
    var _a, _b, _c, _d;
    if (!this.settings.linkerActivated) {
      return;
    }
    const tags = ["p", "li", "td", "th", "span", "em", "strong"];
    if (this.settings.includeHeaders) {
      tags.push("h1", "h2", "h3", "h4", "h5", "h6");
    }
    const linkedFiles = /* @__PURE__ */ new Set();
    const explicitlyLinkedFiles = /* @__PURE__ */ new Set();
    for (const tag of tags) {
      const nodeList = this.containerEl.getElementsByTagName(tag);
      const children = this.containerEl.children;
      for (let index = 0; index <= nodeList.length; index++) {
        const item = index == nodeList.length ? this.containerEl : nodeList.item(index);
        for (let childNodeIndex = 0; childNodeIndex < item.childNodes.length; childNodeIndex++) {
          const childNode = item.childNodes[childNodeIndex];
          if (childNode.nodeType === Node.TEXT_NODE) {
            let text = childNode.textContent || "";
            if (text.length === 0)
              continue;
            this.linkerCache.reset();
            const additions = [];
            let id = 0;
            for (let i = 0; i <= text.length; i) {
              const codePoint = text.codePointAt(i);
              const char = i < text.length ? String.fromCodePoint(codePoint) : "\n";
              const isWordBoundary = PrefixTree.checkWordBoundary(char);
              if (!this.settings.matchOnlyWholeWords || isWordBoundary) {
                const currentNodes = this.linkerCache.cache.getCurrentMatchNodes(i);
                if (currentNodes.length > 0) {
                  const node = currentNodes[0];
                  const nFrom = node.start;
                  const nTo = node.end;
                  const name = text.slice(nFrom, nTo);
                  const file = node.files.values().next().value;
                  additions.push({
                    id: id++,
                    from: nFrom,
                    to: nTo,
                    text: name,
                    file,
                    isSubWord: !isWordBoundary
                  });
                }
              }
              this.linkerCache.cache.pushChar(char);
              i += char.length;
            }
            additions.sort((a, b) => {
              if (a.from === b.from) {
                return b.to - a.to;
              }
              return a.from - b.from;
            });
            const filteredAdditions = [];
            const additionsToDelete = /* @__PURE__ */ new Map();
            if (this.settings.excludeLinksToRealLinkedFiles) {
              for (const addition of additions) {
                if (explicitlyLinkedFiles.has(addition.file)) {
                  additionsToDelete.set(addition.id, true);
                }
              }
            }
            if (this.settings.onlyLinkOnce) {
              for (const addition of additions) {
                if (linkedFiles.has(addition.file)) {
                  additionsToDelete.set(addition.id, true);
                }
              }
            }
            for (let i = 0; i < additions.length; i++) {
              const addition = additions[i];
              if (additionsToDelete.has(addition.id)) {
                continue;
              }
              for (let j = i + 1; j < additions.length; j++) {
                const otherAddition = additions[j];
                if (otherAddition.from >= addition.to) {
                  break;
                }
                additionsToDelete.set(otherAddition.id, true);
              }
              if (this.settings.onlyLinkOnce) {
                for (let j = i + 1; j < additions.length; j++) {
                  const otherAddition = additions[j];
                  if (additionsToDelete.has(otherAddition.id)) {
                    continue;
                  }
                  if (otherAddition.file.path === addition.file.path) {
                    additionsToDelete.set(otherAddition.id, true);
                  }
                }
              }
            }
            for (const addition of additions) {
              if (!additionsToDelete.has(addition.id)) {
                filteredAdditions.push(addition);
              }
            }
            const parent = childNode.parentElement;
            let lastTo = 0;
            for (let addition of filteredAdditions) {
              linkedFiles.add(addition.file);
              const destName = this.ctx.sourcePath.replace(/(.*).md/, "$1");
              const linkpath = addition.file.path;
              const replacementText = addition.text;
              let span = document.createElement("span");
              span.classList.add("glossary-entry", "virtual-link");
              if (this.settings.applyDefaultLinkStyling) {
                span.classList.add("virtual-link-default");
              }
              let link = this.containerEl.createEl("a");
              link.text = `${replacementText}`;
              link.href = `${linkpath}`;
              link.setAttribute("data-href", `${linkpath}`);
              link.classList.add("internal-link");
              link.classList.add("virtual-link-a");
              link.setAttribute("origin-text", this.text);
              link.target = "_blank";
              link.rel = "noopener";
              span.appendChild(link);
              if (((_b = (_a = this.settings.glossarySuffix) == null ? void 0 : _a.length) != null ? _b : 0) > 0) {
                if (((_d = (_c = this.settings.glossarySuffix) == null ? void 0 : _c.length) != null ? _d : 0) > 0) {
                  if (!addition.isSubWord || !this.settings.suppressSuffixForSubWords) {
                    let icon = document.createElement("sup");
                    icon.textContent = this.settings.glossarySuffix;
                    icon.classList.add("linker-suffix-icon");
                    span.appendChild(icon);
                  }
                }
              }
              if (addition.from > 0) {
                parent == null ? void 0 : parent.insertBefore(document.createTextNode(text.slice(lastTo, addition.from)), childNode);
              }
              parent == null ? void 0 : parent.insertBefore(span, childNode);
              lastTo = addition.to;
            }
            const textLength = text.length;
            if (lastTo < textLength) {
              parent == null ? void 0 : parent.insertBefore(document.createTextNode(text.slice(lastTo)), childNode);
            }
            parent == null ? void 0 : parent.removeChild(childNode);
            childNodeIndex += 1;
          }
        }
      }
    }
  }
};

// linker/liveLinker.ts
var import_language = require("@codemirror/language");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_obsidian4 = require("obsidian");

// node_modules/@flatten-js/interval-tree/dist/main.mjs
var Interval = class Interval2 {
  constructor(low, high) {
    this.low = low;
    this.high = high;
  }
  clone() {
    return new Interval2(this.low, this.high);
  }
  get max() {
    return this.clone();
  }
  less_than(other_interval) {
    return this.low < other_interval.low || this.low === other_interval.low && this.high < other_interval.high;
  }
  equal_to(other_interval) {
    return this.low === other_interval.low && this.high === other_interval.high;
  }
  intersect(other_interval) {
    return !this.not_intersect(other_interval);
  }
  not_intersect(other_interval) {
    return this.high < other_interval.low || other_interval.high < this.low;
  }
  merge(other_interval) {
    return new Interval2(this.low === void 0 ? other_interval.low : this.low < other_interval.low ? this.low : other_interval.low, this.high === void 0 ? other_interval.high : this.high > other_interval.high ? this.high : other_interval.high);
  }
  output() {
    return [this.low, this.high];
  }
  static comparable_max(interval1, interval2) {
    return interval1.merge(interval2);
  }
  static comparable_less_than(val1, val2) {
    return val1 < val2;
  }
};
var RB_TREE_COLOR_RED = 0;
var RB_TREE_COLOR_BLACK = 1;
var Node2 = class {
  constructor(key = void 0, value = void 0, left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {
    this.left = left;
    this.right = right;
    this.parent = parent;
    this.color = color;
    this.item = { key, value };
    if (key && key instanceof Array && key.length === 2) {
      if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {
        let [low, high] = key;
        if (low > high)
          [low, high] = [high, low];
        this.item.key = new Interval(low, high);
      }
    }
    this.max = this.item.key ? this.item.key.max : void 0;
  }
  isNil() {
    return this.item.key === void 0 && this.item.value === void 0 && this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK;
  }
  _value_less_than(other_node) {
    return this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) : this.item.value < other_node.item.value;
  }
  less_than(other_node) {
    if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {
      return this.item.key.less_than(other_node.item.key);
    } else {
      return this.item.key.less_than(other_node.item.key) || this.item.key.equal_to(other_node.item.key) && this._value_less_than(other_node);
    }
  }
  _value_equal(other_node) {
    return this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) : this.item.value === other_node.item.value;
  }
  equal_to(other_node) {
    if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {
      return this.item.key.equal_to(other_node.item.key);
    } else {
      return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);
    }
  }
  intersect(other_node) {
    return this.item.key.intersect(other_node.item.key);
  }
  copy_data(other_node) {
    this.item.key = other_node.item.key;
    this.item.value = other_node.item.value;
  }
  update_max() {
    this.max = this.item.key ? this.item.key.max : void 0;
    if (this.right && this.right.max) {
      const comparable_max = this.item.key.constructor.comparable_max;
      this.max = comparable_max(this.max, this.right.max);
    }
    if (this.left && this.left.max) {
      const comparable_max = this.item.key.constructor.comparable_max;
      this.max = comparable_max(this.max, this.left.max);
    }
  }
  not_intersect_left_subtree(search_node) {
    const comparable_less_than = this.item.key.constructor.comparable_less_than;
    let high = this.left.max.high !== void 0 ? this.left.max.high : this.left.max;
    return comparable_less_than(high, search_node.item.key.low);
  }
  not_intersect_right_subtree(search_node) {
    const comparable_less_than = this.item.key.constructor.comparable_less_than;
    let low = this.right.max.low !== void 0 ? this.right.max.low : this.right.item.key.low;
    return comparable_less_than(search_node.item.key.high, low);
  }
};
var IntervalTree = class {
  constructor() {
    this.root = null;
    this.nil_node = new Node2();
  }
  get size() {
    let count = 0;
    this.tree_walk(this.root, () => count++);
    return count;
  }
  get keys() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push(node.item.key.output ? node.item.key.output() : node.item.key));
    return res;
  }
  get values() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push(node.item.value));
    return res;
  }
  get items() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push({
      key: node.item.key.output ? node.item.key.output() : node.item.key,
      value: node.item.value
    }));
    return res;
  }
  isEmpty() {
    return this.root == null || this.root === this.nil_node;
  }
  clear() {
    this.root = null;
  }
  insert(key, value = key) {
    if (key === void 0)
      return;
    let insert_node = new Node2(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);
    this.tree_insert(insert_node);
    this.recalc_max(insert_node);
    return insert_node;
  }
  exist(key, value = key) {
    let search_node = new Node2(key, value);
    return !!this.tree_search(this.root, search_node);
  }
  remove(key, value = key) {
    let search_node = new Node2(key, value);
    let delete_node = this.tree_search(this.root, search_node);
    if (delete_node) {
      this.tree_delete(delete_node);
    }
    return delete_node;
  }
  search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {
    let search_node = new Node2(interval);
    let resp_nodes = [];
    this.tree_search_interval(this.root, search_node, resp_nodes);
    return resp_nodes.map((node) => outputMapperFn(node.item.value, node.item.key));
  }
  intersect_any(interval) {
    let search_node = new Node2(interval);
    return this.tree_find_any_interval(this.root, search_node);
  }
  forEach(visitor) {
    this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));
  }
  map(callback) {
    const tree = new IntervalTree();
    this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));
    return tree;
  }
  *iterate(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {
    let node;
    if (interval) {
      node = this.tree_search_nearest_forward(this.root, new Node2(interval));
    } else if (this.root) {
      node = this.local_minimum(this.root);
    }
    while (node) {
      yield outputMapperFn(node.item.value, node.item.key);
      node = this.tree_successor(node);
    }
  }
  recalc_max(node) {
    let node_current = node;
    while (node_current.parent != null) {
      node_current.parent.update_max();
      node_current = node_current.parent;
    }
  }
  tree_insert(insert_node) {
    let current_node = this.root;
    let parent_node = null;
    if (this.root == null || this.root === this.nil_node) {
      this.root = insert_node;
    } else {
      while (current_node !== this.nil_node) {
        parent_node = current_node;
        if (insert_node.less_than(current_node)) {
          current_node = current_node.left;
        } else {
          current_node = current_node.right;
        }
      }
      insert_node.parent = parent_node;
      if (insert_node.less_than(parent_node)) {
        parent_node.left = insert_node;
      } else {
        parent_node.right = insert_node;
      }
    }
    this.insert_fixup(insert_node);
  }
  insert_fixup(insert_node) {
    let current_node;
    let uncle_node;
    current_node = insert_node;
    while (current_node !== this.root && current_node.parent.color === RB_TREE_COLOR_RED) {
      if (current_node.parent === current_node.parent.parent.left) {
        uncle_node = current_node.parent.parent.right;
        if (uncle_node.color === RB_TREE_COLOR_RED) {
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          uncle_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent.parent;
        } else {
          if (current_node === current_node.parent.right) {
            current_node = current_node.parent;
            this.rotate_left(current_node);
          }
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          this.rotate_right(current_node.parent.parent);
        }
      } else {
        uncle_node = current_node.parent.parent.left;
        if (uncle_node.color === RB_TREE_COLOR_RED) {
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          uncle_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent.parent;
        } else {
          if (current_node === current_node.parent.left) {
            current_node = current_node.parent;
            this.rotate_right(current_node);
          }
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          this.rotate_left(current_node.parent.parent);
        }
      }
    }
    this.root.color = RB_TREE_COLOR_BLACK;
  }
  tree_delete(delete_node) {
    let cut_node;
    let fix_node;
    if (delete_node.left === this.nil_node || delete_node.right === this.nil_node) {
      cut_node = delete_node;
    } else {
      cut_node = this.tree_successor(delete_node);
    }
    if (cut_node.left !== this.nil_node) {
      fix_node = cut_node.left;
    } else {
      fix_node = cut_node.right;
    }
    fix_node.parent = cut_node.parent;
    if (cut_node === this.root) {
      this.root = fix_node;
    } else {
      if (cut_node === cut_node.parent.left) {
        cut_node.parent.left = fix_node;
      } else {
        cut_node.parent.right = fix_node;
      }
      cut_node.parent.update_max();
    }
    this.recalc_max(fix_node);
    if (cut_node !== delete_node) {
      delete_node.copy_data(cut_node);
      delete_node.update_max();
      this.recalc_max(delete_node);
    }
    if (cut_node.color === RB_TREE_COLOR_BLACK) {
      this.delete_fixup(fix_node);
    }
  }
  delete_fixup(fix_node) {
    let current_node = fix_node;
    let brother_node;
    while (current_node !== this.root && current_node.parent != null && current_node.color === RB_TREE_COLOR_BLACK) {
      if (current_node === current_node.parent.left) {
        brother_node = current_node.parent.right;
        if (brother_node.color === RB_TREE_COLOR_RED) {
          brother_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.color = RB_TREE_COLOR_RED;
          this.rotate_left(current_node.parent);
          brother_node = current_node.parent.right;
        }
        if (brother_node.left.color === RB_TREE_COLOR_BLACK && brother_node.right.color === RB_TREE_COLOR_BLACK) {
          brother_node.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent;
        } else {
          if (brother_node.right.color === RB_TREE_COLOR_BLACK) {
            brother_node.color = RB_TREE_COLOR_RED;
            brother_node.left.color = RB_TREE_COLOR_BLACK;
            this.rotate_right(brother_node);
            brother_node = current_node.parent.right;
          }
          brother_node.color = current_node.parent.color;
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          brother_node.right.color = RB_TREE_COLOR_BLACK;
          this.rotate_left(current_node.parent);
          current_node = this.root;
        }
      } else {
        brother_node = current_node.parent.left;
        if (brother_node.color === RB_TREE_COLOR_RED) {
          brother_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.color = RB_TREE_COLOR_RED;
          this.rotate_right(current_node.parent);
          brother_node = current_node.parent.left;
        }
        if (brother_node.left.color === RB_TREE_COLOR_BLACK && brother_node.right.color === RB_TREE_COLOR_BLACK) {
          brother_node.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent;
        } else {
          if (brother_node.left.color === RB_TREE_COLOR_BLACK) {
            brother_node.color = RB_TREE_COLOR_RED;
            brother_node.right.color = RB_TREE_COLOR_BLACK;
            this.rotate_left(brother_node);
            brother_node = current_node.parent.left;
          }
          brother_node.color = current_node.parent.color;
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          brother_node.left.color = RB_TREE_COLOR_BLACK;
          this.rotate_right(current_node.parent);
          current_node = this.root;
        }
      }
    }
    current_node.color = RB_TREE_COLOR_BLACK;
  }
  tree_search(node, search_node) {
    if (node == null || node === this.nil_node)
      return void 0;
    if (search_node.equal_to(node)) {
      return node;
    }
    if (search_node.less_than(node)) {
      return this.tree_search(node.left, search_node);
    } else {
      return this.tree_search(node.right, search_node);
    }
  }
  tree_search_nearest_forward(node, search_node) {
    let best;
    let curr = node;
    while (curr && curr !== this.nil_node) {
      if (curr.less_than(search_node)) {
        if (curr.intersect(search_node)) {
          best = curr;
          curr = curr.left;
        } else {
          curr = curr.right;
        }
      } else {
        if (!best || curr.less_than(best))
          best = curr;
        curr = curr.left;
      }
    }
    return best || null;
  }
  tree_search_interval(node, search_node, res) {
    if (node != null && node !== this.nil_node) {
      if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {
        this.tree_search_interval(node.left, search_node, res);
      }
      if (node.intersect(search_node)) {
        res.push(node);
      }
      if (node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {
        this.tree_search_interval(node.right, search_node, res);
      }
    }
  }
  tree_find_any_interval(node, search_node) {
    let found = false;
    if (node != null && node !== this.nil_node) {
      if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {
        found = this.tree_find_any_interval(node.left, search_node);
      }
      if (!found) {
        found = node.intersect(search_node);
      }
      if (!found && node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {
        found = this.tree_find_any_interval(node.right, search_node);
      }
    }
    return found;
  }
  local_minimum(node) {
    let node_min = node;
    while (node_min.left != null && node_min.left !== this.nil_node) {
      node_min = node_min.left;
    }
    return node_min;
  }
  local_maximum(node) {
    let node_max = node;
    while (node_max.right != null && node_max.right !== this.nil_node) {
      node_max = node_max.right;
    }
    return node_max;
  }
  tree_successor(node) {
    let node_successor;
    let current_node;
    let parent_node;
    if (node.right !== this.nil_node) {
      node_successor = this.local_minimum(node.right);
    } else {
      current_node = node;
      parent_node = node.parent;
      while (parent_node != null && parent_node.right === current_node) {
        current_node = parent_node;
        parent_node = parent_node.parent;
      }
      node_successor = parent_node;
    }
    return node_successor;
  }
  rotate_left(x) {
    let y = x.right;
    x.right = y.left;
    if (y.left !== this.nil_node) {
      y.left.parent = x;
    }
    y.parent = x.parent;
    if (x === this.root) {
      this.root = y;
    } else {
      if (x === x.parent.left) {
        x.parent.left = y;
      } else {
        x.parent.right = y;
      }
    }
    y.left = x;
    x.parent = y;
    if (x != null && x !== this.nil_node) {
      x.update_max();
    }
    y = x.parent;
    if (y != null && y !== this.nil_node) {
      y.update_max();
    }
  }
  rotate_right(y) {
    let x = y.left;
    y.left = x.right;
    if (x.right !== this.nil_node) {
      x.right.parent = y;
    }
    x.parent = y.parent;
    if (y === this.root) {
      this.root = x;
    } else {
      if (y === y.parent.left) {
        y.parent.left = x;
      } else {
        y.parent.right = x;
      }
    }
    x.right = y;
    y.parent = x;
    if (y !== null && y !== this.nil_node) {
      y.update_max();
    }
    x = y.parent;
    if (x != null && x !== this.nil_node) {
      x.update_max();
    }
  }
  tree_walk(node, action) {
    if (node != null && node !== this.nil_node) {
      this.tree_walk(node.left, action);
      action(node);
      this.tree_walk(node.right, action);
    }
  }
  testRedBlackProperty() {
    let res = true;
    this.tree_walk(this.root, function(node) {
      if (node.color === RB_TREE_COLOR_RED) {
        if (!(node.left.color === RB_TREE_COLOR_BLACK && node.right.color === RB_TREE_COLOR_BLACK)) {
          res = false;
        }
      }
    });
    return res;
  }
  testBlackHeightProperty(node) {
    let height = 0;
    let heightLeft = 0;
    let heightRight = 0;
    if (node.color === RB_TREE_COLOR_BLACK) {
      height++;
    }
    if (node.left !== this.nil_node) {
      heightLeft = this.testBlackHeightProperty(node.left);
    } else {
      heightLeft = 1;
    }
    if (node.right !== this.nil_node) {
      heightRight = this.testBlackHeightProperty(node.right);
    } else {
      heightRight = 1;
    }
    if (heightLeft !== heightRight) {
      throw new Error("Red-black height property violated");
    }
    height += heightLeft;
    return height;
  }
};

// linker/liveLinker.ts
function isDescendant(parent, child, maxDepth = 10) {
  let node = child.parentNode;
  let depth = 0;
  while (node != null && depth < maxDepth) {
    if (node === parent) {
      return true;
    }
    node = node.parentNode;
    depth++;
  }
  return false;
}
var LiveLinkWidget = class extends import_view.WidgetType {
  constructor(text, linkFile, from, to, isSubWord, app, settings) {
    super();
    this.text = text;
    this.linkFile = linkFile;
    this.from = from;
    this.to = to;
    this.isSubWord = isSubWord;
    this.app = app;
    this.settings = settings;
  }
  createInternalLinkSpan() {
    var _a, _b;
    const note = this.linkFile;
    const linkText = this.text;
    let linkHref = "";
    try {
      linkHref = note.path;
    } catch (e) {
      console.error(e);
    }
    const span = document.createElement("span");
    const link = document.createElement("a");
    link.href = linkHref;
    link.textContent = linkText;
    link.target = "_blank";
    link.rel = "noopener noreferrer";
    link.setAttribute("from", this.from.toString());
    link.setAttribute("to", this.to.toString());
    link.setAttribute("origin-text", this.text);
    link.classList.add("internal-link", "virtual-link-a");
    span.classList.add("glossary-entry", "virtual-link");
    if (this.settings.applyDefaultLinkStyling) {
      span.classList.add("virtual-link-default");
    }
    span.appendChild(link);
    if (((_b = (_a = this.settings.glossarySuffix) == null ? void 0 : _a.length) != null ? _b : 0) > 0) {
      if (!this.isSubWord || !this.settings.suppressSuffixForSubWords) {
        let icon = document.createElement("sup");
        icon.textContent = this.settings.glossarySuffix;
        icon.classList.add("linker-suffix-icon");
        span.appendChild(icon);
      }
    }
    return span;
  }
  toDOM(view) {
    const div = this.createInternalLinkSpan();
    return div;
  }
};
var AutoLinkerPlugin = class {
  constructor(view, app, settings, updateManager) {
    this.lastCursorPos = 0;
    this.lastActiveFile = "";
    this.lastViewUpdate = null;
    this.viewUpdateDomToFileMap = /* @__PURE__ */ new Map();
    this.app = app;
    this.settings = settings;
    const { vault } = this.app;
    this.vault = vault;
    this.linkerCache = LinkerCache.getInstance(app, this.settings);
    this.decorations = this.buildDecorations(view);
    updateManager.registerCallback(() => {
      if (this.lastViewUpdate) {
        this.update(this.lastViewUpdate, true);
      }
    });
  }
  update(update, force = false) {
    var _a;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    let updateIsOnActiveView = false;
    if (this.settings.fixIMEProblem || this.settings.excludeLinksInCurrentLine || this.settings.excludeLinksToOwnNote) {
      const domFromUpdate = update.view.dom;
      const domFromWorkspace = activeView == null ? void 0 : activeView.contentEl;
      updateIsOnActiveView = domFromWorkspace ? isDescendant(domFromWorkspace, domFromUpdate, 3) : false;
      if (updateIsOnActiveView) {
        this.viewUpdateDomToFileMap.set(domFromUpdate, activeView == null ? void 0 : activeView.file);
      }
    }
    const cursorPos = update.view.state.selection.main.from;
    const activeFile = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path;
    const fileChanged = activeFile != this.lastActiveFile;
    if (force || this.lastCursorPos != cursorPos || update.docChanged || fileChanged || update.viewportChanged) {
      this.lastCursorPos = cursorPos;
      this.linkerCache.updateCache(force);
      this.decorations = this.buildDecorations(update.view, updateIsOnActiveView);
      this.lastActiveFile = activeFile != null ? activeFile : "";
    }
    this.lastViewUpdate = update;
  }
  destroy() {
  }
  buildDecorations(view, viewIsActive = true) {
    const builder = new import_state.RangeSetBuilder();
    if (!this.settings.linkerActivated) {
      return builder.finish();
    }
    const dom = view.dom;
    const mappedFile = this.viewUpdateDomToFileMap.get(dom);
    const explicitlyLinkedFiles = /* @__PURE__ */ new Set();
    const alreadyLinkedFiles = /* @__PURE__ */ new Set();
    for (let { from, to } of view.visibleRanges) {
      this.linkerCache.reset();
      const text = view.state.doc.sliceString(from, to);
      const additions = [];
      let id = 0;
      for (let i = 0; i <= text.length; i) {
        const codePoint = text.codePointAt(i);
        const char = i < text.length ? String.fromCodePoint(codePoint) : "\n";
        const isWordBoundary = PrefixTree.checkWordBoundary(char);
        if (!this.settings.matchOnlyWholeWords || isWordBoundary) {
          const currentNodes = this.linkerCache.cache.getCurrentMatchNodes(i, this.settings.excludeLinksToOwnNote ? mappedFile : null);
          if (currentNodes.length > 0) {
            for (const node of currentNodes) {
              const nFrom = node.start;
              const nTo = node.end;
              const name = text.slice(nFrom, nTo);
              const aFrom = from + nFrom;
              const aTo = from + nTo;
              node.files.forEach((file) => {
                additions.push({
                  id: id++,
                  from: aFrom,
                  to: aTo,
                  file,
                  widget: new LiveLinkWidget(name, file, aFrom, aTo, !isWordBoundary, this.app, this.settings)
                });
              });
            }
          }
        }
        this.linkerCache.cache.pushChar(char);
        i += char.length;
      }
      additions.sort((a, b) => {
        if (a.from === b.from) {
          return b.to - a.to;
        }
        return a.from - b.from;
      });
      const excludedIntervalTree = new IntervalTree();
      const excludedTypes = [
        "codeblock",
        "code-block",
        "inline-code",
        "internal-link",
        "link",
        "url"
      ];
      if (!this.settings.includeHeaders) {
        excludedTypes.push("header-");
      }
      const app = this.app;
      (0, import_language.syntaxTree)(view.state).iterate({
        from,
        to,
        enter(node) {
          var _a;
          const type = node.type.name;
          for (const excludedType of excludedTypes) {
            if (type.contains(excludedType)) {
              excludedIntervalTree.insert([node.from, node.to]);
              if (type.contains("internal-link_link-has-alias") || type.endsWith("internal-link") || type == "string_url") {
                const text2 = view.state.doc.sliceString(node.from, node.to);
                const linkedFile = app.metadataCache.getFirstLinkpathDest(text2, (_a = mappedFile == null ? void 0 : mappedFile.path) != null ? _a : "");
                if (linkedFile) {
                  explicitlyLinkedFiles.add(linkedFile);
                }
              }
            }
          }
        }
      });
      const filteredAdditions = [];
      const additionsToDelete = /* @__PURE__ */ new Map();
      if (this.settings.excludeLinksToRealLinkedFiles) {
        for (const addition of additions) {
          if (explicitlyLinkedFiles.has(addition.file)) {
            additionsToDelete.set(addition.id, true);
          }
        }
      }
      if (this.settings.onlyLinkOnce) {
        for (const addition of additions) {
          if (alreadyLinkedFiles.has(addition.file)) {
            additionsToDelete.set(addition.id, true);
          }
        }
      }
      for (let i = 0; i < additions.length; i++) {
        const addition = additions[i];
        if (additionsToDelete.has(addition.id)) {
          continue;
        }
        const overlaps = excludedIntervalTree.search([addition.from, addition.to]);
        if (overlaps.length > 0) {
          additionsToDelete.set(addition.id, true);
          continue;
        }
        for (let j = i + 1; j < additions.length; j++) {
          const otherAddition = additions[j];
          if (otherAddition.from >= addition.to) {
            break;
          }
          additionsToDelete.set(otherAddition.id, true);
        }
        if (this.settings.onlyLinkOnce) {
          for (let j = i + 1; j < additions.length; j++) {
            const otherAddition = additions[j];
            if (additionsToDelete.has(otherAddition.id)) {
              continue;
            }
            if (otherAddition.file === addition.file) {
              additionsToDelete.set(otherAddition.id, true);
            }
          }
        }
      }
      for (const addition of additions) {
        if (!additionsToDelete.has(addition.id)) {
          filteredAdditions.push(addition);
          alreadyLinkedFiles.add(addition.file);
        }
      }
      const cursorPos = view.state.selection.main.from;
      const excludeLine = viewIsActive && this.settings.excludeLinksInCurrentLine;
      const fixIMEProblem = viewIsActive && this.settings.fixIMEProblem;
      let needImeFix = false;
      const lineStart = view.state.doc.lineAt(cursorPos).from;
      const lineEnd = view.state.doc.lineAt(cursorPos).to;
      filteredAdditions.forEach((addition) => {
        const [from2, to2] = [addition.from, addition.to];
        const cursorNearby = cursorPos >= from2 - 0 && cursorPos <= to2 + 0;
        const additionIsInCurrentLine = from2 >= lineStart && to2 <= lineEnd;
        if (fixIMEProblem) {
          needImeFix = true;
          if (additionIsInCurrentLine && cursorPos > to2) {
            let gapString = view.state.sliceDoc(to2, cursorPos);
            let strBeforeAdd = view.state.sliceDoc(lineStart, from2);
            const regAddInLineStart = /(^\s*$)|(^\s*- +$)|(^\s*#{1,6} $)|(^\s*>+ *$)|(^\s*- +#{1,6} +$)|(^\s*> \[![\w-]+\][+-]? +$)/;
            if (!regAddInLineStart.test(strBeforeAdd)) {
              needImeFix = false;
            } else {
              const regStrMayIMEon = /^[a-zA-Z]+[a-zA-Z' ]*[a-zA-Z]$|^[a-zA-Z]$/;
              if (!regStrMayIMEon.test(gapString) || /[' ]{2}/.test(gapString)) {
                needImeFix = false;
              }
            }
          } else {
            needImeFix = false;
          }
        }
        if (!cursorNearby && !needImeFix && !(excludeLine && additionIsInCurrentLine)) {
          builder.add(from2, to2, import_view.Decoration.replace({
            widget: addition.widget
          }));
        }
      });
    }
    return builder.finish();
  }
};
var pluginSpec = {
  decorations: (value) => value.decorations
};
var liveLinkerPlugin = (app, settings, updateManager) => {
  return import_view.ViewPlugin.define((editorView) => {
    return new AutoLinkerPlugin(editorView, app, settings, updateManager);
  }, pluginSpec);
};

// main.ts
var DEFAULT_SETTINGS = {
  linkerActivated: true,
  matchOnlyWholeWords: false,
  suppressSuffixForSubWords: false,
  includeAllFiles: true,
  linkerDirectories: ["Glossary"],
  excludedDirectories: [],
  glossarySuffix: "\u{1F517}",
  useMarkdownLinks: false,
  applyDefaultLinkStyling: true,
  includeHeaders: true,
  matchCaseSensitive: false,
  tagToIgnoreCase: "linker-ignore-case",
  tagToMatchCase: "linker-match-case",
  tagToExcludeFile: "linker-exclude",
  tagToIncludeFile: "linker-include",
  excludeLinksToOwnNote: true,
  fixIMEProblem: false,
  excludeLinksInCurrentLine: false,
  onlyLinkOnce: true,
  excludeLinksToRealLinkedFiles: true,
  includeAliases: true
};
var LinkerPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.updateManager = new ExternalUpdateManager();
  }
  async onload() {
    await this.loadSettings();
    this.updateManager.registerCallback(() => {
      LinkerCache.getInstance(this.app, this.settings).clearCache();
    });
    this.registerMarkdownPostProcessor((element, context) => {
      context.addChild(new GlossaryLinker(this.app, this.settings, context, element));
    });
    this.registerEditorExtension(liveLinkerPlugin(this.app, this.settings, this.updateManager));
    this.addSettingTab(new LinkerSettingTab(this.app, this));
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file, source) => this.addContextMenuItem(menu, file, source)));
    this.addCommand({
      id: "activate-virtual-linker",
      name: "Activate Virtual Linker",
      checkCallback: (checking) => {
        if (!this.settings.linkerActivated) {
          if (!checking) {
            this.updateSettings({ linkerActivated: true });
            this.updateManager.update();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "deactivate-virtual-linker",
      name: "Deactivate Virtual Linker",
      checkCallback: (checking) => {
        if (this.settings.linkerActivated) {
          if (!checking) {
            this.updateSettings({ linkerActivated: false });
            this.updateManager.update();
          }
          return true;
        }
        return false;
      }
    });
  }
  addContextMenuItem(menu, file, source) {
    if (!file) {
      return;
    }
    const that = this;
    const app = this.app;
    const updateManager = this.updateManager;
    const settings = this.settings;
    const fetcher = new LinkerMetaInfoFetcher(app, settings);
    const isDirectory = app.vault.getAbstractFileByPath(file.path) instanceof import_obsidian5.TFolder;
    if (!isDirectory) {
      let contextMenuHandler = function(event) {
        const targetElement = event.target;
        if (!targetElement || !(targetElement instanceof HTMLElement)) {
          console.error("No target element");
          return;
        }
        const isVirtualLink = targetElement.classList.contains("virtual-link-a");
        const from = parseInt(targetElement.getAttribute("from") || "-1");
        const to = parseInt(targetElement.getAttribute("to") || "-1");
        if (from === -1 || to === -1) {
          menu.addItem((item) => {
            item.setTitle("[Virtual Linker] Converting to real link is not possible in read mode, switch to edit or source mode to convert.").setIcon("link");
          });
        } else if (isVirtualLink) {
          menu.addItem((item) => {
            item.setTitle("[Virtual Linker] Convert to real link").setIcon("link").onClick(() => {
              var _a, _b;
              const from2 = parseInt(targetElement.getAttribute("from") || "-1");
              const to2 = parseInt(targetElement.getAttribute("to") || "-1");
              if (from2 === -1 || to2 === -1) {
                console.error("No from or to position");
                return;
              }
              const text = targetElement.getAttribute("origin-text") || "";
              const target = file;
              const activeFile = app.workspace.getActiveFile();
              const activeFilePath = (_a = activeFile == null ? void 0 : activeFile.path) != null ? _a : "";
              if (!activeFile) {
                console.error("No active file");
                return;
              }
              const replacementPath = app.metadataCache.fileToLinktext(target, activeFilePath);
              let replacement = "";
              if (replacementPath === text) {
                replacement = `[[${replacementPath}]]`;
              } else {
                if (settings.useMarkdownLinks) {
                  replacement = `[${text}](${replacementPath})`;
                } else {
                  replacement = `[[${replacementPath}|${text}]]`;
                }
              }
              const editor = (_b = app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView)) == null ? void 0 : _b.editor;
              const fromEditorPos = editor == null ? void 0 : editor.offsetToPos(from2);
              const toEditorPos = editor == null ? void 0 : editor.offsetToPos(to2);
              if (!fromEditorPos || !toEditorPos) {
                console.warn("No editor positions");
                return;
              }
              editor == null ? void 0 : editor.replaceRange(replacement, fromEditorPos, toEditorPos);
            });
          });
        }
        document.removeEventListener("contextmenu", contextMenuHandler);
      };
      const metaInfo = fetcher.getMetaInfo(file);
      if (!metaInfo.excludeFile && (metaInfo.includeAllFiles || metaInfo.includeFile || metaInfo.isInIncludedDir)) {
        menu.addItem((item) => {
          item.setTitle("[Virtual Linker] Exclude this file").setIcon("trash").onClick(async () => {
            const target = file;
            const targetFile = app.vault.getFileByPath(target.path);
            if (!targetFile) {
              console.error("No target file");
              return;
            }
            const fileCache = app.metadataCache.getFileCache(targetFile);
            const frontmatter = (fileCache == null ? void 0 : fileCache.frontmatter) || {};
            const tag = settings.tagToExcludeFile;
            let tags = frontmatter["tags"];
            if (typeof tags === "string") {
              tags = [tags];
            }
            if (!Array.isArray(tags)) {
              tags = [];
            }
            if (!tags.includes(tag)) {
              await app.fileManager.processFrontMatter(targetFile, (frontMatter) => {
                if (!frontMatter.tags) {
                  frontMatter.tags = /* @__PURE__ */ new Set();
                }
                const currentTags = [...frontMatter.tags];
                frontMatter.tags = /* @__PURE__ */ new Set([...currentTags, tag]);
                const includeTag = settings.tagToIncludeFile;
                if (frontMatter.tags.has(includeTag)) {
                  frontMatter.tags.delete(includeTag);
                }
              });
              updateManager.update();
            }
          });
        });
      } else if (!metaInfo.includeFile && (!metaInfo.includeAllFiles || metaInfo.excludeFile || metaInfo.isInExcludedDir)) {
        menu.addItem((item) => {
          item.setTitle("[Virtual Linker] Include this file").setIcon("plus").onClick(async () => {
            const target = file;
            const targetFile = app.vault.getFileByPath(target.path);
            if (!targetFile) {
              console.error("No target file");
              return;
            }
            const fileCache = app.metadataCache.getFileCache(targetFile);
            const frontmatter = (fileCache == null ? void 0 : fileCache.frontmatter) || {};
            const tag = settings.tagToIncludeFile;
            let tags = frontmatter["tags"];
            if (typeof tags === "string") {
              tags = [tags];
            }
            if (!Array.isArray(tags)) {
              tags = [];
            }
            if (!tags.includes(tag)) {
              await app.fileManager.processFrontMatter(targetFile, (frontMatter) => {
                if (!frontMatter.tags) {
                  frontMatter.tags = /* @__PURE__ */ new Set();
                }
                const currentTags = [...frontMatter.tags];
                frontMatter.tags = /* @__PURE__ */ new Set([...currentTags, tag]);
                const excludeTag = settings.tagToExcludeFile;
                if (frontMatter.tags.has(excludeTag)) {
                  frontMatter.tags.delete(excludeTag);
                }
              });
              updateManager.update();
            }
          });
        });
      }
      document.addEventListener("contextmenu", contextMenuHandler, { once: true });
    } else {
      const path = file.path + "/";
      const isInIncludedDir = fetcher.includeDirPattern.test(path);
      const isInExcludedDir = fetcher.excludeDirPattern.test(path);
      if (fetcher.includeAllFiles && !isInExcludedDir || isInIncludedDir) {
        menu.addItem((item) => {
          item.setTitle("[Virtual Linker] Exclude this directory").setIcon("trash").onClick(async () => {
            const target = file;
            const targetFolder = app.vault.getAbstractFileByPath(target.path);
            if (!targetFolder) {
              console.error("No target folder");
              return;
            }
            const newExcludedDirs = Array.from(/* @__PURE__ */ new Set([...settings.excludedDirectories, targetFolder.name]));
            const newIncludedDirs = settings.linkerDirectories.filter((dir) => dir !== targetFolder.name);
            await this.updateSettings({ linkerDirectories: newIncludedDirs, excludedDirectories: newExcludedDirs });
            updateManager.update();
          });
        });
      } else if (!fetcher.includeAllFiles && !isInIncludedDir || isInExcludedDir) {
        menu.addItem((item) => {
          item.setTitle("[Virtual Linker] Include this directory").setIcon("plus").onClick(async () => {
            const target = file;
            const targetFolder = app.vault.getAbstractFileByPath(target.path);
            if (!targetFolder) {
              console.error("No target folder");
              return;
            }
            const newExcludedDirs = settings.excludedDirectories.filter((dir) => dir !== targetFolder.name);
            const newIncludedDirs = Array.from(/* @__PURE__ */ new Set([...settings.linkerDirectories, targetFolder.name]));
            await this.updateSettings({ linkerDirectories: newIncludedDirs, excludedDirectories: newExcludedDirs });
            updateManager.update();
          });
        });
      }
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const fileContent = await this.app.vault.adapter.read(this.app.vault.configDir + "/app.json");
    const appSettings = JSON.parse(fileContent);
    this.settings.useMarkdownLinks = appSettings.useMarkdownLinks;
  }
  async updateSettings(settings = {}) {
    Object.assign(this.settings, settings);
    await this.saveData(this.settings);
    this.updateManager.update();
  }
};
var LinkerSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian5.Setting(containerEl).setName("Activate Virtual Linker").addToggle((toggle) => toggle.setValue(this.plugin.settings.linkerActivated).onChange(async (value) => {
      await this.plugin.updateSettings({ linkerActivated: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Matching behavior").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Include aliases").setDesc("If activated, the virtual linker will also include aliases for the files.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeAliases).onChange(async (value) => {
      await this.plugin.updateSettings({ includeAliases: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Only link once").setDesc("If activated, there will not be several identical virtual links in the same note (Wikipedia style).").addToggle((toggle) => toggle.setValue(this.plugin.settings.onlyLinkOnce).onChange(async (value) => {
      await this.plugin.updateSettings({ onlyLinkOnce: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Exclude links to real linked files").setDesc("If activated, there will be no links to files that are already linked in the note by real links.").addToggle((toggle) => toggle.setValue(this.plugin.settings.excludeLinksToRealLinkedFiles).onChange(async (value) => {
      await this.plugin.updateSettings({ excludeLinksToRealLinkedFiles: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Case sensitive").setDesc("If activated, the matching is case sensitive.").addToggle((toggle) => toggle.setValue(this.plugin.settings.matchCaseSensitive).onChange(async (value) => {
      await this.plugin.updateSettings({ matchCaseSensitive: value });
      this.display();
    }));
    if (this.plugin.settings.matchCaseSensitive) {
      new import_obsidian5.Setting(containerEl).setName("Tag to ignore case").setDesc("By adding this tag to a file, the linker will ignore the case for the file.").addText((text) => text.setValue(this.plugin.settings.tagToIgnoreCase).onChange(async (value) => {
        await this.plugin.updateSettings({ tagToIgnoreCase: value });
      }));
    } else {
      new import_obsidian5.Setting(containerEl).setName("Tag to match case").setDesc("By adding this tag to a file, the linker will match the case for the file.").addText((text) => text.setValue(this.plugin.settings.tagToMatchCase).onChange(async (value) => {
        await this.plugin.updateSettings({ tagToMatchCase: value });
      }));
    }
    new import_obsidian5.Setting(containerEl).setName("Include headers").setDesc("If activated, headers (so your lines beginning with at least one `#`) are included for virtual links.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeHeaders).onChange(async (value) => {
      await this.plugin.updateSettings({ includeHeaders: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Match only whole words").setDesc("If activated, only whole words are matched. Otherwise, every part of a word is found.").addToggle((toggle) => toggle.setValue(this.plugin.settings.matchOnlyWholeWords).onChange(async (value) => {
      await this.plugin.updateSettings({ matchOnlyWholeWords: value });
      this.display();
    }));
    if (!this.plugin.settings.matchOnlyWholeWords) {
      new import_obsidian5.Setting(containerEl).setName("Suppress suffix for sub words").setDesc("If activated, the suffix is not added to links for subwords, but only for complete matches.").addToggle((toggle) => toggle.setValue(this.plugin.settings.suppressSuffixForSubWords).onChange(async (value) => {
        await this.plugin.updateSettings({ suppressSuffixForSubWords: value });
      }));
    }
    new import_obsidian5.Setting(containerEl).setName("Fix IME problem").setDesc("If activated, there will be no links in the current line start which is followed immediately by the Input Method Editor (IME). This is the recommended setting if you are using IME (input method editor) for typing, e.g. for chinese characters, because instant linking might interfere with IME.").addToggle((toggle) => toggle.setValue(this.plugin.settings.fixIMEProblem).onChange(async (value) => {
      await this.plugin.updateSettings({ fixIMEProblem: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Avoid linking in current line").setDesc("If activated, there will be no links in the current line.").addToggle((toggle) => toggle.setValue(this.plugin.settings.excludeLinksInCurrentLine).onChange(async (value) => {
      await this.plugin.updateSettings({ excludeLinksInCurrentLine: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Matched files").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Include all files").setDesc("Include all files for the virtual linker.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeAllFiles).onChange(async (value) => {
      await this.plugin.updateSettings({ includeAllFiles: value });
      this.display();
    }));
    if (!this.plugin.settings.includeAllFiles) {
      new import_obsidian5.Setting(containerEl).setName("Glossary linker directories").setDesc("Directories to include for the virtual linker (separated by new lines).").addTextArea((text) => {
        let setValue = "";
        try {
          setValue = this.plugin.settings.linkerDirectories.join("\n");
        } catch (e) {
          console.warn(e);
        }
        text.setPlaceholder("List of directory names (separated by new line)").setValue(setValue).onChange(async (value) => {
          this.plugin.settings.linkerDirectories = value.split("\n").map((x) => x.trim()).filter((x) => x.length > 0);
          await this.plugin.updateSettings();
        });
        text.inputEl.addClass("linker-settings-text-box");
      });
    } else {
      new import_obsidian5.Setting(containerEl).setName("Excluded directories").setDesc("Directories to exclude for the virtual linker (separated by new lines).").addTextArea((text) => {
        let setValue = "";
        try {
          setValue = this.plugin.settings.excludedDirectories.join("\n");
        } catch (e) {
          console.warn(e);
        }
        text.setPlaceholder("List of directory names (separated by new line)").setValue(setValue).onChange(async (value) => {
          this.plugin.settings.excludedDirectories = value.split("\n").map((x) => x.trim()).filter((x) => x.length > 0);
          await this.plugin.updateSettings();
        });
        text.inputEl.addClass("linker-settings-text-box");
      });
    }
    new import_obsidian5.Setting(containerEl).setName("Tag to include file").setDesc("Tag to explicitly include the file for the linker.").addText((text) => text.setValue(this.plugin.settings.tagToIncludeFile).onChange(async (value) => {
      await this.plugin.updateSettings({ tagToIncludeFile: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Tag to ignore file").setDesc("Tag to ignore the file for the linker.").addText((text) => text.setValue(this.plugin.settings.tagToExcludeFile).onChange(async (value) => {
      await this.plugin.updateSettings({ tagToExcludeFile: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Exclude self-links to the current note").setDesc("If toggled, links to the note itself are excluded from the linker. (This might not work in preview windows.)").addToggle((toggle) => toggle.setValue(this.plugin.settings.excludeLinksToOwnNote).onChange(async (value) => {
      await this.plugin.updateSettings({ excludeLinksToOwnNote: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Link style").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Virtual link suffix").setDesc("The suffix to add to auto generated virtual links.").addText((text) => text.setValue(this.plugin.settings.glossarySuffix).onChange(async (value) => {
      await this.plugin.updateSettings({ glossarySuffix: value });
    }));
    new import_obsidian5.Setting(containerEl).setName("Apply default link styling").setDesc("If toggled, the default link styling will be applied to virtual links. Furthermore, you can style the links yourself with a CSS-snippet affecting the class `virtual-link`. (Find the CSS snippet directory at Appearance -> CSS Snippets -> Open snippets folder)").addToggle((toggle) => toggle.setValue(this.plugin.settings.applyDefaultLinkStyling).onChange(async (value) => {
      await this.plugin.updateSettings({ applyDefaultLinkStyling: value });
    }));
  }
};
